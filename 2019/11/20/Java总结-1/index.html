<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="2aen8txJ9makMaGgtEKHpowVyKdkJYiySE3ojNCZAwU" />





  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java总结-1">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结-1">
<meta property="og:url" content="https://damaoguo.github.io/2019/11/20/Java总结-1/index.html">
<meta property="og:site_name" content="MaoGuo&#39;s Blog">
<meta property="og:description" content="Java总结-1">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/compare.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/qiceng.gif">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/device.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/protocol.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/woshou.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/network/huishou.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/tcp.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/udp.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/ip.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/request.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/yongsekongzhi.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/ip.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/network/epoll.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/Java总结-1/Coroutines.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//os/fork-example.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//os/yemianzhihuan.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/bio.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/nonblocking-io.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/multiplexing.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/asynchronous.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/io-comparison.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/BEFORE-DMA.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/DMA.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/read_write.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/mmap_write.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/zero_copy_1.png">
<meta property="og:image" content="https://damaoguo.github.io/2019/11/20/Java总结-1/sg-dma.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//basic/btree.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//basic/bplustree.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//algo/headsort.gif">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//algorithm/Catalan.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//algorithm/sortmethod.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/Red-black_tree_example.png">
<meta property="og:updated_time" content="2021-06-01T15:56:40.793Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结-1">
<meta name="twitter:description" content="Java总结-1">
<meta name="twitter:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/compare.png">






  <link rel="canonical" href="https://damaoguo.github.io/2019/11/20/Java总结-1/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java总结-1 | MaoGuo's Blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ea8bf9b92c205ae2c147d91b5242a6b0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/damaoguo/damaoguo.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MaoGuo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://damaoguo.github.io/2019/11/20/Java总结-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="袤锅">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/boy.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaoGuo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java总结-1
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-20 15:20:53" itemprop="dateCreated datePublished" datetime="2019-11-20T15:20:53+08:00">2019-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-06-01 23:56:40" itemprop="dateModified" datetime="2021-06-01T23:56:40+08:00">2021-06-01</time>
              
            
          </span>

          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Java总结-1</p>
<a id="more"></a>
<h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><h4 id="1-OSI、TCP-IP、五层体系结构联系与区别？"><a href="#1-OSI、TCP-IP、五层体系结构联系与区别？" class="headerlink" title="1.OSI、TCP/IP、五层体系结构联系与区别？"></a>1.OSI、TCP/IP、五层体系结构联系与区别？</h4><p>（1）三种比较？</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/compare.png" alt="img"></p>
<p>（2）七层结构细节？</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/qiceng.gif" alt="img"></p>
<p>（3）每一层对应的设备？</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/device.png" alt="img"></p>
<h4 id="2-说一说TCP-IP协议簇？"><a href="#2-说一说TCP-IP协议簇？" class="headerlink" title="2.说一说TCP/IP协议簇？"></a>2.说一说TCP/IP协议簇？</h4><p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/protocol.png" alt="img"></p>
<ul>
<li>应用层（它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。）<ul>
<li>SNMP</li>
<li>SMTP</li>
</ul>
</li>
<li>传输层（向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。）</li>
<li>网络层（通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。）<ul>
<li>ICMP</li>
<li>IGMP</li>
<li>RIP</li>
<li>BGP</li>
<li>OSPF</li>
<li>IP</li>
</ul>
</li>
<li>链路层（通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。）<ul>
<li>ARP，RARP</li>
</ul>
</li>
</ul>
<h4 id="3-TCP三次握手的过程？"><a href="#3-TCP三次握手的过程？" class="headerlink" title="3.TCP三次握手的过程？"></a>3.<strong>TCP三次握手的过程？</strong></h4><blockquote>
<p>握手过程可以由客户端调用socket开启，客户端发送SYN和Seq，closed状态变换为SYN_SEND状态，服务器端由LISTEN状态变换为SYN_RECV状态，服务端回送SYN+ACK，客户端接收，客户端状态变为Established，客户端发送ACK，服务端接收到ACK，状态变为Established，至此，TCP三次握手的过程就完成了。 </p>
<p>（1）第一次握手：服务端确定（服务端可以接收数据，客户端可以发送数据） </p>
<p>（2）第二次握手：客户端确定（服务端可以发送数据，服务端可以接收数据） </p>
<p>（3）第三次握手：服务端确定（客户端可以接收数据） </p>
<p>以上，（1）（2）（3）是的双方确定彼此可以接收和发送数据。</p>
</blockquote>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/woshou.png" alt="img"></p>
<h4 id="4-TCP四次挥手的过程？"><a href="#4-TCP四次挥手的过程？" class="headerlink" title="4.TCP四次挥手的过程？"></a>4.TCP四次挥手的过程？</h4><ul>
<li>关闭连接的过程可以由服务端和客户端的任何一方发起，发起的一方状态变化为：</li>
</ul>
<p>Established———&gt;FIN_WAIT_1———&gt;FIN_WAIT_2———&gt;TIME_WAIT———&gt;CLOSED;</p>
<ul>
<li>被动关闭的一方的状态变化为：</li>
</ul>
<p>Establised———&gt;CLOSE_WAIT———&gt;LAST_ACK———&gt;CLOSED.</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/network/huishou.png" alt="img"></p>
<h4 id="5-TCP在三次握手的过程中是如何超时重传的？"><a href="#5-TCP在三次握手的过程中是如何超时重传的？" class="headerlink" title="5.TCP在三次握手的过程中是如何超时重传的？"></a>5.TCP在三次握手的过程中是如何超时重传的？</h4><blockquote>
<p>(1) 如果第一个包，A发送给B请求建立连接的报文(SYN)如果丢掉了，A会周期性的超时重传，直到B发出确认(SYN+ACK)；<br>(2) 如果第二个包，B发送给A的确认报文(SYN+ACK)如果丢掉了，B会周期性的超时重传，直到A发出确认(ACK)；<br>(3) 如果第三个包，A发送给B的确认报文(ACK)如果丢掉了，</p>
<pre><code>- A在发送完确认报文之后，单方面会进入ESTABLISHED的状态，B还是SYN_RCVD状态
- 如果此时双方都没有数据需要发送，B会周期性的超时发送(SYN+ACK)，直到收到A的确认报文(ACK)，此时B也进入ESTABLISHED状态，双方可以发送数据；
- 如果A有数据发送，A发送的是(ACK+DATA)，B会在收到这个数据包的时候自动切换到ESTABLISHED状态，并接受数据(DATA)；
- 如果这个时候B要发送数据，B是发送不了数据的，会周期性的超时重传(SYN+ACK)直到收到A的确认(ACK)B才能发送数据。
</code></pre></blockquote>
<h4 id="6-为什么要三次握手，四次挥手？"><a href="#6-为什么要三次握手，四次挥手？" class="headerlink" title="6.为什么要三次握手，四次挥手？"></a>6.<strong>为什么要三次握手，四次挥手？</strong></h4><p>（1）为什么要进行三次握手？</p>
<p>三次握手的目的是为了建立可靠的通信信道，简单地来说就是双方确认自己与对方的发送和接收是正常的。</p>
<p><strong>这是防止已失效的连接请求报文段突然又传送到了B而引发错误。</strong> 举例，客户端A向服务端B发送数据，受到网络状态的影响，可能A发送的数据B很久以后才收到（实际上A已经通过重传机制重新发送了），当这个阻塞的数据到来的时候，B就会误以为这是一个新的连接，则B将等待A，但是实际上A并没有发起新的请求，这就导致了资源的浪费。 </p>
<p>（2）为什么要进行四次挥手？ TCP通信是一个双工通信，在结束连接的时候FIN和ACK是分开发送的，A向B发送FIN仅仅表示A不在发送数据，并不表示自己不在接收数据，同理，B向A发送FIN仅仅表示B不在发送数据，但是自己是可以接收数据的。</p>
<p>为什么要在发起端加上TIME_WAIT？<strong>是为了保证ACK丢失的时候可以重传</strong>。客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。</p>
<h4 id="7-在浏览器地址栏输入一个url到浏览器返回页面的过程？"><a href="#7-在浏览器地址栏输入一个url到浏览器返回页面的过程？" class="headerlink" title="7.在浏览器地址栏输入一个url到浏览器返回页面的过程？"></a>7.<strong>在浏览器地址栏输入一个url到浏览器返回页面的过程？</strong></h4><blockquote>
<ul>
<li>浏览器分析超链指向页面的 URL。</li>
<li>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的 IP 地址。</li>
<li>域名系统 DNS 解析出清华大学服务器的 IP 地址。</li>
<li>浏览器与服务器建立 TCP 连接</li>
<li>浏览器发出取文件命令：GET /chn/yxsz/index.htm。(HTTP)</li>
<li>服务器给出响应，把文件 index.htm 发给浏览器。</li>
<li>TCP 连接释放。</li>
<li>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</li>
</ul>
</blockquote>
<h4 id="8-说一说在三次握手的时候可能存在的安全问题？"><a href="#8-说一说在三次握手的时候可能存在的安全问题？" class="headerlink" title="8.说一说在三次握手的时候可能存在的安全问题？"></a>8.<strong>说一说在三次握手的时候可能存在的安全问题？</strong></h4><p>当第二次握手后，服务端将会进入SYN_RECV状态（又叫做半连接状态），通过伪造客户端的地址，这个时候服务器端一直在等待客户端返回ACK，但是由于地址是伪造的，所以根本就无法收到ACK。当这种伪造的连接数量大的时候就会导致DDOS。</p>
<h4 id="9-域名解析"><a href="#9-域名解析" class="headerlink" title="9.域名解析"></a>9.域名解析</h4><p>m.xyz.com需要查找y.abc.com的IP地址：</p>
<blockquote>
<ul>
<li><p>主机m.xyz.com向本地域名服务器进行递归查询。</p>
<blockquote>
<p>主机向本地域名服务器查询时一般使用递归查询。</p>
<ul>
<li><strong>递归查询</strong>：就是如果本地域名服务器没有所需域名的IP地址，本地域名服务器就以客户的方式向其他根域名服务器继续查询，而不是主机自己进行查询。返回给客户的是解析好的ip。（查查查，一直查到了再返回）</li>
</ul>
<p>本地域名服务器向其他根域名服务器进行查询的时一般使用迭代查询。</p>
<ul>
<li><strong>迭代查询：</strong> 当某个根域名服务器收到本地域名服务器的请求报文时，要么告诉它所需域名的IP地址，要么告诉它下一步应该向哪个服务器发起询问。<strong>然后让本地域名服务器自己去查询</strong>。（查不到，你去别的地方查询吧）</li>
</ul>
</blockquote>
</li>
<li><p>本地域名服务器迭代查询，先向一个根域名服务器查询。</p>
</li>
<li><p>根域名服务器告诉本地域名服务器，下一步应该向顶级域名服务器dns.com查询。</p>
</li>
<li><p>顶级域名服务器dns.com告诉本地域名服务器，下一步查找权限域名服务器：dns.adc.com。</p>
</li>
<li><p>本地域名服务器向权限域名服务器发起查询。权限域名服务器告诉本地服务器所需的IP地址，本地服务器在告诉给本地主机。</p>
</li>
</ul>
</blockquote>
<p>根：美国（10），日本（1），英国（1），瑞士（1）</p>
<p>顶级域名：com，org，edu，gov等</p>
<p>二级域名：</p>
<p>子域：</p>
<p><www.baidu.com.:>总共有四层，最大深度127层</www.baidu.com.:></p>
<p>DNS资源记录：</p>
<blockquote>
<p>SOA，每一个区在开始处都包含一个授权记录</p>
<p>NS资源记录，域名服务器记录</p>
<p>A资源记录，</p>
<p>PTR资源记录，</p>
<p>CNAME资源记录，别名记录</p>
</blockquote>
<h4 id="10-TCP是如何保证可靠传输的？-分编校丢流拥重超"><a href="#10-TCP是如何保证可靠传输的？-分编校丢流拥重超" class="headerlink" title="10.TCP是如何保证可靠传输的？(分编校丢流拥重超)"></a>10.<strong>TCP是如何保证可靠传输的？</strong>(分编校丢流拥重超)</h4><ul>
<li>（1）应用数据被TCP分割成为适合发送的数据块</li>
<li>（2）TCP将会给每一个包进行<strong>编号</strong>，接收方会对数据进行排序，将有序的数据传输给应用层。     序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。     确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。     序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</li>
<li>（3）TCP将会保持首部和数据的<strong>校验和</strong>，目的是检查数据在传输的过程中是否被修改</li>
<li>（4）丢弃重复发送的数据</li>
<li>（5）流量控制：TCP连接的每一方都有一个固定的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能够容纳的数据，当接收方来不及处理的时候，能够提示发送端降低发送的速率，防止丢包。（TCP使用的是滑动窗口进行流量控制)，如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，<strong>TCP协议利用了滑动窗口进行了流量控制。</strong>在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</li>
<li>（6）拥塞控制（当网络阻塞的时候，减少数据的发送，拥塞控制就是防止过多的数据注入到网络中，这样使网络中的路由器或者链路不至于过载。）这里的发送方会维护一个拥塞窗口的状态变量，它和流量控制的滑动窗口是不一样的，滑动窗口是根据接收方数据缓冲区大小确定的，<strong>而拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口和拥塞窗口中的最小值。</strong></li>
<li>（7）自动重传（为了实现可靠的传输，每发送完一个分组就会停止发送，等待对方确认，确认后再发送下一个分组。）</li>
<li>（8）超时重传（当TCP发出一个分组后，它将启动一个定时器，等待目的端确认接收，如果不及时，将会重传。）</li>
</ul>
<h4 id="11-TCP和UDP之间的区别？-面头流速可有界"><a href="#11-TCP和UDP之间的区别？-面头流速可有界" class="headerlink" title="11.TCP和UDP之间的区别？(面头流速可有界)"></a>11.<strong>TCP和UDP之间的区别？</strong>(面头流速可有界)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:left">TCP</th>
<th style="text-align:left">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向连接</td>
<td style="text-align:left">面向连接，<strong>TCP不提供广播和多播服务</strong></td>
<td style="text-align:left">面向无连接，<strong>UDP支持一对一、多对一、一对多、多对多的交互通信。</strong></td>
</tr>
<tr>
<td style="text-align:left">头部大小</td>
<td style="text-align:left">头部至少为20个字节</td>
<td style="text-align:left">头部为8个字节</td>
</tr>
<tr>
<td style="text-align:left">流量控制</td>
<td style="text-align:left">有流量控制</td>
<td style="text-align:left">没有流量控制</td>
</tr>
<tr>
<td style="text-align:left">速度</td>
<td style="text-align:left">TCP速度较慢</td>
<td style="text-align:left">UDP速度较快</td>
</tr>
<tr>
<td style="text-align:left">可靠性</td>
<td style="text-align:left">可靠传输</td>
<td style="text-align:left">不可靠传输</td>
</tr>
<tr>
<td style="text-align:left">有序</td>
<td style="text-align:left">有序</td>
<td style="text-align:left">无序</td>
</tr>
<tr>
<td style="text-align:left">界</td>
<td style="text-align:left">TCP有界，通过字节流传输</td>
<td style="text-align:left">UDP无界，每一个包是单独传输的，发送方的UDP对应用程序交下来的报文添加首部后直接交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</td>
</tr>
<tr>
<td style="text-align:left">适用场景</td>
<td style="text-align:left">视频</td>
<td style="text-align:left">文件传输</td>
</tr>
</tbody>
</table>
</div>
<h4 id="12-post和get的区别？"><a href="#12-post和get的区别？" class="headerlink" title="12.post和get的区别？"></a>12.post和get的区别？</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:left">POST</th>
<th style="text-align:left">GET</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可见性</td>
<td style="text-align:left">数据在url中不可见</td>
<td style="text-align:left">参数在url中可见</td>
</tr>
<tr>
<td style="text-align:left">长度</td>
<td style="text-align:left">没有长度限制</td>
<td style="text-align:left">有长度限制</td>
</tr>
<tr>
<td style="text-align:left"><strong>编码</strong></td>
<td style="text-align:left">application/x-www-form-urlencoded, multipart/form-data</td>
<td style="text-align:left">application/x-www-form-urlencoded</td>
</tr>
<tr>
<td style="text-align:left">缓存</td>
<td style="text-align:left">不支持</td>
<td style="text-align:left">支持</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">相对安全</td>
<td style="text-align:left">相对不安全</td>
</tr>
</tbody>
</table>
</div>
<h4 id="13-在TCP和UDP之上都有哪些应用层的协议？"><a href="#13-在TCP和UDP之上都有哪些应用层的协议？" class="headerlink" title="13.在TCP和UDP之上都有哪些应用层的协议？"></a>13.<strong>在TCP和UDP之上都有哪些应用层的协议？</strong></h4><blockquote>
<p>TCP：HTTP，HTTPS，SMTP（简单邮件传输协议），POP3，SSH </p>
<p>UDP：DNS，Telnet，SNMP（简单网络管理协议），IGMP（网络组管理协议）,RIP(路由信息协议)，DHCP（动态主机设置协议）</p>
</blockquote>
<h4 id="14-HTTPS握手的过程？"><a href="#14-HTTPS握手的过程？" class="headerlink" title="14.HTTPS握手的过程？"></a>14.<strong>HTTPS握手的过程？</strong></h4><blockquote>
<p>（1）客户端给出一个<strong>协议版本号</strong>、一个客户端生成的<strong>随机数</strong>（Client random）以及客户端<strong>支持的加密算法</strong>。（客户端发送了三件东西） </p>
<p>（2）服务端确认双方使用的<strong>加密算法</strong>，并且给出<strong>数字证书</strong>，以及一个<strong>随机数（server random）</strong>。（服务端发送了两件东西） （服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。）</p>
<p>（3）客户端确认数字证书有效，然后生成一个新的随机数   ，并且使用数字证书中的公钥，加密这个随机数，将其发送给服务端。（客户端发送了一个非对称加密的随机数） </p>
<p>（4）服务端使用自己的私钥，获取来自客户端的加密随机数（Premaster secret）。（服务端使用非对称加密算法进行解密） </p>
<p>（5）客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成对话密钥（session key），用来加密整个会话。（服务端使用对称密钥会话）</p>
<blockquote>
<p>对称加密和非对称加密？</p>
<p>》 DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等</p>
<p>》RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p>
</blockquote>
</blockquote>
<h4 id="15-TCP头部，UDP头部比较？"><a href="#15-TCP头部，UDP头部比较？" class="headerlink" title="15.TCP头部，UDP头部比较？"></a>15.<strong>TCP头部，UDP头部比较？</strong></h4><p>（1）TCP头部至少由20个字节构成（最长60个），如下图：</p>
<p><img src="/2019/11/20/Java总结-1/" alt=""><img src="/2019/11/20/Java总结-1/" alt="img"></p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/tcp.png" alt="img"></p>
<p>（2）UDP头部由8个字节构成，如下图：</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/udp.png" alt="img"></p>
<h4 id="16-IP头部"><a href="#16-IP头部" class="headerlink" title="16.IP头部"></a>16.IP头部</h4><p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/ip.png" alt="img"></p>
<h4 id="17-HTTP请求，HTTP响应，字段？"><a href="#17-HTTP请求，HTTP响应，字段？" class="headerlink" title="17.HTTP请求，HTTP响应，字段？"></a>17.HTTP请求，HTTP响应，字段？</h4><blockquote>
<p>（1）HTTP请求</p>
<ul>
<li>请求行<ul>
<li>方法，url，协议版本</li>
</ul>
</li>
<li>请求首部字段</li>
<li>空行（这一个空行一定存在）</li>
<li>内容实体</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">PUT</td>
<td style="text-align:left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">PATCH</td>
<td style="text-align:left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/request.png" alt="img"></p>
<blockquote>
<p>（2）HTTP响应</p>
<ul>
<li>响应行<ul>
<li>协议版本，响应状态码，原因短语</li>
</ul>
</li>
<li>响应首部字段</li>
<li>空行</li>
<li>内容实体</li>
</ul>
</blockquote>
<p>（3）字段</p>
<ul>
<li>通用头（通用头域包含请求和响应消息都支持的头域，通用头域包含缓存头部Cache-Control、Pragma及信息性头部Connection、Date、Transfer-Encoding、Update、Via）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Date</strong></td>
<td style="text-align:left">Date头域表示消息发送的时间，服务器响应中要包含这个头部，因为缓存在评估响应的新鲜度时要用到，其时间的描述格式由RFC822定义。例如，Date:Mon,31 Dec 2001 04:25:57 GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Transfer-Encoding</strong></td>
<td style="text-align:left">WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked），例如：Transfer-Encoding: chunked</td>
</tr>
<tr>
<td style="text-align:left"><strong>Pragma</strong></td>
<td style="text-align:left">Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Connection</strong></td>
<td style="text-align:left">Connection表示是否需要持久连接。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Cache-Control</strong></td>
<td style="text-align:left">Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置 Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Upgrade</strong></td>
<td style="text-align:left">它可以指定另一种可能完全不同的协议，如HTTP/1.1客户端可以向服务器发送一条HTTP/1.0请求，其中包含值为“HTTP/1.1”的Update头部，这样客户端就可以测试一下服务器是否也使用HTTP/1.1了。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Via</strong></td>
<td style="text-align:left">列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>HTTP请求头（请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Accept</strong></td>
<td style="text-align:left">告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Accept-Charset</strong></td>
<td style="text-align:left">浏览器告诉服务器自己能接收的字符集。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Accept-Encoding</strong></td>
<td style="text-align:left">浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Accept-Language</strong></td>
<td style="text-align:left">浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Authorization</strong></td>
<td style="text-align:left">当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>If-Match</strong></td>
<td style="text-align:left">如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作，获取文档。</td>
</tr>
<tr>
<td style="text-align:left"><strong>If-None-Match</strong></td>
<td style="text-align:left">如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作，获取文档。</td>
</tr>
<tr>
<td style="text-align:left"><strong>If-Modified-Since</strong></td>
<td style="text-align:left">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</td>
</tr>
<tr>
<td style="text-align:left"><strong>If-Unmodified-Since</strong></td>
<td style="text-align:left">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>If-Range</strong></td>
<td style="text-align:left">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Range</strong></td>
<td style="text-align:left">浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546</td>
</tr>
<tr>
<td style="text-align:left"><strong>Proxy-Authenticate</strong></td>
<td style="text-align:left">代理服务器响应浏览器，要求其提供代理身份验证信息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Proxy-Authorization</strong></td>
<td style="text-align:left">浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Host</strong></td>
<td style="text-align:left">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn</td>
</tr>
<tr>
<td style="text-align:left"><strong>Referer</strong></td>
<td style="text-align:left">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL，例如：Referer：<a href="http://www.jb51.net/" target="_blank" rel="noopener">http://www.jb51.net</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>User-Agent</strong></td>
<td style="text-align:left">浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>HTTP响应头（响应头向客户端提供一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些头部有助于客户端处理响应，并在将来发起更好的请求。）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Age</strong></td>
<td style="text-align:left">当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Server</strong></td>
<td style="text-align:left">WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix)</td>
</tr>
<tr>
<td style="text-align:left"><strong>Accept-Ranges</strong></td>
<td style="text-align:left">WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Vary</strong></td>
<td style="text-align:left">WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding:gzip; Vary: Content-Encoding，那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>HTTP实体头部（实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括信息性头部Allow、Location，内容头部Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type，缓存头部Etag、Expires、Last-Modified、extension-header。）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Allow</strong></td>
<td style="text-align:left">服务器支持哪些请求方法（如GET、POST等）。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Location</strong></td>
<td style="text-align:left">表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Base</strong></td>
<td style="text-align:left">解析主体中的相对URL时使用的基础URL。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Encoding</strong></td>
<td style="text-align:left">WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Language</strong></td>
<td style="text-align:left">WEB 服务器告诉浏览器理解主体时最适宜使用的自然语言。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Length</strong></td>
<td style="text-align:left">WEB服务器告诉浏览器自己响应的对象的长度或尺寸，例如：Content-Length: 26012</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Location</strong></td>
<td style="text-align:left">资源实际所处的位置。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-MD5</strong></td>
<td style="text-align:left">主体的MD5校验和。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Range</strong></td>
<td style="text-align:left">实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth。例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Content-Type</strong></td>
<td style="text-align:left"><strong>WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>Etag</strong></td>
<td style="text-align:left">就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其<br>ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Expires</strong></td>
<td style="text-align:left">WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</td>
</tr>
<tr>
<td style="text-align:left"><strong>Last-Modified</strong></td>
<td style="text-align:left">WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT</td>
</tr>
</tbody>
</table>
</div>
<h4 id="18-HTTP1-0，HTTP1-1，HTTP2-0之间的区别？"><a href="#18-HTTP1-0，HTTP1-1，HTTP2-0之间的区别？" class="headerlink" title="18.HTTP1.0，HTTP1.1，HTTP2.0之间的区别？"></a>18.HTTP1.0，HTTP1.1，HTTP2.0之间的区别？</h4><blockquote>
<p>（1）HTTP1.0：</p>
<ul>
<li>无法复用连接</li>
<li>对头阻塞（head of line blocking）:对于同一个tcp连接，所有的http1.0请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。可见，http1.0的队首组塞发生在客户端。</li>
</ul>
<p>（2）HTTP1.1：</p>
<ul>
<li>长连接（在头部加入了connection：keep-alive）</li>
<li>管道化（将请求队列移动到服务端队列）HTTP/1.1通过pipelining管道技术实现一次性发送多个请求，以期提高吞吐和性能,可见，http1.1的队首阻塞发生在服务器端。</li>
<li>缓存机制（引入了新的字段cache-control，支持断点重传）</li>
<li>增加了host字段（使得一个服务器可创建多个站点）</li>
</ul>
<p>(3）HTTP2.0：</p>
<ul>
<li>二进制分帧</li>
<li>多路复用（消息由一个帧或者多个帧组成，可以乱序进行发送，之后使用帧的stream id进行重组，二进制分帧使得多路复用成为可能，多路复用实现真正的并发）</li>
<li>头部压缩，通信双方保存header filed表</li>
<li>服务器推送（不用客户端进行明确请求）</li>
</ul>
<p>（4）最新的HTTP版本？</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP</a></p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#post-http2_evolution" target="_blank" rel="noopener">Post-HTTP/2 evolution</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http3_-_http_over_quic" target="_blank" rel="noopener">HTTP/3 - HTTP over QUIC</a></li>
</ul>
<p><strong>（5）在应用中如何配置HTTP版本？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># For HTTP, the proxy_http_version directive should be set to “1.1” and the “Connection” header field should be cleared:</span></span><br><span class="line">&gt; upstream http_backend &#123;</span><br><span class="line">&gt;     server 127.0.0.1:8080;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     keepalive 16;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; server &#123;</span><br><span class="line">&gt;     ...</span><br><span class="line">&gt; </span><br><span class="line">&gt;     location /http/ &#123;</span><br><span class="line">&gt;         proxy_pass http://http_backend;</span><br><span class="line">&gt;         proxy_http_version 1.1;</span><br><span class="line">&gt;         proxy_set_header Connection <span class="string">""</span>;</span><br><span class="line">&gt;         ...</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
</blockquote>
<p><strong>新HTTP1.0与HTTP1.1区别：</strong></p>
<blockquote>
<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>
<ul>
<li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity  tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial  Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed  Web  Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400  Bad Request）。</li>
<li><strong>长连接、持续连接</strong>，HTTP  1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：  keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ul>
</blockquote>
<p><strong>HTTP1.1与HTTP2.0的区别：</strong></p>
<blockquote>
<ul>
<li><strong>新的二进制格式</strong>（Binary  Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的  id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header  fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能</li>
</ul>
</blockquote>
<h4 id="19-cookie和session的区别？"><a href="#19-cookie和session的区别？" class="headerlink" title="19.cookie和session的区别？"></a>19.cookie和session的区别？</h4><blockquote>
<p>说先说一下为什么需要cookie和session？</p>
<p>（1）cookie数据存放在客户的浏览器上，session存放在服务器上。</p>
<p>（2）cookie不是安全的，别人可以分析存放在本地的cookie进行cookie欺骗。</p>
<p>（3）session会一定时间内存放在服务器上，当访问次数增多的时候，会影响性能。</p>
<p>（4）单个cookie保存的数据不会超过4K，很多浏览器限制一个站点的cookie数目不超过20个。</p>
</blockquote>
<h4 id="20-状态码？"><a href="#20-状态码？" class="headerlink" title="20.状态码？"></a>20.<strong>状态码？</strong></h4><p>（1）概括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational（信息状态码）</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success（成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error（服务器错误状态码）</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<p>（2）细节</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">状态码英文名称</th>
<th style="text-align:left">中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Continue</td>
<td style="text-align:left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td style="text-align:left">101</td>
<td style="text-align:left">Switching Protocols</td>
<td style="text-align:left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td style="text-align:left">201</td>
<td style="text-align:left">Created</td>
<td style="text-align:left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td style="text-align:left">203</td>
<td style="text-align:left">Non-Authoritative Information</td>
<td style="text-align:left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">No Content</td>
<td style="text-align:left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td style="text-align:left">205</td>
<td style="text-align:left">Reset Content</td>
<td style="text-align:left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">300</td>
<td style="text-align:left">Multiple Choices</td>
<td style="text-align:left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other</td>
<td style="text-align:left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">Not Modified</td>
<td style="text-align:left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td style="text-align:left">305</td>
<td style="text-align:left">Use Proxy</td>
<td style="text-align:left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td style="text-align:left">306</td>
<td style="text-align:left">Unused</td>
<td style="text-align:left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect</td>
<td style="text-align:left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">请求要求用户的身份认证</td>
</tr>
<tr>
<td style="text-align:left">402</td>
<td style="text-align:left">Payment Required</td>
<td style="text-align:left">保留，将来使用</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td style="text-align:left">405</td>
<td style="text-align:left">Method Not Allowed</td>
<td style="text-align:left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td style="text-align:left"><strong>406</strong></td>
<td style="text-align:left"><strong>Not Acceptable</strong></td>
<td style="text-align:left"><strong>服务器无法根据客户端请求的内容特性完成请求</strong></td>
</tr>
<tr>
<td style="text-align:left">407</td>
<td style="text-align:left">Proxy Authentication Required</td>
<td style="text-align:left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Time-out</td>
<td style="text-align:left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td style="text-align:left">410</td>
<td style="text-align:left">Gone</td>
<td style="text-align:left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td style="text-align:left">411</td>
<td style="text-align:left">Length Required</td>
<td style="text-align:left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td style="text-align:left">412</td>
<td style="text-align:left">Precondition Failed</td>
<td style="text-align:left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td style="text-align:left">413</td>
<td style="text-align:left">Request Entity Too Large</td>
<td style="text-align:left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td style="text-align:left">414</td>
<td style="text-align:left">Request-URI Too Large</td>
<td style="text-align:left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td style="text-align:left">415</td>
<td style="text-align:left">Unsupported Media Type</td>
<td style="text-align:left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td style="text-align:left">416</td>
<td style="text-align:left">Requested range not satisfiable</td>
<td style="text-align:left">客户端请求的范围无效</td>
</tr>
<tr>
<td style="text-align:left">417</td>
<td style="text-align:left">Expectation Failed</td>
<td style="text-align:left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left">Not Implemented</td>
<td style="text-align:left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left">Service Unavailable</td>
<td style="text-align:left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Gateway Time-out</td>
<td style="text-align:left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td style="text-align:left">505</td>
<td style="text-align:left">HTTP Version not supported</td>
<td style="text-align:left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody>
</table>
</div>
<p><strong>1XX——表示通知信息，如请求收到了或正在进行处理</strong></p>
<p><strong>2XX——表明请求被正常处理了</strong></p>
<blockquote>
<ul>
<li>200 OK：请求已正常处理。</li>
<li>204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li>
<li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</li>
</ul>
</blockquote>
<p><strong>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</strong></p>
<blockquote>
<ul>
<li>301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li>
<li>302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</li>
<li>303  See  Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</li>
<li>304  Not  Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。</li>
<li>307 Temporary Redirect：临时重定向。与302有相同的含义。</li>
</ul>
</blockquote>
<p><strong>4XX——表明客户端是发生错误的原因所在。</strong></p>
<blockquote>
<ul>
<li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li>
<li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</li>
<li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li>
<li>404 Not Found：服务器上没有请求的资源。路径错误等。</li>
</ul>
</blockquote>
<p><strong>5XX——服务器本身发生错误</strong></p>
<blockquote>
<ul>
<li>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li>
<li>503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</li>
</ul>
</blockquote>
<h4 id="21-TCP是如何实现面向连接的？面向连接和非面向连接的区别？"><a href="#21-TCP是如何实现面向连接的？面向连接和非面向连接的区别？" class="headerlink" title="21.TCP是如何实现面向连接的？面向连接和非面向连接的区别？"></a>21.TCP是如何实现面向连接的？面向连接和非面向连接的区别？</h4><p>（1）状态和序列号，以及错误校验。描述TCP和UDP头之间的差异！</p>
<h4 id="22-TCP的拥塞控制？（重传就可能导致拥塞）"><a href="#22-TCP的拥塞控制？（重传就可能导致拥塞）" class="headerlink" title="22.TCP的拥塞控制？（重传就可能导致拥塞）"></a>22.TCP的拥塞控制？（重传就可能导致拥塞）</h4><p>TCP通过<strong>慢启动、拥塞避免、快重传以及快恢复</strong>这四个算法来进行拥塞控制（使用滑动窗口进行流量控制）：</p>
<blockquote>
<ul>
<li><strong>慢启动：</strong>一开始先设置一个比较小的拥塞窗口值cwnd（报文段的倍数），然后进行数据传输，每收到一个报文段的确认，我们就将<strong>cwnd+1</strong>，这样下来，cwnd总体上是乘以<strong>2^n</strong>的倍数增长。（慢启动非增长速度慢，只是增长的初始基数比较小）</li>
<li><strong>拥塞避免：</strong> 因为慢启动算法的增长比较快，当cwnd = ssthresh（预先设置好的门限值）时，我们启动拥塞避免算法，窗口值开始线性增长。</li>
</ul>
<blockquote>
<p>随着拥塞避免算法的进行，网络出现超时的情况（这时判断为<strong>拥塞出现</strong>）。这时将cwnd降为一开始的值，重新进行<strong>慢开始-拥塞避免</strong>，并且此时的门限值设为出现拥塞时的cwnd的一半。</p>
</blockquote>
<ul>
<li><strong>快重传：</strong> 快重传的目的是为了让发送方尽早知道某个报文段的丢失。如何知道呢？<strong>当我们重复收到某一个报文段的3次确认时，我们就可以判断，它的下一个报文段可能出现了丢失</strong>。这时我们启动快重传算法，立即重传丢失的报文段。</li>
<li><strong>快恢复：</strong> 上面快重传算法的启动只是因为个别报文段的丢失，我们这时并不判断为网络拥塞，而是启动快恢复算法。我们将cwnd=ssthresh=当前cwnd的一半，并且开始拥塞避免算法。</li>
</ul>
<blockquote>
<p>当然，也有的快恢复算法是将当前拥塞窗口再增大3个报文段的值，因为既然收到了3个重复的ACK，则说明有三个分组已经离开了网络，不在占用网络资源而是停留在对方缓存当中，可以适当将窗口值增大。</p>
</blockquote>
</blockquote>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/yongsekongzhi.png" alt="img"></p>
<h4 id="23-TCP的流量控制？"><a href="#23-TCP的流量控制？" class="headerlink" title="23.TCP的流量控制？"></a>23.TCP的流量控制？</h4><p>滑动窗口协议</p>
<h4 id="24-重传算法？"><a href="#24-重传算法？" class="headerlink" title="24.重传算法？"></a>24.重传算法？</h4><blockquote>
<p>SACK方法</p>
<ul>
<li>为了解决快速重传的缺点，一种更好的SACK重传策略被提出</li>
<li>基于快速重传，同时在tcp头里加了一个SACK的东西</li>
<li>解决了什么问题：客户端应该发送哪些超时包的问题</li>
</ul>
</blockquote>
<h4 id="25-路由算法？"><a href="#25-路由算法？" class="headerlink" title="25.路由算法？"></a>25.路由算法？</h4><blockquote>
<p>（1）路由：找到任意两个节点之间开销最小的路径。</p>
<p>（2）距离向量，链路状态</p>
<ul>
<li>距离向量：网络中没有任何一个节点知道整张表的信息，自己只知道它自己的路由表的内容。好处：所有的节点在没有任何集中授权的额情况下取得网络的一致视图。（RIP协议）</li>
<li>链路状态：每一个节点都有足够的信息构建完整的网络映象。（OSPF协议，开放最短路径优先），路由的计算采用迪杰特斯拉算法进行计算。</li>
</ul>
</blockquote>
<h4 id="26-IP数据报格式？"><a href="#26-IP数据报格式？" class="headerlink" title="26.IP数据报格式？"></a>26.IP数据报格式？</h4><p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//network/ip.png" alt="img"></p>
<h4 id="27-ABC类地址"><a href="#27-ABC类地址" class="headerlink" title="27.ABC类地址"></a>27.ABC类地址</h4><blockquote>
<ul>
<li>A、B、C类IP地址的网络号字段分别是1、2、3个字节长，而在网络号的1-3位是类别位，分别是：0、10、110。</li>
<li>A、B、C类IP地址的主机号字段分别为3、2、1个字节。</li>
<li>A、B、C类IP地址是单播地址，D类IP地址（前四位为1110）为多播地址，E类IP地址（前四位1111）保留为以后使用。</li>
<li>A类地址的网络号中：全0和127是不指派的；主机号中：全0代表本主机所连接的单个网络地址，全1代表网络上的所有主机，也是不指派的。</li>
<li>B类IP地址网络号中：<strong>128.0.0.0不指派</strong>；主机号中：全0和全1也不指派。</li>
<li>C类IP地址网络号中：<strong>192.0.0.0不指派</strong>；主机号中：全0和全1也不指派。</li>
</ul>
</blockquote>
<h4 id="28-端口号"><a href="#28-端口号" class="headerlink" title="28.端口号"></a>28.端口号</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">应用程序</th>
<th style="text-align:left">FTP</th>
<th style="text-align:left">TELNET</th>
<th style="text-align:left">SMTP</th>
<th style="text-align:left">DNS</th>
<th style="text-align:left">TFTP</th>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">SNMP</th>
<th style="text-align:left">SNMP(trap)</th>
<th style="text-align:left">HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">熟知端口号</td>
<td style="text-align:left">21</td>
<td style="text-align:left">23</td>
<td style="text-align:left">25</td>
<td style="text-align:left">53</td>
<td style="text-align:left">69</td>
<td style="text-align:left">80</td>
<td style="text-align:left">161</td>
<td style="text-align:left">162</td>
<td style="text-align:left">443</td>
</tr>
</tbody>
</table>
</div>
<h4 id="29-滑动窗口（解决的是速率不匹配问题）"><a href="#29-滑动窗口（解决的是速率不匹配问题）" class="headerlink" title="29.滑动窗口（解决的是速率不匹配问题）"></a>29.滑动窗口（解决的是速率不匹配问题）</h4><ul>
<li>解决了什么问题：发送方和接收方速率不匹配时，保证可靠传输和包乱序的问题</li>
<li>机制：接收方根据目前缓冲区大小，通知发送方目前能接收的最大值。发送方根据接收方的处理能力来发送数据。通过这种协调机制，防止接收端处理不过来。</li>
<li>窗口大小：接收方发给发送端的这个值称为窗口大小</li>
</ul>
<h4 id="30-拥塞窗口（控制的是发送方）"><a href="#30-拥塞窗口（控制的是发送方）" class="headerlink" title="30.拥塞窗口（控制的是发送方）"></a>30.拥塞窗口（控制的是发送方）</h4><ul>
<li>解决什么问题：发送方发送速度过快，导致中转路由器拥堵的问题</li>
<li>机制：发送方增加一个拥塞窗口（cwnd），每次受到ack，窗口值加1。发送时，取拥塞窗口和接收方发来的窗口大小取最小值发送</li>
<li>起到发送方流量控制的作用</li>
</ul>
<h4 id="31-细节"><a href="#31-细节" class="headerlink" title="31.细节"></a>31.细节</h4><ul>
<li>MIME (<em>M</em>ultipurpose <em>I</em>nternet <em>M</em>ail <em>E</em>xtensions) 是描述消息内容类型的因特网标准。</li>
<li>Request For Comments（<em>RFC</em>），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。</li>
<li>RIP使用UDP，OSPF使用IP,而BGP使用TCP。(R—-U,O—-I,B—-P)<ul>
<li>OSPF本身提供主从协商机制，可以保证可靠的传输，另外全网路由器保持着同样的一个LSDB（链路状态数据库），当拓扑发生变化时，需要携带的变更信息较少，</li>
<li>通过IP协议即可完成RIP协议采用UDP是因为RIP每周期需全网组播路由信息，路由信息数目较大，故使用UDP协议可以提高效率</li>
<li>BGP为边界网关协议，因携带的路由信息较多，且可能跨不同网络传送路由信息，为保证可靠性，需使用TCP协议，可兼顾容量和可靠性</li>
</ul>
</li>
</ul>
<h4 id="32-HTTP和HTTPS的区别？"><a href="#32-HTTP和HTTPS的区别？" class="headerlink" title="32.HTTP和HTTPS的区别？"></a>32.HTTP和HTTPS的区别？</h4><blockquote>
<p>证书机构： 阿里巴巴</p>
<p>(1) https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)</p>
<p>(2) http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>(3) http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</blockquote>
<h4 id="33-同源策略？"><a href="#33-同源策略？" class="headerlink" title="33.同源策略？"></a>33.同源策略？</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>http://store.company.com/dir2/other.html</code></td>
<td style="text-align:left">成功</td>
<td style="text-align:left">只有路径不同</td>
</tr>
<tr>
<td style="text-align:left"><code>http://store.company.com/dir/inner/another.html</code></td>
<td style="text-align:left">成功</td>
<td style="text-align:left">只有路径不同</td>
</tr>
<tr>
<td style="text-align:left"><code>https://store.company.com/secure.html</code></td>
<td style="text-align:left">失败</td>
<td style="text-align:left">不同协议 ( https和http )</td>
</tr>
<tr>
<td style="text-align:left"><code>http://store.company.com:81/dir/etc.html</code></td>
<td style="text-align:left">失败</td>
<td style="text-align:left">不同端口 ( http:// 80是默认的)</td>
</tr>
<tr>
<td style="text-align:left"><code>http://news.company.com/dir/other.html</code></td>
<td style="text-align:left">失败</td>
<td style="text-align:left">不同域名 ( news和store )</td>
</tr>
</tbody>
</table>
</div>
<h4 id="34-跨域问题？"><a href="#34-跨域问题？" class="headerlink" title="34.跨域问题？"></a>34.跨域问题？</h4><blockquote>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<blockquote>
<p>　　1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p>
<p>　　2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）</p>
<p>　　3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p>
</blockquote>
<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）</p>
</blockquote>
<h4 id="35-websocket和SSE的区别？"><a href="#35-websocket和SSE的区别？" class="headerlink" title="35. websocket和SSE的区别？"></a>35. websocket和SSE的区别？</h4><h4 id="36-epoll"><a href="#36-epoll" class="headerlink" title="36. epoll"></a>36. epoll</h4><ul>
<li>epoll_create</li>
<li>epoll_ctl</li>
<li>epoll_wait</li>
</ul>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/network/epoll.png" alt="img"></p>
<h4 id="37-cacheline，MESI"><a href="#37-cacheline，MESI" class="headerlink" title="37. cacheline，MESI"></a>37. cacheline，MESI</h4><p>4kb</p>
<p>64bytes</p>
<h2 id="二、操作系统"><a href="#二、操作系统" class="headerlink" title="二、操作系统"></a>二、操作系统</h2><h3 id="（一）基础"><a href="#（一）基础" class="headerlink" title="（一）基础"></a>（一）基础</h3><h4 id="1-原码、补码、反码"><a href="#1-原码、补码、反码" class="headerlink" title="1.原码、补码、反码"></a>1.原码、补码、反码</h4><blockquote>
<ul>
<li>原码：原码用第一位表示符号, 其余位表示值. 比如如果是8位二进制</li>
<li>补码<ul>
<li>正数：正数的补码就是其本身</li>
<li>负数：负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。 (即在反码的基础上+1)</li>
<li>为什么要用补码？<ul>
<li>原因很简单，如果使用补码表示负整数，那么ALU在做整数之间的操作时，就不用区分符号了，所有位都会参与运算，其上上面的例子中，符号位都参与了运算。</li>
</ul>
</li>
</ul>
</li>
<li>反码<ul>
<li>正数：正数的反码是其本身</li>
<li>负数：负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2-fork函数"><a href="#2-fork函数" class="headerlink" title="2.fork函数"></a>2.fork函数</h4><blockquote>
<p>int main(){fork()||fork();}共创建几个进程：3</p>
<p>fork()给子进程返回一个零值，而给父进程返回一个非零值； </p>
<p>在main这个主进程中，首先执行     <strong>fork()</strong>    || fork(),   左边的fork()返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程， </p>
<p>由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中，     <strong>fork()</strong>   ||fork()这条语句左边表达式的返回值是0,   所以||右边的表达式要执行，这时在子进程中又创建了一个进程， 即main进程-&gt;子进程-&gt;子进程，一共创建了3个进程。 </p>
</blockquote>
<h3 id="（二）并发"><a href="#（二）并发" class="headerlink" title="（二）并发"></a>（二）并发</h3><h4 id="1-进程、线程、管程、协程？"><a href="#1-进程、线程、管程、协程？" class="headerlink" title="1.进程、线程、管程、协程？"></a>1.进程、线程、管程、协程？</h4><h5 id="（1）线程和进程-Thread-amp-Process"><a href="#（1）线程和进程-Thread-amp-Process" class="headerlink" title="（1）线程和进程(Thread &amp; Process)"></a>（1）线程和进程(Thread &amp; Process)</h5><p>线程是程序执行的一条路径，在多线程的OS中，线程是调度和分配的基本单位，而进程是拥有资源的基本单位。结合Java的内存区域（线程共享和线程私有）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.MultiThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MultiThread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 查看有哪些线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [5] Monitor Ctrl-Break</span></span><br><span class="line"><span class="comment"> * [4] Signal Dispatcher</span></span><br><span class="line"><span class="comment"> * [3] Finalizer</span></span><br><span class="line"><span class="comment"> * [2] Reference Handler</span></span><br><span class="line"><span class="comment"> * [1] main</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 下午9:23 2019/8/13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadMXBean threadMXBean= ManagementFactory.getThreadMXBean();</span><br><span class="line">        ThreadInfo[] threadInfos=threadMXBean.dumpAllThreads(<span class="keyword">false</span>,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (ThreadInfo threadInfo:threadInfos)&#123;</span><br><span class="line">            System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（2）线程的属性"><a href="#（2）线程的属性" class="headerlink" title="（2）线程的属性"></a>（2）线程的属性</h5><ul>
<li><strong>轻型实体</strong>：线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息：</li>
<li>线程状态。<ul>
<li>当线程不运行时，被保存的现场资源。</li>
<li>一组执行堆栈。</li>
<li>存放每个线程的局部变量主存区。</li>
<li>访问同一个进程中的主存和其它资源。</li>
</ul>
</li>
</ul>
<p>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p>
<ul>
<li><strong>独立调度和分派的基本单位</strong>：在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</li>
<li><strong>可并发执行</strong>：在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</li>
<li><strong>共享进程资源</strong>：在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</li>
</ul>
<h5 id="（3）管程"><a href="#（3）管程" class="headerlink" title="（3）管程"></a>（3）管程</h5><h5 id="（4）协程"><a href="#（4）协程" class="headerlink" title="（4）协程"></a>（4）协程</h5><p><span style="color:red">协程：协程，英文Coroutines，是一种比线程更加轻量级的存在。</span>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。（线程内核管理，协程自己控制切换，用户态和内核态切换，比线程切换代价更小）</p>
<p><img src="/2019/11/20/Java总结-1/./Java总结-1/Coroutines.png" alt=""></p>
<h4 id="2-进程之间的通信？（套共消，管信信）"><a href="#2-进程之间的通信？（套共消，管信信）" class="headerlink" title="2.进程之间的通信？（套共消，管信信）"></a>2.进程之间的通信？（套共消，管信信）</h4><blockquote>
<p>（1）套接字</p>
<p>（2）共享内存</p>
<p>（3）消息队列</p>
<p>（4）管程</p>
<p>（5）信号</p>
<p>（6）信号量</p>
<p><strong>信号量</strong></p>
<p>是一个确定的二元组（s，q），其中s是一个具有非负初值的整形变量，q是一个初始状态为空的队列，整形变量s表示系统中某类资源的数目：</p>
<ul>
<li>当其值 <code>&gt;= 0</code> 时，表示系统中当前可用资源的数目</li>
<li>当其值 <code>&lt; 0</code> 时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目</li>
</ul>
<p>除信号量的初值外，信号量的值仅能由P操作和V操作更改，操作系统利用它的状态对进程和资源进行管理</p>
<h5 id="P操作"><a href="#P操作" class="headerlink" title="P操作"></a>P操作</h5><p>P操作记为P(s)，其中s为一信号量，它执行时主要完成以下动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;s.value = s.value - 1；  /*可理解为占用1个资源，若原来就没有则记帐“欠”1个*/</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>若<code>s.value ≥ 0</code>，则进程继续执行，否则（即s.value &lt; 0），则进程被阻塞，并将该进程插入到信号量s的等待队列s.queue中</p>
<blockquote>
<p>实际上，P操作可以理解为分配资源的计数器，或是使进程处于等待状态的控制指令</p>
</blockquote>
<h5 id="V操作"><a href="#V操作" class="headerlink" title="V操作"></a>V操作</h5><p>V操作记为V(s)，其中s为一信号量，它执行时，主要完成以下动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;s.value = s.value + 1；/*可理解为归还1个资源，若原来就没有则意义是用此资源还1个欠帐*/</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>若<code>s.value &gt; 0</code>，则进程继续执行，否则（即s.value ≤ 0），则从信号量s的等待队s.queue中移出第一个进程，使其变为就绪状态，然后返回原进程继续执行</p>
<blockquote>
<p>实际上，V操作可以理解为归还资源的计数器，或是唤醒进程使其处于就绪状态的控制指令      </p>
</blockquote>
</blockquote>
<h4 id="3-信号和信号量之间的区别？"><a href="#3-信号和信号量之间的区别？" class="headerlink" title="3.信号和信号量之间的区别？"></a>3.信号和信号量之间的区别？</h4><blockquote>
<ul>
<li><p>信号量：（Semaphore）进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。（特点，pv操作，用于同步进程）</p>
<blockquote>
<p>若信号S的初值为2，当前值为－1，则表示有（B　）个等待进程。</p>
<p>A.0  B.1  C.2  D.3</p>
<p>2代表有两个资源空闲,负数的绝对值表示在等待的进程数量</p>
</blockquote>
</li>
<li><p>信号：（signal）是一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。（特点，通知）</p>
</li>
</ul>
</blockquote>
<h4 id="4-线程之间的通信？"><a href="#4-线程之间的通信？" class="headerlink" title="4.线程之间的通信？"></a>4.线程之间的通信？</h4><blockquote>
<p>（1）锁机制</p>
<blockquote>
<ul>
<li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li>
<li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li>
<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</blockquote>
<p>（2）信号量机制</p>
<p>（3）信号机制</p>
</blockquote>
<h4 id="5-死锁产生的条件？"><a href="#5-死锁产生的条件？" class="headerlink" title="5.死锁产生的条件？"></a>5.死锁产生的条件？</h4><blockquote>
<p>（1）互斥</p>
<p>（2）请求与保持:指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p>（3）循环等待（解决：按照顺序来申请和释放资源）</p>
<p>（4）不可剥夺（解决：主动释放）</p>
</blockquote>
<h4 id="6-死锁的解除和预防的方法？"><a href="#6-死锁的解除和预防的方法？" class="headerlink" title="6.死锁的解除和预防的方法？"></a>6.死锁的解除和预防的方法？</h4><ul>
<li>死锁避免:银行家算法</li>
</ul>
<p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<ul>
<li><strong>破坏互斥条件</strong></li>
</ul>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<ul>
<li><strong>破坏请求与保持条件</strong></li>
</ul>
<p>一次性申请所有的资源。</p>
<ul>
<li><strong>破坏不剥夺条件</strong></li>
</ul>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<ul>
<li><strong>破坏循环等待条件</strong></li>
</ul>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<h4 id="7-调度"><a href="#7-调度" class="headerlink" title="7.调度"></a>7.调度</h4><blockquote>
<p>（1）调度策略</p>
<ul>
<li><code>响应时间</code>：从用户输入到产生反应的时间</li>
<li><code>周转时间</code>：从任务开始到任务结束的时间</li>
<li><code>平均周转时间</code>：周转总时间除以作业个数</li>
</ul>
<p>（2）调度算法(8种)</p>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;share_source=copy_web" title=" 红黑树B站最NB教程" target="_blank" rel="noopener">1</a> FCFS：调度的顺序就是任务到达就绪队列的顺序。对短作业不公平。</p>
<blockquote>
<p>公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短</p>
</blockquote>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=4&amp;share_source=copy_web" title="B站手撕红黑树代码，原生态版本" target="_blank" rel="noopener">2</a> SJF：最短的作业(CPU区间长度最小)最先调度。</p>
<blockquote>
<p>可以证明，SJF可以保证最小的平均等待时间。</p>
</blockquote>
</li>
<li><p>[3] SRJF：SJF的可抢占版本，比SJF更有优势。</p>
</li>
</ul>
<p>SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。</p>
<ul>
<li><p>[4] HRN：最高响应比优先法，是FCFS和SJF的综合平衡，响应比R定义如下： <code>R =(W+T)/T</code> 。</p>
</li>
<li><p>[5] 优先权调度：每个任务关联一个优先权，调度优先权最高的任务。</p>
<blockquote>
<p>注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</p>
<p>FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。</p>
</blockquote>
</li>
<li><p>[6] Round-Robin(RR)：设置一个时间片，按时间片来轮转调度</p>
<blockquote>
<p>优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</p>
<p>时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。</p>
</blockquote>
</li>
<li><p>[7] 多级队列调度</p>
<blockquote>
<ul>
<li>按照一定的规则建立多个进程队列</li>
<li>不同的队列有固定的优先级（高优先级有抢占权）</li>
<li>不同的队列可以给不同的时间片和采用不同的调度方法</li>
</ul>
<p>存在问题1：没法区分I/O bound和CPU bound；</p>
<p>存在问题2：也存在一定程度的“饥饿”现象；</p>
</blockquote>
</li>
<li><p>[8] 多级反馈队列：在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。</p>
<blockquote>
<p>最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。</p>
</blockquote>
</li>
</ul>
<p>#### </p>
</blockquote>
<h4 id="8-锁，死锁怎么检查？"><a href="#8-锁，死锁怎么检查？" class="headerlink" title="8.锁，死锁怎么检查？"></a>8.锁，死锁怎么检查？</h4><ul>
<li>锁的类型</li>
</ul>
<p>（1）互斥锁</p>
<blockquote>
<p>同一时间只能有一个线程访问加锁的数据。</p>
</blockquote>
<p>（2）自旋锁</p>
<blockquote>
<p>互斥锁的一种实现，如果自旋锁已经被别的执行单元保持，调用者就一直 <strong>循环等待</strong> 是否该自旋锁的保持者已经释放了锁。</p>
</blockquote>
<p>（3）读写锁</p>
<blockquote>
<p>一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。<strong>写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者</strong>。</p>
</blockquote>
<p>（4）阻塞锁</p>
<blockquote>
<p>与自旋锁不同，改变了线程的运行状态。<strong>让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态</strong>，准备就绪状态的所有线程，通过竞争，进入运行状态。</p>
<blockquote>
<p>在Java中synchronized,ReentrantLock,Object.wait() / notify()都属于阻塞锁。</p>
</blockquote>
</blockquote>
<p>（5）可重入锁</p>
<blockquote>
<p>也叫做递归锁，指的是同一线程上该锁是可重入的，对于不同线程则相当于普通的互斥锁。</p>
</blockquote>
<p>（6）公平锁</p>
<blockquote>
<p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。</p>
</blockquote>
<p>（7）非公平锁</p>
<blockquote>
<p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。<code>ReentrantLock</code>中的<code>lock()</code>默认就是非公平锁。</p>
</blockquote>
<p>（8）悲观锁</p>
<blockquote>
<p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。加锁的时间可能会很长，也就是说悲观锁的并发访问性不好。</p>
</blockquote>
<p>（9）乐观锁</p>
<blockquote>
<p>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题，可以通过添加时间戳和版本来来解决。</p>
</blockquote>
<ul>
<li>死锁的检查</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_28760063/article/details/81266578" target="_blank" rel="noopener">https://blog.csdn.net/weixin_28760063/article/details/81266578</a></p>
<ul>
<li>Jconsole</li>
<li>Jstack</li>
</ul>
</blockquote>
<h4 id="9-CAS"><a href="#9-CAS" class="headerlink" title="9.CAS"></a>9.CAS</h4><p>比较并交换(compare and swap, CAS)<strong>，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作。</strong>该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p>
<p>在使用上，通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换。<strong>如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行使内存中的数据变为新值</strong>。如果内存中的值在这期间内被修改过，则一般来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。</p>
<blockquote>
<p>在Java中，锁在并发中占据了一席之地，但是使用锁的一个问题是：当一个线程没有获取到锁的时候就会被挂起，这将导致线程的上下文切换和重新调度的开销。</p>
</blockquote>
<h4 id="10-临界区"><a href="#10-临界区" class="headerlink" title="10.临界区"></a>10.临界区</h4><p>进程中访问临界资源的那段程序称为临界区（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。 </p>
<h4 id="11-yield方法，join方法"><a href="#11-yield方法，join方法" class="headerlink" title="11.yield方法，join方法"></a>11.yield方法，join方法</h4><ul>
<li>yield方法</li>
</ul>
<blockquote>
<p>而当一个线程调用了 Thread 类的静态方法 yield 时，是在告诉线程调度器自己占有的时间片中还没有使用完的部分自己不想使用了，这暗示线程调度器现在就可以进行下一轮的线程调度 。</p>
</blockquote>
<ul>
<li>join方法</li>
</ul>
<blockquote>
<p>t.join()方法<strong>阻塞调用此方法的线程</strong>(calling thread)进入 <strong>TIMED_WAITING</strong> 状态，<strong>直到线程t完成，此线程再继续</strong>；</p>
<p>通常用于在main()主线程内，等待其它线程完成再结束main()主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTester01</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">private</span> String name;</span><br><span class="line">&gt; </span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="title">JoinTester01</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&gt; <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; System.out.printf(<span class="string">"%s begins: %s\n"</span>, name, <span class="keyword">new</span> Date());</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt; TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; e.printStackTrace();</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt; System.out.printf(<span class="string">"%s has finished: %s\n"</span>, name, <span class="keyword">new</span> Date());</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> JoinTester01(<span class="string">"One"</span>));</span><br><span class="line">&gt; Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> JoinTester01(<span class="string">"Two"</span>));</span><br><span class="line">&gt; thread1.start();</span><br><span class="line">&gt; thread2.start();</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt; thread1.join();</span><br><span class="line">&gt; thread2.join();</span><br><span class="line">&gt;   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&gt; <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">&gt;   e.printStackTrace();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; System.out.println(<span class="string">"Main thread is finished"</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="12-一般在什么时候使用volatile？"><a href="#12-一般在什么时候使用volatile？" class="headerlink" title="12.一般在什么时候使用volatile？"></a>12.一般在什么时候使用volatile？</h4><p>写入的变量不依赖当前的值的时候。因为依赖当前值的话，将会是获取—-计算—-写入三步操作，这三步操作不是原子性的，volatile不保证原子性。</p>
<h4 id="13-Linux内核select-poll-epoll？"><a href="#13-Linux内核select-poll-epoll？" class="headerlink" title="13.Linux内核select poll epoll？"></a>13.Linux内核select poll epoll？</h4><h4 id="14-周转时间"><a href="#14-周转时间" class="headerlink" title="14.周转时间"></a>14.<strong>周转时间</strong></h4><p><strong>=作业完成时间减去作业到达时间</strong></p>
<h4 id="15-响应比"><a href="#15-响应比" class="headerlink" title="15.响应比"></a>15.<strong>响应比</strong></h4><p><strong>=（作业等待时间+作业执行时间）/作业执行时间</strong></p>
<blockquote>
<p>关于平均周转时间的一些题目</p>
<p>（１）设一个系统中有5个进程，它们的到达时间和服务时间如下，A的到达时间为0，服务时间为3；B的到达时间为2，服务时间为6；C的到达时间为4，服务时间为4；D的到达时间为6，服务时间为5；E的 到达时间为8，服务时间为2，忽略1/0以及其他开销时间，若分别按先来先服务（fFCFS）进行CPU调度，其平均周转时间为？</p>
<p>答：周转时间=作业完成时间减去作业到达时间</p>
<p>所以</p>
<p>A　完成时间　０＋３＝３　周转时间Ａ＝３－０；</p>
<p>B　完成时间　３＋６＝９　周转时间Ｂ＝９－２＝７；</p>
<p>C　完成时间　９＋４＝１３　周转时间Ｃ＝１３－４＝９；</p>
<p>D　完成时间　１３＋５＝１８　周转时间Ｄ＝１８－６＝１２；</p>
<p>E　完成时间　１８＋２＝２０　周转时间　Ｅ＝２０－８＝１２；</p>
<p>所以平均周转时间是　（３＋７＋９＋１２＋１２）／５＝８.６</p>
<p>（２）单道批处理系统有４个作业，J1 的提交时间为8 运行时间2， J2的提交时间8.6 运行时间0.6 ，J3的提交时间8.8 运行时间0.2 J4的提交时间9.0 运行时间0.5 在采用响应比优先调度算法时，其平均周转时间是？</p>
<p>响应比=（作业等待时间+作业执行时间）/ 作业执行时间</p>
<p>J1 周转时间(8+2) -8 =2；</p>
<p>此时</p>
<p>J2等待时间为(8+2-8.6)=1.4 响应比为（1.4+0.6）/0.6=10/3</p>
<p>J3 等待时机是(8+2-8.8)=1.2 响应比（1.2+0.2）/0.2=7</p>
<p>J4 等待时间是(8+2-9.0)=1.0 响应比（1.0+0.5）/0.5=3</p>
<p>因为J3的响应比最高，所以J3开始运行。J3 的完成时间是10+0.2=10.2周转时间是10.2-8.8=1.4</p>
<p>此时</p>
<p>J2的等待时间是10.2-8.6=1.6 响应比( 1.6+0.6)/0.6=11/3=3.6667</p>
<p>J4的等待时间是10.2-9.0=1.2 响应比（1.2+0.5）/0.5=3.4</p>
<p>因为J2的响应比高，所以J2 开始运行，J2的完成时间是10.2+0.6=10.8；周转时间10.8-8.6=2.2；</p>
<p>这时候运行J4,J4 的完成时间是10.8+0.5=11.3 周转时间是11.3-9.0=2.3；</p>
<p>因此平均周转时间是（2+1.4+2.2+2.3 )/4=1.975</p>
</blockquote>
<h4 id="16-fork函数"><a href="#16-fork函数" class="headerlink" title="16. fork函数"></a>16. fork函数</h4><p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p>
<blockquote>
<pre><code>1）在父进程中，fork返回新创建子进程的进程ID；
2）在子进程中，fork返回0；
3）如果出现错误，fork返回一个负值；
</code></pre></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    fpid=fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the child process, my process id is %d/n"</span>,getpid());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是爹的儿子/n"</span>);<span class="comment">//对某些人来说中文看着更直白。  </span></span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am the parent process, my process id is %d/n"</span>,getpid());   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是孩子他爹/n"</span>);  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"统计结果是: %d/n"</span>,count);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果是：<br>    i am the child process, my process id is 5574<br>    我是爹的儿子<br>    统计结果是: 1<br>    i am the parent process, my process id is 5573<br>    我是孩子他爹<br>    统计结果是: 1 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">      fork();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d.-\n"</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   wait(<span class="literal">NULL</span>);</span><br><span class="line">   wait(<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//os/fork-example.png" alt="img"></p>
<h4 id="17-上下文切换"><a href="#17-上下文切换" class="headerlink" title="17. 上下文切换"></a>17. 上下文切换</h4><p>​        Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器(Program Counter，PC)。CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。根据任务的不同，CPU的上下文切换可以分为不同的场景，也就是进程上下文切换、线程上下文切换、中断上下文切换。</p>
<p>​        上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。上下文切换过程中的信息被保存在<strong><span style="color:red">进程控制块（PCB-Process Control Block）</span></strong>中。PCB又被称作切换帧（SwitchFrame）。上下文切换的信息会一直被保存在CPU的内存中，直到被再次使用。</p>
<p><a href="https://www.cnblogs.com/williamjie/p/9466941.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9466941.html</a></p>
<h4 id="18-进程切换"><a href="#18-进程切换" class="headerlink" title="18. 进程切换"></a>18. 进程切换</h4><h3 id="（三）内存管理"><a href="#（三）内存管理" class="headerlink" title="（三）内存管理"></a>（三）内存管理</h3><h4 id="1-页面置换算法"><a href="#1-页面置换算法" class="headerlink" title="1.页面置换算法"></a>1.页面置换算法</h4><blockquote>
<ul>
<li><strong>FIFO算法</strong>：先入先出，即淘汰最早调入的页面。</li>
<li><strong>OPT(MIN)算法</strong>：选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</li>
<li><strong>LRU(Least-Recently-Used)算法</strong>：用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。性能最接近OPT。<strong>与页面使用时间有关</strong>。</li>
</ul>
<ul>
<li><strong>LFU(Least Frequently Used)算法</strong>：即最不经常使用页置换算法，要求在页置换时置换引用计数最小的页，因为经常使用的页应该有一个较大的引用次数。<strong>与页面使用次数有关</strong>。</li>
<li><strong>Clock</strong>：给每个页帧关联一个使用位，当该页第一次装入内存或者被重新访问到时，将使用位置为1。每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧。</li>
</ul>
<p>在一个请求页式存储管理中，一个程序的页面走向为 3、4、2、1、4、5、3、4、5、1、2，并采用 LRU算法。设分配给该程序的存储块数 S 分别为 3 和 4，在该访问中发生的缺页次数 F 是8,7</p>
<p><a href="https://www.nowcoder.com/questionTerminal/780dce19969445c5a7814c0ff087c103" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/780dce19969445c5a7814c0ff087c103</a></p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//os/yemianzhihuan.png" alt="img"></p>
</blockquote>
<h4 id="2-内存分页"><a href="#2-内存分页" class="headerlink" title="2. 内存分页"></a>2. 内存分页</h4><p>现代计算机都使用分页（Paging）的方式对虚拟地址空间和物理地址空间进行分割和映射，以减小换入换出的粒度，提高程序运行效率。</p>
<p>分页（Paging）的思想是指把地址空间人为地分成大小相等（并且固定）的若干份，这样的一份称为一页，就像一本书由很多页面组成，每个页面的大小相等。如此，就能够以页为单位对内存进行换入换出：</p>
<p>当程序运行时，只需要将必要的数据从磁盘读取到内存，暂时用不到的数据先留在磁盘中，什么时候用到什么时候读取。<br>当物理内存不足时，只需要将原来程序的部分数据写入磁盘，腾出足够的空间即可，不用把整个程序都写入磁盘。</p>
<h3 id="（四）I-O"><a href="#（四）I-O" class="headerlink" title="（四）I/O"></a>（四）I/O</h3><h4 id="1-I-O模式？参考"><a href="#1-I-O模式？参考" class="headerlink" title="1.I/O模式？参考"></a>1.I/O模式？<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">参考</a></h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="/2019/11/20/Java总结-1/bio.png" alt=""></th>
<th style="text-align:center"><img src="/2019/11/20/Java总结-1/nonblocking-io.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>阻塞I/O（blocking IO）</strong></td>
<td style="text-align:center"><strong>非阻塞I/O（nonblocking IO）</strong></td>
</tr>
<tr>
<td style="text-align:center"><span style="color:red">调用blocking IO会一直block住对应的进程直到操作完成</span></td>
<td style="text-align:center"><span style="color:red">non-blocking IO在kernel还准备数据的情况下会立刻返回。</span></td>
</tr>
<tr>
<td style="text-align:center"><img src="/2019/11/20/Java总结-1/multiplexing.png" alt=""></td>
<td style="text-align:center"><img src="/2019/11/20/Java总结-1/asynchronous.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><strong>I/O多路复用（ IO multiplexing）</strong></td>
<td style="text-align:center"><strong>异步I/O（asynchronous IO）</strong></td>
</tr>
</tbody>
</table>
</div>
<p><span style="color:red"><strong>下图对IO模型进行了对比：</strong></span></p>
<p><img src="/2019/11/20/Java总结-1/io-comparison.png" alt=""></p>
<h5 id="（1）阻塞I-O（blocking-IO）"><a href="#（1）阻塞I-O（blocking-IO）" class="headerlink" title="（1）阻塞I/O（blocking IO）"></a>（1）阻塞I/O（blocking IO）</h5><p>​        当<span style="color:red">用户进程</span>调用了 <code>recvfrom</code> 这个系统调用， <code>kernel</code> 就开始了 IO 的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 <code>UDP</code> 包。这个时候 <code>kernel</code> 就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当 <code>kernel</code> 一直等到数据准备好了，它就会将数据从 <code>kernel</code> 中拷贝到用户内存，然后 <code>kernel</code> 返回结果，用户进程才解除 <code>block</code> 的状态，重新运行起来。</p>
<blockquote>
<p>blocking IO的特点就是在<span style="color:red">IO执行的两个阶段</span>都被block了</p>
</blockquote>
<h5 id="（2）非阻塞I-O（nonblocking-IO）"><a href="#（2）非阻塞I-O（nonblocking-IO）" class="headerlink" title="（2）非阻塞I/O（nonblocking IO）"></a>（2）非阻塞I/O（nonblocking IO）</h5><p>​        当<span style="color:red">用户进程</span>发出 <code>read</code> 操作时，如果 <code>kernel</code> 中的数据还没有准备好，那么它并不会 <code>block</code> 用户进程，而是立刻返回一个 <code>error</code> 。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 <code>error</code> 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 <code>kernel</code> 中的数据准备好了，并且又再次收到了用户进程的 <code>system call</code> ，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有.</p>
</blockquote>
<h5 id="（3）I-O多路复用（-IO-multiplexing）"><a href="#（3）I-O多路复用（-IO-multiplexing）" class="headerlink" title="（3）I/O多路复用（ IO multiplexing）"></a>（3）I/O多路复用（ IO multiplexing）</h5><p>​        （Java中的NIO使用channel来完成多路复用）,IO multiplexing就是我们说的<span style="color:red"><strong>select，poll，epoll</strong></span>，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。所以，I/O 多路复用的特点是<strong>通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回</strong>。</p>
<h5 id="（4）信号驱动I-O（-signal-driven-IO）"><a href="#（4）信号驱动I-O（-signal-driven-IO）" class="headerlink" title="（4）信号驱动I/O（ signal driven IO）"></a>（4）信号驱动I/O（ signal driven IO）</h5><h5 id="（5）异步I-O（asynchronous-IO）"><a href="#（5）异步I-O（asynchronous-IO）" class="headerlink" title="（5）异步I/O（asynchronous IO）"></a>（5）异步I/O（asynchronous IO）</h5><p>​        （并不会加快io的过程）用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 <code>kernel</code> 的角度，当它受到一个 <code>asynchronous read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何 <code>block</code> 。然后，<code>kernel</code> 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，<code>kernel</code> 会给用户进程发送一个 <code>signal</code> ，告诉它 <code>read</code> 操作完成了。</p>
<h4 id="2-零拷贝zero-copy"><a href="#2-零拷贝zero-copy" class="headerlink" title="2.零拷贝zero-copy"></a>2.零拷贝zero-copy</h4><p>​        零拷贝操作减少了<span style="color:red">在用户空间与内核空间之间切换模式的次数。</span>磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如<span style="color:red"><strong>零拷贝</strong></span>、直接 I/O、异步 I/O 等等，这些优化的目的就是为了提高系统的吞吐量，另外操作系统内核中的磁盘高速缓存区，可以有效的减少磁盘的访问次数。</p>
<h5 id="2-1-用户空间和内核空间"><a href="#2-1-用户空间和内核空间" class="headerlink" title="2.1 用户空间和内核空间"></a>2.1 用户空间和内核空间</h5><p>​        说到零拷贝，首先“用户空间”和“内核空间”说起，用户空间和内核空间的空间、权限以及作用是不一样的，<span style="color:red">用户空间</span>是提供给各个用户使用的主要空间，<span style="color:red">内核空间</span>是操作系统自身使用的空间，主要提供给程序调度、内存分配、连接硬件资源等。</p>
<p><span style="color:red">用户空间不具备访问内核空间资源的权限，</span>因此如果应用程序需要使用到内核资源的话，必须切换到内核空间：<span style="color:red">首先从用户空间切换到内核空间，然后在完成相关的操作后再从内核空间切换到用户空间。</span></p>
<h5 id="2-2-DMA技术"><a href="#2-2-DMA技术" class="headerlink" title="2.2 DMA技术"></a>2.2 DMA技术</h5><p>在没有 DMA 技术前，I/O 的过程是这样的：</p>
<ul>
<li>CPU 发出对应的指令给磁盘控制器，然后返回；</li>
<li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到<span style="color:red">磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</span></li>
<li>CPU     收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间     CPU 是无法执行其他任务的。</li>
</ul>
<p>流程如下：</p>
<p><img src="/2019/11/20/Java总结-1/BEFORE-DMA.png" alt=""></p>
<p>​        可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是直接内存访问（Direct Memory Access）技术。</p>
<p><span style="color:red"><strong>什么是 DMA 技术？</strong></span>简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。流程如下：</p>
<p><img src="/2019/11/20/Java总结-1/DMA.png" alt=""></p>
<p>具体过程：</p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li><span style="color:red"><strong>DMA 进一步将 I/O 请求发送给磁盘；</strong></span></li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向     DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA     收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>
<p>​        可以看到， 整个数据传输的过程，<span style="color:red">CPU 不再参与数据搬运的工作，而是全程由 DMA 完成</span>，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以<span style="color:red">每个 I/O 设备里面都有自己的 DMA 控制器。</span></p>
<h5 id="2-3-传统文件传输有多糟糕？"><a href="#2-3-传统文件传输有多糟糕？" class="headerlink" title="2.3 传统文件传输有多糟糕？"></a>2.3 传统文件传输有多糟糕？</h5><p>代码通常如下，一般会需要两个系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/20/Java总结-1/read_write.png" alt=""></p>
<p>首先，期间共<span style="color:red"><strong>发生了 4 次用户态与内核态的上下文切换</strong></span>，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p>
<p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><strong><em>第一次拷贝</em></strong>，把磁盘上的数据拷贝到<span style="color:red">操作系统内核</span>的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><strong><em>第二次拷贝</em></strong>，把内核缓冲区的数据拷贝到<span style="color:red">用户的缓冲区</span>里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由     CPU 完成的。</li>
<li><strong><em>第三次拷贝</em></strong>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到<span style="color:red">内核的 socket 的缓冲区</span>里，这个过程依然还是由 CPU 搬运的。</li>
<li><strong><em>第四次拷贝</em></strong>，把内核的 socket 缓冲区里的数据，拷贝到<span style="color:red">网卡的缓冲区</span>里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p>
<h5 id="2-4-零拷贝—-mmap-write"><a href="#2-4-零拷贝—-mmap-write" class="headerlink" title="2.4 零拷贝—-mmap+write"></a>2.4 零拷贝—-mmap+write</h5><p>在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，<span style="color:red">我们可以用 mmap() 替换 read() 系统调用函数。</span></p>
<p><img src="/2019/11/20/Java总结-1/mmap_write.png" alt=""></p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 mmap() 后，DMA  会把磁盘的数据拷贝到内核的缓冲区里。接着，<span style="color:red">应用进程跟操作系统内核「共享」这个缓冲区；</span></li>
<li>应用进程再调用 write()，操作系统直接将<span style="color:red">内核缓冲区</span>的数据拷贝到 <span style="color:red">socket 缓冲区</span>中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>​        我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<h5 id="2-5-零拷贝—-sendfile"><a href="#2-5-零拷贝—-sendfile" class="headerlink" title="2.5 零拷贝—-sendfile"></a>2.5 零拷贝—-sendfile</h5><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p>以上，只有一条系统命令，只会引起以此上下文切换。</p>
<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<ul>
<li><p>首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
</li>
<li><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
</li>
</ul>
<p><img src="/2019/11/20/Java总结-1/zero_copy_1.png" alt=""></p>
<h5 id="2-6-零拷贝—-SG-DMA"><a href="#2-6-零拷贝—-SG-DMA" class="headerlink" title="2.6 零拷贝—-SG-DMA"></a>2.6 零拷贝—-SG-DMA</h5><p>如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k eth0 | grep scatter-gather</span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure>
<p>于是，从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA     控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket     缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<p><img src="/2019/11/20/Java总结-1/sg-dma.png" alt=""></p>
<p>这就是所谓的<span style="color:red">零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。（零拷贝：全程没有使用CPU搬运数据）</span></p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
<h5 id="2-7-Netty的零拷贝实现？"><a href="#2-7-Netty的零拷贝实现？" class="headerlink" title="2.7 Netty的零拷贝实现？"></a>2.7 Netty的零拷贝实现？</h5><p>​        在 <span style="color:red"> OS 层面</span>上的 Zero-copy 通常指避免在 <span style="color:red"> 用户态(User-space) 与 内核态(Kernel-space) </span>之间来回拷贝数据。而在 Netty 层面 ，零拷贝主要体现在对于数据操作的优化。</p>
<ul>
<li>Netty 中的零拷贝体现在以下几个方面：使用 Netty 提供的<span style="color:red"> <strong>CompositeByteBuf 类</strong></span>, 可以将多个ByteBuf 合并为一个逻辑上的 ByteBuf, <span style="color:red">避免了各个 ByteBuf 之间的拷贝</span>。</li>
<li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了<span style="color:red">内存的拷贝</span>。</li>
<li>通过 FileRegion 包装的<span style="color:red">FileChannel.tranferTo </span>实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li>
</ul>
<h4 id="3-同步异步，阻塞非阻塞的区别。"><a href="#3-同步异步，阻塞非阻塞的区别。" class="headerlink" title="3.同步异步，阻塞非阻塞的区别。"></a>3.同步异步，阻塞非阻塞的区别。</h4><h5 id="（1）阻塞，非阻塞指的有无返回值"><a href="#（1）阻塞，非阻塞指的有无返回值" class="headerlink" title="（1）阻塞，非阻塞指的有无返回值"></a>（1）阻塞，非阻塞指的有无返回值</h5><h5 id="（2）同步异步指的是能否继续执行"><a href="#（2）同步异步指的是能否继续执行" class="headerlink" title="（2）同步异步指的是能否继续执行"></a>（2）同步异步指的是能否继续执行</h5><p>无论阻塞式IO还是非阻塞式IO，都是同步IO模型，区别就在与第一步是否完成后才返回，但第二步都需要当前进程去完成，异步IO呢，就是从第一步开始就返回，直到第二步完成后才会返回一个消息，也就是说，非阻塞能够让你在第一步时去做其它的事情，而真正的异步IO能让你第二步的过程也能去做其它事情.</p>
<h3 id="（五）linux使用"><a href="#（五）linux使用" class="headerlink" title="（五）linux使用"></a>（五）linux使用</h3><h4 id="1-CPU占用过高排查"><a href="#1-CPU占用过高排查" class="headerlink" title="1.CPU占用过高排查"></a>1.CPU占用过高排查</h4><p>（1）top</p>
<p>（2）ps -ef | grep java或者jps定位</p>
<p>（3）定位到具体的线程：ps -mp 进程 -o THREAD,tid,time</p>
<p>（4）将线程ID转换为16进制的格式：print “%x\n” 数字</p>
<p>（5）jstack 进程id | grep tid（16进制线程id的小写）-A60</p>
<h4 id="2-补充"><a href="#2-补充" class="headerlink" title="2.补充"></a>2.补充</h4><ul>
<li>计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。</li>
<li>操作系统的五大功能，分别为：<code>作业管理</code>、<code>文件管理</code>、<code>存储管理</code>、<code>输入输出设备管理</code>、<code>进程及处理机管理</code></li>
<li>中断：所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：<ul>
<li><code>内部异常中断</code>：由计算机硬件异常或故障引起的中断；</li>
<li><code>软中断</code>：由程序中执行了引起中断的指令而造成的中断（这也是和我们将要说明的系统调用相关的中断）；</li>
<li><code>外部中断</code>：由外部设备请求引起的中断，比如I/O请求。</li>
</ul>
</li>
<li>系统调用：进程的执行在系统上的两个级别：用户级和核心级，也称为<code>用户态</code>和<code>系统态</code>(<code>user mode</code> and <code>kernel mode</code>)。<strong>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用</strong>。</li>
</ul>
<h4 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令?"></a>3.命令?</h4><blockquote>
<ul>
<li>lsof -i:80 查看端口</li>
<li>awk</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">#/usr/bin env</span></span><br><span class="line">&gt; <span class="comment"># 通过find递归，得到所有的文件的完整路径,在当前路径下，递归遍历所有的文件，每个文件使用逗号分割，找出每一行第一列值为10的所有文件的记录的行号和文件名。</span></span><br><span class="line">&gt; files=$(find ./ -<span class="built_in">type</span> f)</span><br><span class="line">&gt; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$files</span></span><br><span class="line">&gt;<span class="keyword">do</span></span><br><span class="line">&gt;  <span class="comment"># awk的-F选项指定分割符号，-v是指定的变量，可以在print中打印，'$1=="10"是指第一列中等于10的，print NR表示的是指示的行号，uniq指的是过滤掉重复的，&gt;&gt;out指的是追加到out文件</span></span><br><span class="line">&gt;awk -F <span class="string">","</span> -v mao=<span class="variable">$PWD</span> <span class="string">'$1=="10"&#123;print NR,FILENAME&#125;'</span> <span class="variable">$i</span> | uniq &gt;&gt;out</span><br><span class="line">&gt; <span class="keyword">done</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sed</p>
<blockquote>
<ul>
<li>选项<ul>
<li>-n</li>
<li>-e（多条命令顺序执行，命令使用分号切割）</li>
<li>-f</li>
<li>-r</li>
<li>-i（写入文件）</li>
</ul>
</li>
<li>命令<ul>
<li>a（append新增）</li>
<li>c（行替换）</li>
<li>d（delete删除）</li>
<li>i（insert前面插入）</li>
<li>p（print打印）</li>
<li>s（字符串的替换</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h2><h3 id="1-B-树，B-树？"><a href="#1-B-树，B-树？" class="headerlink" title="1.B-树，B+树？"></a>1.B-树，B+树？</h3><p>画出一颗简单的B+树，给定一个ID（主键），简述B+树的查找过程</p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<p>B树 <a href="https://blog.csdn.net/li_canhui/article/details/85305147" target="_blank" rel="noopener">https://blog.csdn.net/li_canhui/article/details/85305147</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">定义任意非叶子结点最多只有M个儿子；且M&gt;2；</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">根结点的儿子数为[2, M]；根节点的数目是个例外</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">除根结点以外的非叶子结点的儿子数为[M/2, M]；,除了根节点,最少有M/2向上取整个子节点</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">非叶子结点的关键字个数=指向儿子的指针个数-1；（有减1,一个绳子砍三刀分为四截）</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">非叶子结点的关键字：K<a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;share_source=copy_web" title=" 红黑树B站最NB教程" target="_blank" rel="noopener">1</a>, K<a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=4&amp;share_source=copy_web" title="B站手撕红黑树代码，原生态版本" target="_blank" rel="noopener">2</a>, …, K[M-1]；且K[i] &lt; K[i+1]；</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">非叶子结点的指针：P<a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;share_source=copy_web" title=" 红黑树B站最NB教程" target="_blank" rel="noopener">1</a>, P<a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=4&amp;share_source=copy_web" title="B站手撕红黑树代码，原生态版本" target="_blank" rel="noopener">2</a>, …, P[M]；其中P<a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;share_source=copy_web" title=" 红黑树B站最NB教程" target="_blank" rel="noopener">1</a>指向关键字小于K<a href="https://www.bilibili.com/video/BV1UJ411J7CU?p=2&amp;share_source=copy_web" title=" 红黑树B站最NB教程" target="_blank" rel="noopener">1</a>的<br>子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；,当成数轴来看, K[M-1]——————K[M],因为中间节点包含了数值,所以都是开区间</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">所有叶子结点位于同一层；</td>
</tr>
</tbody>
</table>
</div>
<p>B+树</p>
<p>（3,5,8,9,10,12,13,15,17,26,28,29,30,35,36,60,65,75,79,87,90,99）</p>
<blockquote>
<p>B+树是B-树的变体，也是一种多路搜索树，其定义基本与B-树同，除了： </p>
<p>（1）非叶子结点的子树指针与关键字个数相同；(没有减1)</p>
<p>（2）非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])(前闭后开)的子树（B-树是开区间）；</p>
<p>（3）为所有叶子结点增加一个链指针；</p>
<p>（4）所有关键字都在叶子结点出现；</p>
</blockquote>
<ul>
<li>关键字和指针数量的关系:B树减1,B+树相等</li>
<li>指向区间:B树开区间,B+树前闭后开</li>
<li>叶节点是否增加指针?B树没有,B+树有</li>
</ul>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//basic/btree.png" alt="img"></p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//basic/bplustree.png" alt="img"></p>
<h3 id="2-二叉树的遍历，非递归？"><a href="#2-二叉树的遍历，非递归？" class="headerlink" title="2.二叉树的遍历，非递归？"></a>2.二叉树的遍历，非递归？</h3><ul>
<li>前序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder1</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">    preorder1(root.getLeft());</span><br><span class="line">    preorder1(root.getRight());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt;stack =<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode cur;</span><br><span class="line">    cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(cur.getData()+<span class="string">"\t"</span>);<span class="comment">//根</span></span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.getLeft();<span class="comment">//左</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            cur=cur.getRight();<span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>中序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder1</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inorder1(root.getLeft());</span><br><span class="line">    System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">    inorder1(root.getRight());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt;stack =<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BinaryTreeNode cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.getLeft();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            System.out.print(cur.getData()+<span class="string">"\t"</span>);</span><br><span class="line">            cur=cur.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder1</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postorder1(root.getLeft());</span><br><span class="line">    postorder1(root.getRight());</span><br><span class="line">    System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root=root.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(stack.lastElement().getRight()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                root=stack.pop();</span><br><span class="line">                System.out.print(root.getData()+<span class="string">"\t"</span>);</span><br><span class="line">                <span class="keyword">while</span> (stack.lastElement().getRight()==root)&#123;</span><br><span class="line">                    System.out.print(stack.lastElement().getData()+<span class="string">"\t"</span>);</span><br><span class="line">                    root=stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">                root=stack.lastElement().getRight();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder3</span><span class="params">(BinaryTreeNode root)</span></span>&#123;<span class="comment">//修改前序遍历的方式为：根右左</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTreeNode&gt;();</span><br><span class="line">    BinaryTreeNode cur;</span><br><span class="line">    cur=root;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(cur.getData());</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur=cur.getRight();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            cur=cur.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">for</span> (Integer i:res)&#123;</span><br><span class="line">        System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>层次遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelorder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">     BinaryTreeNode temp;</span><br><span class="line">     Queue&lt;BinaryTreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;BinaryTreeNode&gt;();</span><br><span class="line">     queue.offer(root);</span><br><span class="line">     <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">         temp=queue.poll();</span><br><span class="line">         System.out.print(temp.getData()+<span class="string">"\t"</span>);</span><br><span class="line">         <span class="keyword">if</span>(temp.getLeft()!=<span class="keyword">null</span>)&#123;<span class="comment">//左</span></span><br><span class="line">             queue.offer(temp.getLeft());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(temp.getRight()!=<span class="keyword">null</span>)&#123;<span class="comment">//右</span></span><br><span class="line">             queue.offer(temp.getRight());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-循环队列？"><a href="#3-循环队列？" class="headerlink" title="3.循环队列？"></a>3.循环队列？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonProblems.ArrayProblems;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> CycQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 循环队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 上午9:46 2019/9/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxsize;</span><br><span class="line">    <span class="keyword">private</span> Object[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CycQueue</span><span class="params">(<span class="keyword">int</span> maxsize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxsize = maxsize;</span><br><span class="line">        <span class="keyword">this</span>.arr =<span class="keyword">new</span> Object[maxsize];</span><br><span class="line">        <span class="keyword">this</span>.front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front==tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CycQueue <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        arr=<span class="keyword">null</span>;</span><br><span class="line">        front=tail=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CycQueue <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        front=tail=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;maxsize ; i++) &#123;</span><br><span class="line">            arr[i]=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (tail-front+maxsize)%maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">head</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((tail+<span class="number">1</span>)%maxsize==front)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail=(tail+<span class="number">1</span>)%maxsize;</span><br><span class="line">        arr[tail]=e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front==tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T e=(T)arr[front];</span><br><span class="line">        front=(front+<span class="number">1</span>)%maxsize;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CycQueue c=<span class="keyword">new</span> CycQueue(<span class="number">6</span>);</span><br><span class="line">        c.add(<span class="number">1</span>);</span><br><span class="line">        c.add(<span class="number">2</span>);</span><br><span class="line">        c.add(<span class="number">3</span>);</span><br><span class="line">        c.add(<span class="number">4</span>);</span><br><span class="line">        c.add(<span class="number">5</span>);</span><br><span class="line">        c.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(c.add(<span class="number">7</span>));</span><br><span class="line">        System.out.println(c.pop());</span><br><span class="line">        System.out.println(c.pop());</span><br><span class="line">        System.out.println(c.add(<span class="number">7</span>));</span><br><span class="line">        System.out.println(c.add(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            System.out.print(c.arr[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Trie-Tree（208-Implement-Trie-Prefix-Tree-）"><a href="#4-Trie-Tree（208-Implement-Trie-Prefix-Tree-）" class="headerlink" title="4.Trie Tree（208. Implement Trie (Prefix Tree)）"></a>4.Trie Tree（208. Implement Trie (Prefix Tree)）</h3><blockquote>
<p>Trie，又经常叫前缀树，字典树等等。它有很多变种，如后缀树，Radix Tree/Trie，PATRICIA tree，以及bitwise版本的crit-bit tree。当然很多名字的意义其实有交叉。</p>
<ul>
<li>应用<ul>
<li><strong>字符串检索</strong></li>
<li><strong>文本预测、拼写检查</strong></li>
<li><strong>词频统计</strong></li>
<li><strong>排序</strong></li>
<li><strong>字符串最长公共前缀</strong></li>
<li><strong>字符串搜索的前缀匹配</strong></li>
<li><strong>作为其他数据结构和算法的辅助结构</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="5-树，图节点以及度数相关？"><a href="#5-树，图节点以及度数相关？" class="headerlink" title="5.树，图节点以及度数相关？"></a>5.树，图节点以及度数相关？</h3><blockquote>
<ul>
<li><p>二叉树中n个节点，0度、 1度、 2度的关系？</p>
<blockquote>
<p>度为2节点数 = 叶子节点数 - 1</p>
<p>证明：</p>
<ul>
<li>树支路总数 = 树节点总数 - 1</li>
<li>树支路总数=0<em>x0 + 1</em>x1 + 2*x2 </li>
<li>树节点总数=x0 + x1 + x2   -  1</li>
<li>得到：度为0与度为2的节点数的关系x2  = x0 -  1</li>
</ul>
</blockquote>
</li>
<li><p>无向图度数和边数的关系：度数等于二倍的边数。</p>
</li>
</ul>
</blockquote>
<h2 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h2><h3 id="1-算法的分类？"><a href="#1-算法的分类？" class="headerlink" title="1.算法的分类？"></a>1.算法的分类？</h3><h3 id="2-弗洛伊德算法？"><a href="#2-弗洛伊德算法？" class="headerlink" title="2.弗洛伊德算法？"></a>2.弗洛伊德算法？</h3><p>（三层for循环，通过第三个点不断更新两个点之间的距离）<a href="https://www.cnblogs.com/lc-java/p/7840464.html" target="_blank" rel="noopener">https://www.cnblogs.com/lc-java/p/7840464.html</a></p>
<h3 id="3-迪杰斯特拉算法？"><a href="#3-迪杰斯特拉算法？" class="headerlink" title="3.迪杰斯特拉算法？"></a>3.迪杰斯特拉算法？</h3><p><a href="https://www.cnblogs.com/he-px/p/6677063.html" target="_blank" rel="noopener">https://www.cnblogs.com/he-px/p/6677063.html</a></p>
<p><a href="https://www.cnblogs.com/zengzhihua/p/6755439.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengzhihua/p/6755439.html</a></p>
<h3 id="4-二分法？（边界问题）"><a href="#4-二分法？（边界问题）" class="headerlink" title="4.二分法？（边界问题）"></a>4.二分法？（边界问题）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//减1</span></span><br><span class="line">    <span class="keyword">int</span> end=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//等号</span></span><br><span class="line">    <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            start=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-排序算法"><a href="#5-排序算法" class="headerlink" title="5.排序算法"></a>5.排序算法</h3><h4 id="（1）堆排序"><a href="#（1）堆排序" class="headerlink" title="（1）堆排序"></a>（1）堆排序</h4><p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//algo/headsort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ALiBaBa;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> HeapSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</span></span><br><span class="line"><span class="comment"> * 小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 下午11:35 2019/8/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.构建大顶堆（头部就是0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构（不包含length）</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素（取值length-1次）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整（不包含j）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）归并排序"><a href="#（2）归并排序" class="headerlink" title="（2）归并排序"></a>（2）归并排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ALiBaBa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MergeSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 上午11:40 2019/8/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            mergeSort(nums,left,mid);</span><br><span class="line">            mergeSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">            merge(nums,left,right,mid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPos=left;</span><br><span class="line">        <span class="keyword">int</span> pos=left;</span><br><span class="line">        <span class="keyword">int</span> rightPos=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len=right-left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] tmp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(leftPos&lt;=mid&amp;&amp;rightPos&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[leftPos]&gt;nums[rightPos])&#123;</span><br><span class="line">                tmp[pos++]=nums[rightPos++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[pos++]=nums[leftPos++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(leftPos&lt;=mid)&#123;</span><br><span class="line">            tmp[pos++]=nums[leftPos++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rightPos&lt;=right)&#123;</span><br><span class="line">            tmp[pos++]=nums[rightPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=left;</span><br><span class="line">        <span class="keyword">int</span> n=left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            nums[m++]=tmp[n++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">73</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）快速排序"><a href="#（3）快速排序" class="headerlink" title="（3）快速排序"></a>（3）快速排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ALiBaBa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> QuickSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 上午11:39 2019/8/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=partition(nums,left,right);</span><br><span class="line">            quickSort(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">            quickSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=left;</span><br><span class="line">        <span class="keyword">int</span> value=nums[pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;value)&#123;</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos!=i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp=nums[pos];</span><br><span class="line">                    nums[pos]=nums[i];</span><br><span class="line">                    nums[i]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left]=nums[pos];</span><br><span class="line">        nums[pos]=value;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-LRU算法？"><a href="#6-LRU算法？" class="headerlink" title="6.LRU算法？"></a>6.LRU算法？</h3><ul>
<li>双向链表加HashMap的实现，重要需要完成的功能点为：<ul>
<li>将当前访问的节点放到队列的头部</li>
<li>当容量不够的时候，将队列尾部的元素移走，并且在HashMap中消除</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.AlgorithmDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> LRUCache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用链表保证相对顺序，使用栓链表，两个指针可以使得两种删除操作更加容易，使用HashMap是为了快速查找！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 上午9:16 2019/8/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUNode</span> </span>&#123;</span><br><span class="line">    String key;</span><br><span class="line">    Object value;</span><br><span class="line">    LRUNode prev;</span><br><span class="line">    LRUNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUNode</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, LRUNode&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> LRUNode head;<span class="comment">//记录尾部</span></span><br><span class="line">    <span class="keyword">private</span> LRUNode tail;<span class="comment">//记录尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        LRUNode node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//原来的节点</span></span><br><span class="line">            node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            remove(node, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新节点</span></span><br><span class="line">            node = <span class="keyword">new</span> LRUNode(key, value);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">// 每次容量不足时先删除最久未使用的元素</span></span><br><span class="line">                remove(tail, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将刚添加的元素设置为head</span></span><br><span class="line">        setHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        LRUNode node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将刚操作的元素放到head，将node从原来的位置删除（这里的删除其实就是将这个node移动到队列的头部）</span></span><br><span class="line">            remove(node, <span class="keyword">false</span>);</span><br><span class="line">            setHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(LRUNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立双向指针</span></span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head.prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        head = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个加入的node设置为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中删除此Node，此时要注意该Node是head或者是tail的情形</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(LRUNode node, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双向指针</span></span><br><span class="line">        <span class="keyword">if</span> (node.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除的节点是head</span></span><br><span class="line">            head = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除的节点是tail，需要重新设置tail为当前节点的前一个节点</span></span><br><span class="line">            tail = node.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//容量不够的时候从map中删除</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            map.remove(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;String, LRUNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LRU的缓存，需要完成超时淘汰和LRU淘汰？,对上面的代码进行修改，每一次get或者set操作将不是当前的LRUNode的age加上一，当前的置为0，紧接着对于HashMap中的所有LRUNode的年龄进行判断，当年龄不够的时候从链表和HashMap中移走。</li>
<li>基于LinkedHashMap的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//定义缓存的容量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">        <span class="comment">//带参数的构造器</span></span><br><span class="line">        LRULinkedHashMap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">            <span class="comment">//如果accessOrder为true的话，则会把访问过的元素放在链表后面，放置顺序是访问的顺序(最近访问的将会被放到队列尾部，即后删除)</span></span><br><span class="line">            <span class="comment">//如果accessOrder为flase的话，则按插入顺序来遍历</span></span><br><span class="line">            <span class="keyword">super</span>(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);<span class="comment">//父类的构造器</span></span><br><span class="line">            <span class="comment">//传入指定的缓存最大容量</span></span><br><span class="line">            <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现LRU的关键方法，如果map里面的元素个数大于了缓存最大容量，则删除链表的顶端元素</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size()&gt;capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRULinkedHashMap&lt;String, Integer&gt; testCache = <span class="keyword">new</span> LRULinkedHashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        testCache.put(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">        testCache.put(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">        testCache.put(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(testCache.get(<span class="string">"B"</span>));</span><br><span class="line">        System.out.println(testCache.get(<span class="string">"A"</span>));</span><br><span class="line">        testCache.put(<span class="string">"D"</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(testCache.get(<span class="string">"D"</span>));</span><br><span class="line">        System.out.println(testCache.get(<span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-洗牌算法？"><a href="#7-洗牌算法？" class="headerlink" title="7.洗牌算法？"></a>7.洗牌算法？</h3><h3 id="8-朋友圈LeetCode547"><a href="#8-朋友圈LeetCode547" class="headerlink" title="8.朋友圈LeetCode547?"></a>8.朋友圈LeetCode547?</h3><h3 id="9-卡特兰数"><a href="#9-卡特兰数" class="headerlink" title="9.卡特兰数"></a>9.卡特兰数</h3><ul>
<li>字节跳动客户端2019笔试题目，圆圈，点，道路</li>
<li>阿里巴巴括号匹配的种类</li>
</ul>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//algorithm/Catalan.png" alt="img"></p>
<h3 id="10-排序算法"><a href="#10-排序算法" class="headerlink" title="10.排序算法"></a>10.排序算法</h3><p><a href="https://www.runoob.com/w3cnote/sort-algorithm-summary.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/sort-algorithm-summary.html</a></p>
<ul>
<li>八大排序算法真的是面试宠儿      </li>
<li>最常考 快速排序 和归并排序      </li>
<li>不稳定(快些选堆)</li>
<li>时间复杂度（快些归堆O(nlogn)）      </li>
<li>堆排 也应该掌握   </li>
</ul>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//algorithm/sortmethod.png" alt="img"></p>
<h3 id="11-树"><a href="#11-树" class="headerlink" title="11. 树"></a>11. 树</h3><ul>
<li>根据遍历结果恢复树，递归      </li>
<li>二叉搜索树第k大      </li>
<li>树的和为k的路径</li>
<li>树的最大路径和      </li>
<li>层次遍历      </li>
<li>根据层次遍历和后序遍历恢复树      </li>
<li>镜像树      </li>
<li>树的深度       </li>
<li>是不是平衡二叉树      </li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><span style="color:red">中序遍历是有序的。</span></p>
<p>红黑树是每个节点都带有<em>颜色</em>属性的<a href="https://zh.wikipedia.org/wiki/二元搜尋樹" target="_blank" rel="noopener">二叉查找树</a>，颜色为<em>红色</em>或<em>黑色</em>。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：</p>
<blockquote>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li>
<li><span style="color:red">从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</span>(黑色节点完美平衡)</li>
</ol>
</blockquote>
<p>下面是一个具体的红黑树的图例：</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/Red-black_tree_example.png" alt="img"></p>
<ul>
<li><p>操作</p>
<ul>
<li>着色</li>
<li>左旋转：你当我儿子，我的左二子当你的右儿子；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*		p                               p</span></span><br><span class="line"><span class="comment">*		|                               |</span></span><br><span class="line"><span class="comment">*		x                               y</span></span><br><span class="line"><span class="comment">*	   / \          ------&gt;            / \</span></span><br><span class="line"><span class="comment">*	 lx   y                           x   ry</span></span><br><span class="line"><span class="comment">*        / \                         / \</span></span><br><span class="line"><span class="comment">*       ly  ry                      lx  ly</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">(RBNode x)</span> </span>&#123;</span><br><span class="line">    RBNode y = x.right;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我的左儿子变为你的右儿子</span></span><br><span class="line">    x.right = y.left;</span><br><span class="line">    <span class="comment">// 注意parent不能够丢下！！！</span></span><br><span class="line">    <span class="keyword">if</span>(y.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        y.left.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我变成爸爸啦</span></span><br><span class="line">    <span class="keyword">if</span>(x.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        y.parent = x.parent;</span><br><span class="line">        <span class="keyword">if</span>(x == x.panrent.left) &#123;</span><br><span class="line">            x.parent.left = y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.parent.right = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 你变成我儿子</span></span><br><span class="line">    x.parent = y;</span><br><span class="line">    y.left = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>右旋转：你当我儿子，我的右儿子当你的左儿子。</li>
</ul>
<h4 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h4><blockquote>
<p>1.说说你对hash算法的理解<br>   追问：hash算法任意长度的输入 转化为了 固定长度的输出，会不会有问题呢？<br>   追问：hash冲突能避免么？<br>2.你认为好的hash算法，应该考虑点有哪些呢？<br>3.HashMap中存储数据的结构是什么样的呢？<br>4.创建HashMap时，不指定散列表数组长度，初始长度是多少呢？<br>   追问：散列表是new HashMap() 时创建的么？<br>5.默认负载因子是多少呢，并且这个负载因子有什么作用？<br>6.链表转化为红黑树，需要达到什么条件呢？<br>7.Node对象内部的hash字段，这个hash值是key对象的hashcode()返回值么？<br>   追问：这个hash值是怎么得到呢？<br>   追问：hash字段为什么采用高低位异或？<br>8.HashMap put 写数据的具体流程，尽可能的详细点！<br>9.红黑树的写入操作，是怎么找到父节点的，找父节点流程？<br>10.TreeNode数据结构，简单说下。<br>11.红黑树的原则有哪些呢？<br>12.JDK8 hashmap为什么引入红黑树？解决什么问题？<br>    追问：为什么hash冲突后性能变低了？【送分题】<br>13.hashmap 什么情况下会触发扩容呢？<br>    追问：触发扩容后，会扩容多大呢？算法是什么？<br>    追问：为什么采用位移运算，不是直接*2？<br>14.hashmap扩容后，老表的数据怎么迁移到扩容后的表的呢？<br>15.hashmap扩容后，迁移数据发现该slot是颗红黑树，怎么处理呢？</p>
</blockquote>
<h3 id="12-链表"><a href="#12-链表" class="headerlink" title="12.链表"></a>12.链表</h3><ul>
<li>反转链表      </li>
<li>链表环的入口      </li>
<li>交叉链表的交点      </li>
<li>复杂链表的复制      </li>
<li>二叉搜索树变成双向链表      </li>
</ul>
<h3 id="13-回溯算法"><a href="#13-回溯算法" class="headerlink" title="13.回溯算法"></a>13.回溯算法</h3><ul>
<li>走迷宫      </li>
<li>游戏通关      </li>
</ul>
<h3 id="14-递推算法"><a href="#14-递推算法" class="headerlink" title="14.递推算法"></a>14.递推算法</h3><ul>
<li>走台阶      </li>
<li>断钢筋      </li>
</ul>
<h3 id="15-背包问题"><a href="#15-背包问题" class="headerlink" title="15. 背包问题"></a>15. 背包问题</h3><ul>
<li>装最多的东西      </li>
</ul>
<h3 id="16-贪心算法"><a href="#16-贪心算法" class="headerlink" title="16.贪心算法"></a>16.贪心算法</h3><ul>
<li>覆盖问题      </li>
<li>时间问题</li>
</ul>
<h3 id="17-编辑距离"><a href="#17-编辑距离" class="headerlink" title="17.编辑距离"></a>17.编辑距离</h3><ul>
<li>对一个八位数有三种操作： 加一、减一、反转 。 至少多少次操作可以把一个八位数A变成八位数B。？</li>
<li>leetcode 72</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> CommonProblems.Dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> EditDistance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 下午3:40 2019/9/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=s1.length();</span><br><span class="line">        <span class="keyword">int</span> n=s2.length();</span><br><span class="line">        <span class="comment">//dp[i][j]表示长度为i的s1的子串转换为长度为j的s2的子串的操作次数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=m ; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;<span class="comment">//删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;<span class="comment">//插入</span></span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> replaces=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    replaces=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    replaces=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j]=Math.min(replaces,<span class="comment">//替换</span></span><br><span class="line">                        Math.min(dp[i-<span class="number">1</span>][j],<span class="comment">//插入</span></span><br><span class="line">                                dp[i][j-<span class="number">1</span>]+<span class="number">1</span>)<span class="comment">//删除</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-dfs"><a href="#18-dfs" class="headerlink" title="18.dfs"></a>18.dfs</h3><ul>
<li>一个有向图用邻接矩阵表示，并且是有权图，现在问怎么判断图中有没有环。使用一个全局的一维数组保存访问的状态，对于每一个节点i，递归遍历当前节点指向的节点，当重新访问到当前的节点的时候，就是存在环路，直接返回true。</li>
</ul>
<h3 id="19-两个str-最大公共子序列和子串？"><a href="#19-两个str-最大公共子序列和子串？" class="headerlink" title="19.两个str 最大公共子序列和子串？"></a>19.两个str 最大公共子序列和子串？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxCommon</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr1=s1.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> m=arr1.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr2=s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n=arr2.length+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[i-<span class="number">1</span>]==arr2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);<span class="comment">//最长公共子序列</span></span><br><span class="line"><span class="comment">//                    dp[i][j]=0;//最长公共子串</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res&lt;dp[i][j])&#123;</span><br><span class="line">                    res=dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    


    
    
    

    
      <div>
         <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    

    
      <div>
        

      </div>
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>我知道是不会有人点的，但万一有人想不开呢？</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="袤锅 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="袤锅 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/20/Java总结-2/" rel="next" title="Java总结-2">
                <i class="fa fa-chevron-left"></i> Java总结-2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/20/Java总结-4/" rel="prev" title="Java总结-4">
                Java总结-4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
		  <div>
  <font color='#FFC0CB' size=20>Mao&Ping Adventure:</font><canvas id="canvasDiyBlock" style="width:60%;">x</canvas>。
</div>
<script>
	/*生成倒计时数字*/
	function getTimeDiff(){
		var date1= '2020/10/04 00:00:00';  //开始时间  
		var date2 = new Date();    //结束时间  
		var date3 = date2.getTime() - new Date(date1).getTime();   //时间差的毫秒数        

		//计算出相差天数  
		var days=Math.floor(date3/(24*3600*1000))  
		//计算出小时数  
		var leave1=date3%(24*3600*1000)    //计算天数后剩余的毫秒数  
		var hours=Math.floor(leave1/(3600*1000))  
		//计算相差分钟数  
		var leave2=leave1%(3600*1000)        //计算小时数后剩余的毫秒数  
		var minutes=Math.floor(leave2/(60*1000))  
		//计算相差秒数  
		var leave3=leave2%(60*1000)      //计算分钟数后剩余的毫秒数  
		var seconds=Math.round(leave3/1000) 
		return ("00000"+days).substr(-5)+":"+("00"+hours).substr(-2)+":"+("00"+minutes).substr(-2)+":"+("00"+seconds).substr(-2)
	}
(function () {
  var digit =
    [
      [
        [0, 0, 1, 1, 1, 0, 0],
        [0, 1, 1, 0, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 0, 1, 1, 0],
        [0, 0, 1, 1, 1, 0, 0]
      ],//0
      [
        [0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1]
      ],//1
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 1, 1, 1, 1, 1]
      ],//2
      [
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//3
      [
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 0],
        [0, 1, 1, 0, 1, 1, 0],
        [1, 1, 0, 0, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 1]
      ],//4
      [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//5
      [
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//6
      [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0]
      ],//7
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//8
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 0, 0, 0, 0]
      ],//9
      [
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]
      ]//:
    ];

  var canvas = document.getElementById('canvasDiyBlock');

  if (canvas.getContext) {
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100, W = 1200;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10, 10, 50, 50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height / 20 - 1;
	var timeDiff = getTimeDiff();
    (function () {
      var temp = /(\d)(\d)(\d)(\d)(\d):(\d)(\d):(\d)(\d):(\d)(\d)/.exec(timeDiff);
      //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
	  // 天(万,千,百,十,个) 小时(十,个) 分钟(十，个) 秒(十 个)
      data.push(temp[1], temp[2], temp[3], temp[4], temp[5], 10, temp[6], temp[7], 10, temp[8], temp[9], 10, temp[10], temp[11]);
    })();
	

    /*生成点阵数字*/
    function renderDigit(index, num) {
      for (var i = 0; i < digit[num].length; i++) {
        for (var j = 0; j < digit[num][i].length; j++) {
          if (digit[num][i][j] == 1) {
            cxt.beginPath();
            cxt.arc(14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1), i * 2 * (R + 1) + (R + 1), R, 0, 2 * Math.PI);
            cxt.closePath();
            cxt.fill();
          }
        }
      }
    }

    /*更新时钟*/
    function updateDigitTime() {
      var changeNumArray = [];
	  var timeDiff = getTimeDiff();
      var temp = /(\d)(\d)(\d)(\d)(\d):(\d)(\d):(\d)(\d):(\d)(\d)/.exec(timeDiff);
      var NewData = [];
      NewData.push(temp[1], temp[2], temp[3], temp[4], temp[5], 10, temp[6], temp[7], 10, temp[8], temp[9], 10, temp[10], temp[11]);

      for (var i = data.length - 1; i >= 0; i--) {
        //时间发生变化
        if (NewData[i] !== data[i]) {
          //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
          changeNumArray.push(i + '_' + (Number(data[i]) + 1) % 10);
        }
      }
      //增加小球
      for (var i = 0; i < changeNumArray.length; i++) {
        addBalls.apply(this, changeNumArray[i].split('_'));
      }
      data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls() {
      for (var i = 0; i < balls.length; i++) {
        balls[i].stepY += balls[i].disY;
        balls[i].x += balls[i].stepX;
        balls[i].y += balls[i].stepY;
        if (balls[i].x > W + R || balls[i].y > H + R) {
          balls.splice(i, 1);
          i--;
        }
      }
    }

    /*增加要运动的小球*/
    function addBalls(index, num) {
      var numArray = [1, 2, 3];
      var colorArray = ["#3BE", "#09C", "#A6C", "#93C", "#9C0", "#690", "#FB3", "#F80", "#F44", "#C00"];
      for (var i = 0; i < digit[num].length; i++) {
        for (var j = 0; j < digit[num][i].length; j++) {
          if (digit[num][i][j] == 1) {
            var ball = {
              x: 14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1),
              y: i * 2 * (R + 1) + (R + 1),
              stepX: Math.floor(Math.random() * 4 - 2),
              stepY: -2 * numArray[Math.floor(Math.random() * numArray.length)],
              color: colorArray[Math.floor(Math.random() * colorArray.length)],
              disY: 1
            };
            balls.push(ball);
          }
        }
      }
    }

    /*渲染*/
    function render() {
      //重置画布宽度，达到清空画布的效果
      canvas.height = 100;
      //渲染时钟
      for (var i = 0; i < data.length; i++) {
        renderDigit(i, data[i]);
      }
      //渲染小球
      for (var i = 0; i < balls.length; i++) {
        cxt.beginPath();
        cxt.arc(balls[i].x, balls[i].y, R, 0, 2 * Math.PI);
        cxt.fillStyle = balls[i].color;
        cxt.closePath();
        cxt.fill();
      }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function () {
      //更新时钟
      updateDigitTime();
      //更新小球状态
      updateBalls();
      //渲染
      render();
    }, 50);
  }
})();
</script>

          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjEzNC8xMjY2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/boy.jpg"
                alt="袤锅" />
            
              <p class="site-author-name" itemprop="name">袤锅</p>
              <p class="site-description motion-element" itemprop="description">我尽我力，我尽我心</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/damaoguo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:tianmao818@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" title="Hexo个性化设置" target="_blank">Hexo个性化设置</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、计算机网络"><span class="nav-number">1.</span> <span class="nav-text">一、计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-OSI、TCP-IP、五层体系结构联系与区别？"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.OSI、TCP/IP、五层体系结构联系与区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-说一说TCP-IP协议簇？"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.说一说TCP/IP协议簇？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-TCP三次握手的过程？"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.TCP三次握手的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-TCP四次挥手的过程？"><span class="nav-number">1.0.4.</span> <span class="nav-text">4.TCP四次挥手的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-TCP在三次握手的过程中是如何超时重传的？"><span class="nav-number">1.0.5.</span> <span class="nav-text">5.TCP在三次握手的过程中是如何超时重传的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-为什么要三次握手，四次挥手？"><span class="nav-number">1.0.6.</span> <span class="nav-text">6.为什么要三次握手，四次挥手？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-在浏览器地址栏输入一个url到浏览器返回页面的过程？"><span class="nav-number">1.0.7.</span> <span class="nav-text">7.在浏览器地址栏输入一个url到浏览器返回页面的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-说一说在三次握手的时候可能存在的安全问题？"><span class="nav-number">1.0.8.</span> <span class="nav-text">8.说一说在三次握手的时候可能存在的安全问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-域名解析"><span class="nav-number">1.0.9.</span> <span class="nav-text">9.域名解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-TCP是如何保证可靠传输的？-分编校丢流拥重超"><span class="nav-number">1.0.10.</span> <span class="nav-text">10.TCP是如何保证可靠传输的？(分编校丢流拥重超)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-TCP和UDP之间的区别？-面头流速可有界"><span class="nav-number">1.0.11.</span> <span class="nav-text">11.TCP和UDP之间的区别？(面头流速可有界)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-post和get的区别？"><span class="nav-number">1.0.12.</span> <span class="nav-text">12.post和get的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-在TCP和UDP之上都有哪些应用层的协议？"><span class="nav-number">1.0.13.</span> <span class="nav-text">13.在TCP和UDP之上都有哪些应用层的协议？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-HTTPS握手的过程？"><span class="nav-number">1.0.14.</span> <span class="nav-text">14.HTTPS握手的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-TCP头部，UDP头部比较？"><span class="nav-number">1.0.15.</span> <span class="nav-text">15.TCP头部，UDP头部比较？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-IP头部"><span class="nav-number">1.0.16.</span> <span class="nav-text">16.IP头部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-HTTP请求，HTTP响应，字段？"><span class="nav-number">1.0.17.</span> <span class="nav-text">17.HTTP请求，HTTP响应，字段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-HTTP1-0，HTTP1-1，HTTP2-0之间的区别？"><span class="nav-number">1.0.18.</span> <span class="nav-text">18.HTTP1.0，HTTP1.1，HTTP2.0之间的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-cookie和session的区别？"><span class="nav-number">1.0.19.</span> <span class="nav-text">19.cookie和session的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-状态码？"><span class="nav-number">1.0.20.</span> <span class="nav-text">20.状态码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-TCP是如何实现面向连接的？面向连接和非面向连接的区别？"><span class="nav-number">1.0.21.</span> <span class="nav-text">21.TCP是如何实现面向连接的？面向连接和非面向连接的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-TCP的拥塞控制？（重传就可能导致拥塞）"><span class="nav-number">1.0.22.</span> <span class="nav-text">22.TCP的拥塞控制？（重传就可能导致拥塞）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-TCP的流量控制？"><span class="nav-number">1.0.23.</span> <span class="nav-text">23.TCP的流量控制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-重传算法？"><span class="nav-number">1.0.24.</span> <span class="nav-text">24.重传算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-路由算法？"><span class="nav-number">1.0.25.</span> <span class="nav-text">25.路由算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-IP数据报格式？"><span class="nav-number">1.0.26.</span> <span class="nav-text">26.IP数据报格式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-ABC类地址"><span class="nav-number">1.0.27.</span> <span class="nav-text">27.ABC类地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-端口号"><span class="nav-number">1.0.28.</span> <span class="nav-text">28.端口号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-滑动窗口（解决的是速率不匹配问题）"><span class="nav-number">1.0.29.</span> <span class="nav-text">29.滑动窗口（解决的是速率不匹配问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-拥塞窗口（控制的是发送方）"><span class="nav-number">1.0.30.</span> <span class="nav-text">30.拥塞窗口（控制的是发送方）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-细节"><span class="nav-number">1.0.31.</span> <span class="nav-text">31.细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-HTTP和HTTPS的区别？"><span class="nav-number">1.0.32.</span> <span class="nav-text">32.HTTP和HTTPS的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-同源策略？"><span class="nav-number">1.0.33.</span> <span class="nav-text">33.同源策略？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-跨域问题？"><span class="nav-number">1.0.34.</span> <span class="nav-text">34.跨域问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-websocket和SSE的区别？"><span class="nav-number">1.0.35.</span> <span class="nav-text">35. websocket和SSE的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-epoll"><span class="nav-number">1.0.36.</span> <span class="nav-text">36. epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-cacheline，MESI"><span class="nav-number">1.0.37.</span> <span class="nav-text">37. cacheline，MESI</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、操作系统"><span class="nav-number">2.</span> <span class="nav-text">二、操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（一）基础"><span class="nav-number">2.1.</span> <span class="nav-text">（一）基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-原码、补码、反码"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.原码、补码、反码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-fork函数"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.fork函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（二）并发"><span class="nav-number">2.2.</span> <span class="nav-text">（二）并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-进程、线程、管程、协程？"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.进程、线程、管程、协程？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）线程和进程-Thread-amp-Process"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">（1）线程和进程(Thread &amp; Process)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）线程的属性"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">（2）线程的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）管程"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">（3）管程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）协程"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">（4）协程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-进程之间的通信？（套共消，管信信）"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.进程之间的通信？（套共消，管信信）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#P操作"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">P操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#V操作"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">V操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-信号和信号量之间的区别？"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.信号和信号量之间的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-线程之间的通信？"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.线程之间的通信？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-死锁产生的条件？"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.死锁产生的条件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-死锁的解除和预防的方法？"><span class="nav-number">2.2.6.</span> <span class="nav-text">6.死锁的解除和预防的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-调度"><span class="nav-number">2.2.7.</span> <span class="nav-text">7.调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-锁，死锁怎么检查？"><span class="nav-number">2.2.8.</span> <span class="nav-text">8.锁，死锁怎么检查？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-CAS"><span class="nav-number">2.2.9.</span> <span class="nav-text">9.CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-临界区"><span class="nav-number">2.2.10.</span> <span class="nav-text">10.临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-yield方法，join方法"><span class="nav-number">2.2.11.</span> <span class="nav-text">11.yield方法，join方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-一般在什么时候使用volatile？"><span class="nav-number">2.2.12.</span> <span class="nav-text">12.一般在什么时候使用volatile？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-Linux内核select-poll-epoll？"><span class="nav-number">2.2.13.</span> <span class="nav-text">13.Linux内核select poll epoll？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-周转时间"><span class="nav-number">2.2.14.</span> <span class="nav-text">14.周转时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-响应比"><span class="nav-number">2.2.15.</span> <span class="nav-text">15.响应比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-fork函数"><span class="nav-number">2.2.16.</span> <span class="nav-text">16. fork函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-上下文切换"><span class="nav-number">2.2.17.</span> <span class="nav-text">17. 上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-进程切换"><span class="nav-number">2.2.18.</span> <span class="nav-text">18. 进程切换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（三）内存管理"><span class="nav-number">2.3.</span> <span class="nav-text">（三）内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-页面置换算法"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.页面置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-内存分页"><span class="nav-number">2.3.2.</span> <span class="nav-text">2. 内存分页</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（四）I-O"><span class="nav-number">2.4.</span> <span class="nav-text">（四）I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-I-O模式？参考"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.I/O模式？参考</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）阻塞I-O（blocking-IO）"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">（1）阻塞I/O（blocking IO）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）非阻塞I-O（nonblocking-IO）"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">（2）非阻塞I/O（nonblocking IO）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）I-O多路复用（-IO-multiplexing）"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">（3）I/O多路复用（ IO multiplexing）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）信号驱动I-O（-signal-driven-IO）"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">（4）信号驱动I/O（ signal driven IO）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）异步I-O（asynchronous-IO）"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">（5）异步I/O（asynchronous IO）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-零拷贝zero-copy"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.零拷贝zero-copy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-用户空间和内核空间"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">2.1 用户空间和内核空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-DMA技术"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">2.2 DMA技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-传统文件传输有多糟糕？"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">2.3 传统文件传输有多糟糕？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-零拷贝—-mmap-write"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">2.4 零拷贝—-mmap+write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-零拷贝—-sendfile"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">2.5 零拷贝—-sendfile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-零拷贝—-SG-DMA"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">2.6 零拷贝—-SG-DMA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-Netty的零拷贝实现？"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">2.7 Netty的零拷贝实现？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-同步异步，阻塞非阻塞的区别。"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.同步异步，阻塞非阻塞的区别。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）阻塞，非阻塞指的有无返回值"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">（1）阻塞，非阻塞指的有无返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）同步异步指的是能否继续执行"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">（2）同步异步指的是能否继续执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（五）linux使用"><span class="nav-number">2.5.</span> <span class="nav-text">（五）linux使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-CPU占用过高排查"><span class="nav-number">2.5.1.</span> <span class="nav-text">1.CPU占用过高排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-补充"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.补充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-命令"><span class="nav-number">2.5.3.</span> <span class="nav-text">3.命令?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、数据结构"><span class="nav-number">3.</span> <span class="nav-text">三、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-B-树，B-树？"><span class="nav-number">3.1.</span> <span class="nav-text">1.B-树，B+树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-二叉树的遍历，非递归？"><span class="nav-number">3.2.</span> <span class="nav-text">2.二叉树的遍历，非递归？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-循环队列？"><span class="nav-number">3.3.</span> <span class="nav-text">3.循环队列？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Trie-Tree（208-Implement-Trie-Prefix-Tree-）"><span class="nav-number">3.4.</span> <span class="nav-text">4.Trie Tree（208. Implement Trie (Prefix Tree)）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-树，图节点以及度数相关？"><span class="nav-number">3.5.</span> <span class="nav-text">5.树，图节点以及度数相关？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、算法"><span class="nav-number">4.</span> <span class="nav-text">四、算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-算法的分类？"><span class="nav-number">4.1.</span> <span class="nav-text">1.算法的分类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-弗洛伊德算法？"><span class="nav-number">4.2.</span> <span class="nav-text">2.弗洛伊德算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-迪杰斯特拉算法？"><span class="nav-number">4.3.</span> <span class="nav-text">3.迪杰斯特拉算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-二分法？（边界问题）"><span class="nav-number">4.4.</span> <span class="nav-text">4.二分法？（边界问题）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-排序算法"><span class="nav-number">4.5.</span> <span class="nav-text">5.排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）堆排序"><span class="nav-number">4.5.1.</span> <span class="nav-text">（1）堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）归并排序"><span class="nav-number">4.5.2.</span> <span class="nav-text">（2）归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）快速排序"><span class="nav-number">4.5.3.</span> <span class="nav-text">（3）快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-LRU算法？"><span class="nav-number">4.6.</span> <span class="nav-text">6.LRU算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-洗牌算法？"><span class="nav-number">4.7.</span> <span class="nav-text">7.洗牌算法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-朋友圈LeetCode547"><span class="nav-number">4.8.</span> <span class="nav-text">8.朋友圈LeetCode547?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-卡特兰数"><span class="nav-number">4.9.</span> <span class="nav-text">9.卡特兰数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-排序算法"><span class="nav-number">4.10.</span> <span class="nav-text">10.排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-树"><span class="nav-number">4.11.</span> <span class="nav-text">11. 树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树"><span class="nav-number">4.11.1.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashmap"><span class="nav-number">4.11.2.</span> <span class="nav-text">hashmap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-链表"><span class="nav-number">4.12.</span> <span class="nav-text">12.链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-回溯算法"><span class="nav-number">4.13.</span> <span class="nav-text">13.回溯算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-递推算法"><span class="nav-number">4.14.</span> <span class="nav-text">14.递推算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-背包问题"><span class="nav-number">4.15.</span> <span class="nav-text">15. 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-贪心算法"><span class="nav-number">4.16.</span> <span class="nav-text">16.贪心算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-编辑距离"><span class="nav-number">4.17.</span> <span class="nav-text">17.编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-dfs"><span class="nav-number">4.18.</span> <span class="nav-text">18.dfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-两个str-最大公共子序列和子串？"><span class="nav-number">4.19.</span> <span class="nav-text">19.两个str 最大公共子序列和子串？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>


<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">袤锅</span>

  

  
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>




  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>





        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  


  
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
