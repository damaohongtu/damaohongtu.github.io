<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="2aen8txJ9makMaGgtEKHpowVyKdkJYiySE3ojNCZAwU" />





  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java总结-2">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结-2">
<meta property="og:url" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/index.html">
<meta property="og:site_name" content="大袤宏图&#39;s Blog">
<meta property="og:description" content="Java总结-2">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/fanxing.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/fanxing2.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/StringBuffer.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/exception.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/StackOverflowError.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/JavaHeapSpace.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/GCoverheadlimitexceeded.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/DirectBufferMemory.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/UnableToCreateNewNativeThread.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/collection.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist1.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist2.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist3.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/tableSizeFor.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/node.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/TreeNode.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/concurrenthashmap.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist0.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/linkedlist.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/linkedlist1.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/multithread/2start.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/architecture.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/execute.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/locks.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/juc-collections.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/future.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/futuretask_state.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/juc.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/copyonwrite.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/concurrent.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/blocking.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/CopyOnWriteArrayList.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/CopyOnWriteArraySet.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/cas.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/ArrayBlockingQueue.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/ConcurrentLinkedQueue.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/home/mao/workspace/%E9%9D%A2%E8%AF%95/JavaGuide/JavaInterview/images/juc/concurrenthashmap.png">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/home/mao/workspace/%E9%9D%A2%E8%AF%95/JavaGuide/JavaInterview/images/juc/concurrenthashmap_1.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/synchronized-usage.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/entrylist_waitset.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/Synchronization.gif">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/synchronized.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/unsafe.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/FutureTask.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/并发队列.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/heap.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/jmm-and-memory.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/shuangqinweipai.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/gc-hotspot.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/gc-from-to.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/gc.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/serial.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/parnew.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/cms.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/jmm.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/overview-selectors.png">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/scatter.png">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/gather.png">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_read_1.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_read_2.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_write_1.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_write_2.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/nio_copy.png?lastModify=1574234543">
<meta property="og:image" content="https://damaohongtu.github.io/2019/11/20/Java总结-2/rpc-design.jpeg">
<meta property="og:updated_time" content="2022-05-15T09:39:56.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结-2">
<meta name="twitter:description" content="Java总结-2">
<meta name="twitter:image" content="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/fanxing.png?lastModify=1574234543">






  <link rel="canonical" href="https://damaohongtu.github.io/2019/11/20/Java总结-2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java总结-2 | 大袤宏图's Blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ea8bf9b92c205ae2c147d91b5242a6b0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/damaoguo/damaoguo.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大袤宏图's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">
    <a href="/navigation/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />导航</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://damaohongtu.github.io/2019/11/20/Java总结-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大袤宏图">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/boy.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大袤宏图's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java总结-2
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-20 15:20:53" itemprop="dateCreated datePublished" datetime="2019-11-20T15:20:53+08:00">2019-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-05-15 17:39:56" itemprop="dateModified" datetime="2022-05-15T17:39:56+08:00">2022-05-15</time>
              
            
          </span>

          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Java总结-2</p>
<a id="more"></a>
<h2 id="五、Java"><a href="#五、Java" class="headerlink" title="五、Java"></a>五、Java</h2><h3 id="（一）基础"><a href="#（一）基础" class="headerlink" title="（一）基础"></a>（一）基础</h3><h4 id="0-Java对象"><a href="#0-Java对象" class="headerlink" title="0. Java对象"></a>0. Java对象</h4><h5 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h5><ul>
<li><span style="color:red">markword：（1）锁信息，（2）GC信息，（3）hashcode（Identity HashCode）</span>,怎么标记这个锁是自己持有的？</li>
<li>类型指针class pointer</li>
<li>实例数据instance data</li>
<li>对齐padding</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul>
<li>markword</li>
<li>class pointer</li>
<li>数组长度length（4个字节）</li>
<li>实例数据instance data</li>
<li>对齐 padding</li>
</ul>
<h4 id="1-泛型？"><a href="#1-泛型？" class="headerlink" title="1.泛型？"></a>1.泛型？</h4><ul>
<li><p>泛型是如何实现的?</p>
<p>泛型是通过类型擦除实现的。</p>
</li>
<li><p>什么是泛型中的限定通配符和非限定通配符 ?</p>
<p>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是&lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面&lt;?&gt;表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。</p>
</li>
<li><p>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</p>
<p>List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<integer>或List<float></float></integer></p>
</li>
<li><p>可以把List<string>传递给一个接受List<object>参数的方法吗？</object></string></p>
<p>编译错误。</p>
</li>
<li><p>补充（List<object>并不是ArrayList<string>的父类）</string></object></p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/fanxing.png?lastModify=1574234543" alt="img"></p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/fanxing2.png?lastModify=1574234543" alt="img"></p>
</li>
</ul>
<h4 id="2-内部类？（成局静匿）"><a href="#2-内部类？（成局静匿）" class="headerlink" title="2.内部类？（成局静匿）"></a>2.内部类？（成局静匿）</h4><p>（1）成员内部类</p>
<blockquote>
<p>一个类定义在一个类的内部，看起来像类的成员。</p>
<blockquote>
<p>问题：</p>
<ul>
<li>有隐藏的问题</li>
<li>访问：成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问</li>
</ul>
</blockquote>
</blockquote>
<p>（2）局部内部类</p>
<blockquote>
<p>定义在方法或者是一个作用域内，和成员内部类的区别在于访问权限上。</p>
<blockquote>
<p>问题：</p>
<ul>
<li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</li>
<li>是不能有 public、protected、private 以及 static 修饰符的。</li>
</ul>
</blockquote>
</blockquote>
<p>（3）静态内部类</p>
<blockquote>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，<code>并且它不能使用外部类的非static成员变量或者方法</code></p>
<blockquote>
<ul>
<li>静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。</li>
</ul>
</blockquote>
</blockquote>
<p>（4）匿名内部类</p>
<blockquote>
<p>一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。</p>
</blockquote>
<h4 id="3-构造器能不能override？"><a href="#3-构造器能不能override？" class="headerlink" title="3.构造器能不能override？"></a>3.构造器能不能override？</h4><p>不可以，可以重载，不可以重写，理由：父类的私有属性以及构造器不能够被重载。</p>
<h4 id="4-String，StringBulider，StringBuffer？"><a href="#4-String，StringBulider，StringBuffer？" class="headerlink" title="4.String，StringBulider，StringBuffer？"></a>4.String，StringBulider，StringBuffer？</h4><p>对方法或者被调用的方法加了同步锁。</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/StringBuffer.png?lastModify=1574234543" alt="img"></p>
<ul>
<li>String的基本特征，不可变类，声明为final类，当然使用类反射是可以更改的，一般用在常量申明</li>
<li>StringBuffer与StringBuilder<ul>
<li>内存不够，将原来的复制过来</li>
</ul>
</li>
</ul>
<h4 id="5-static相关？-类，方法，属性，代码块"><a href="#5-static相关？-类，方法，属性，代码块" class="headerlink" title="5.static相关？(类，方法，属性，代码块)"></a>5.static相关？(类，方法，属性，代码块)</h4><blockquote>
<p>（目的：方便在没有new的情况下使用方法和属性）</p>
<p>（1）修饰？</p>
<ul>
<li>类</li>
<li>方法：是没有this的，因为它不依附于任何对象，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。非静态成员方法中是可以访问静态成员方法/变量的。</li>
<li>属性：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>代码块：用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li>
</ul>
<p>（2）特点</p>
<ul>
<li>在static方法内部不能调用非静态方法。</li>
<li>例题：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> StaticTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> static使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * test static</span></span><br><span class="line"><span class="comment"> * myclass static</span></span><br><span class="line"><span class="comment"> * person static</span></span><br><span class="line"><span class="comment"> * person Test</span></span><br><span class="line"><span class="comment"> * test constructor</span></span><br><span class="line"><span class="comment"> * person MyClass</span></span><br><span class="line"><span class="comment"> * myclass constructor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 下午8:23 2019/8/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StaticTest已经加载过了</span></span><br><span class="line"><span class="comment">//而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="comment">//（3）被加载</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span>  </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//（1）首先被加载</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//（2）被执行</span></span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-接口和抽象类的区别？"><a href="#6-接口和抽象类的区别？" class="headerlink" title="6.接口和抽象类的区别？"></a>6.接口和抽象类的区别？</h4><blockquote>
<p>（1）接口？</p>
<ul>
<li>一个类可以实现多个接口。</li>
<li>接口中除了static、final变量，<strong>不能有其他变量</strong>，</li>
<li>不能够有方法的实现，java 8开始支持default。</li>
<li>接口默认是：public的</li>
<li>从设计上讲：抽象是对类的抽象</li>
</ul>
<p>（2）抽象类？</p>
<ul>
<li>一个类只能继承一个抽象类。</li>
<li>抽象类中可以有属性以及方法的实现。</li>
<li>从设计上讲：是对行为的抽象。</li>
<li>抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）</li>
</ul>
</blockquote>
<h4 id="7-equals和hashcode？"><a href="#7-equals和hashcode？" class="headerlink" title="7.equals和hashcode？"></a>7.equals和hashcode？</h4><blockquote>
<ul>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong>（默认使用的地址来计算，不重写hashcode很可能不一样）</li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
</blockquote>
<h4 id="8-Throwable类？"><a href="#8-Throwable类？" class="headerlink" title="8.Throwable类？"></a>8.Throwable类？</h4><h5 id="（1）结构？"><a href="#（1）结构？" class="headerlink" title="（1）结构？"></a>（1）结构？</h5><blockquote>
<p>java.lang</p>
<h2 id="Class-Throwable"><a href="#Class-Throwable" class="headerlink" title="Class Throwable"></a>Class Throwable</h2><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" target="_blank" rel="noopener">java.lang.Object</a></li>
<li><ul>
<li>java.lang.Throwable</li>
</ul>
</li>
<li><ul>
<li>All Implemented Interfaces:</li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html" target="_blank" rel="noopener">Serializable</a></p>
</li>
<li><p>Direct Known Subclasses:</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html" target="_blank" rel="noopener">Error</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" target="_blank" rel="noopener">Exception</a></p>
</li>
</ul>
<blockquote>
<p><strong>常用的方法：getMessage，printStackTrace</strong></p>
<ul>
<li><strong>public string  getMessage()</strong>:返回异常发生时的详细信息</li>
<li><strong>public string toString()</strong>:返回异常发生时的简要描述</li>
<li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li>
<li><strong>public void printStackTrace()</strong>:在控制台上打印Throwable对象封装的异常信息</li>
</ul>
</blockquote>
</blockquote>
<h5 id="（2）常见的异常和错误？"><a href="#（2）常见的异常和错误？" class="headerlink" title="（2）常见的异常和错误？"></a>（2）常见的异常和错误？</h5><ul>
<li><p>异常（可检查的，不可检查的（运行时运行））</p>
<ul>
<li>ArithmeticException</li>
<li>IndexOutOfBoundsException</li>
<li>RuntimeException（在运行的时候抛出）</li>
<li>NullPointerException</li>
<li>原则：<ul>
<li>尽量捕获特定的异常</li>
<li>不要生吞异常</li>
<li>只捕获必要的代码段</li>
<li>不要使用异常处理块控制代码的流程</li>
</ul>
</li>
<li>throw抛出异常</li>
<li>throws</li>
<li>try  with语法糖，自动关闭资源，（类比Python中的</li>
</ul>
<p>| 编号 | 类型                                                         | 代表                                   |<br>| :—- | :—————————————————————————————- | :——————————————————- |<br>| 1    | 检查型（在函数的声明上必须添加throws）（不是RuntimeException的派生类） | IOException，SQLException              |<br>| 2    | 非检查型（是RuntimeException的派生类）                       | NullPointException，ClassCastException |</p>
</li>
</ul>
<ul>
<li><p>错误（Linkage Error，virtual machine Error）</p>
<ul>
<li>OutOfMemoryError</li>
<li>StackOverflowError</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>编号</strong></th>
<th style="text-align:left"><strong>异常Exception</strong></th>
<th style="text-align:left"><strong>错误Error</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ArithmeticException.html" target="_blank" rel="noopener">ArithmeticException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AbstractMethodError.html" target="_blank" rel="noopener">AbstractMethodError</a></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ArrayIndexOutOfBoundsException.html" target="_blank" rel="noopener">ArrayIndexOutOfBoundsException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AssertionError.html" target="_blank" rel="noopener">AssertionError</a></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ArrayStoreException.html" target="_blank" rel="noopener">ArrayStoreException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/BootstrapMethodError.html" target="_blank" rel="noopener">BootstrapMethodError</a></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassCastException.html" target="_blank" rel="noopener">ClassCastException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassCircularityError.html" target="_blank" rel="noopener">ClassCircularityError</a></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassNotFoundException.html" target="_blank" rel="noopener">ClassNotFoundException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassFormatError.html" target="_blank" rel="noopener">ClassFormatError</a></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/CloneNotSupportedException.html" target="_blank" rel="noopener">CloneNotSupportedException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html" target="_blank" rel="noopener">Error</a></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/EnumConstantNotPresentException.html" target="_blank" rel="noopener">EnumConstantNotPresentException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ExceptionInInitializerError.html" target="_blank" rel="noopener">ExceptionInInitializerError</a></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html" target="_blank" rel="noopener">Exception</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalAccessError.html" target="_blank" rel="noopener">IllegalAccessError</a></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalAccessException.html" target="_blank" rel="noopener">IllegalAccessException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IncompatibleClassChangeError.html" target="_blank" rel="noopener">IncompatibleClassChangeError</a></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html" target="_blank" rel="noopener">IllegalArgumentException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InstantiationError.html" target="_blank" rel="noopener">InstantiationError</a></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html" target="_blank" rel="noopener">IllegalMonitorStateException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InternalError.html" target="_blank" rel="noopener">InternalError</a></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html" target="_blank" rel="noopener">IllegalStateException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/LinkageError.html" target="_blank" rel="noopener">LinkageError</a></td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalThreadStateException.html" target="_blank" rel="noopener">IllegalThreadStateException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoClassDefFoundError.html" target="_blank" rel="noopener">NoClassDefFoundError</a></td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html" target="_blank" rel="noopener">IndexOutOfBoundsException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchFieldError.html" target="_blank" rel="noopener">NoSuchFieldError</a></td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InstantiationException.html" target="_blank" rel="noopener">InstantiationException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchMethodError.html" target="_blank" rel="noopener">NoSuchMethodError</a></td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html" target="_blank" rel="noopener">InterruptedException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/OutOfMemoryError.html" target="_blank" rel="noopener">OutOfMemoryError</a></td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NegativeArraySizeException.html" target="_blank" rel="noopener">NegativeArraySizeException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StackOverflowError.html" target="_blank" rel="noopener">StackOverflowError</a></td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchFieldException.html" target="_blank" rel="noopener">NoSuchFieldException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadDeath.html" target="_blank" rel="noopener">ThreadDeath</a></td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchMethodException.html" target="_blank" rel="noopener">NoSuchMethodException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnknownError.html" target="_blank" rel="noopener">UnknownError</a></td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html" target="_blank" rel="noopener">NullPointerException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsatisfiedLinkError.html" target="_blank" rel="noopener">UnsatisfiedLinkError</a></td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NumberFormatException.html" target="_blank" rel="noopener">NumberFormatException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedClassVersionError.html" target="_blank" rel="noopener">UnsupportedClassVersionError</a></td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ReflectiveOperationException.html" target="_blank" rel="noopener">ReflectiveOperationException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/VerifyError.html" target="_blank" rel="noopener">VerifyError</a></td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html" target="_blank" rel="noopener">RuntimeException</a></td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/VirtualMachineError.html" target="_blank" rel="noopener">VirtualMachineError</a></td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityException.html" target="_blank" rel="noopener">SecurityException</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringIndexOutOfBoundsException.html" target="_blank" rel="noopener">StringIndexOutOfBoundsException</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/TypeNotPresentException.html" target="_blank" rel="noopener">TypeNotPresentException</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html" target="_blank" rel="noopener">UnsupportedOperationException</a></td>
</tr>
</tbody>
</table>
</div>
<h5 id="（3）Throw和Throws的区别？"><a href="#（3）Throw和Throws的区别？" class="headerlink" title="（3）Throw和Throws的区别？"></a>（3）Throw和Throws的区别？</h5><blockquote>
<ul>
<li>Throw用于方法内部，Throws用于方法声明上</li>
<li>Throw后跟异常对象，Throws后跟异常类型</li>
<li>Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型</li>
</ul>
</blockquote>
<h5 id="（4）异常是怎么实现的？"><a href="#（4）异常是怎么实现的？" class="headerlink" title="（4）异常是怎么实现的？"></a>（4）异常是怎么实现的？</h5><blockquote>
<p>在编译器生成的字节码中，每一个方法都附有一个异常表（Exception Table），由四部分构成：</p>
<ul>
<li>from指针：指示了该异常处理器所监控的范围</li>
<li>to指针：指示了该异常处理器所监控的范围</li>
<li>target指针：指向异常处理器的起始位置</li>
<li>捕获的异常类型</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void test()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int a=1/0;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;finally &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/exception.png?lastModify=1574234543" alt="img"></p>
<h4 id="9-OutOfMemory详解"><a href="#9-OutOfMemory详解" class="headerlink" title="9. OutOfMemory详解"></a>9. OutOfMemory详解</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">图片</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Exception in thread “main” java.lang.StackOverflowError</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/StackOverflowError.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">递归调用，深度太深</td>
</tr>
<tr>
<td style="text-align:left">Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/JavaHeapSpace.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">堆空间不够（）</td>
</tr>
<tr>
<td style="text-align:left">java.lang.OutOfMemoryError: GC overhead limit exceeded</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/GCoverheadlimitexceeded.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">垃圾回收事倍功半，GC直接罢工</td>
</tr>
<tr>
<td style="text-align:left">Exception in thread “main” java.lang.OutOfMemoryError: Direct buffer memory</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/DirectBufferMemory.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">nio分配直接内存，不够导致</td>
</tr>
<tr>
<td style="text-align:left">Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/UnableToCreateNewNativeThread.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">同一个进程创建的线程太多了，Linux默认限制为1024个。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>方法区溢出（方法区又被称作永久代）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//intern作用是把首次遇到的字符串实例复制到永久代去，返回的也是永久代中这个字符串实例的引用。</span></span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-Collections和Arrays常见的方法？"><a href="#10-Collections和Arrays常见的方法？" class="headerlink" title="10.Collections和Arrays常见的方法？"></a>10.Collections和Arrays常见的方法？</h4><p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/Arrays,CollectionsCommonMethods.md" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/Arrays,CollectionsCommonMethods.md</a></p>
<h4 id="11-反射"><a href="#11-反射" class="headerlink" title="11.反射"></a>11.反射</h4><blockquote>
<p><strong>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">用途</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Class类</td>
<td style="text-align:left">代表类的实体，在运行的Java应用程序中表示类和接口</td>
<td style="text-align:left">//第1种方式获取Class对象 ：通过实例对象getClass()<br>Person p1=new Person(); <br>Class clazz1=p1.getClass(); <br> //第2种方式获取Class对象:类名.class <br>Class clazz2=Person.class; <br> //第3种方式获取Class对象 Class :全类名<br>clazz3=Class.forName(“JavaDemo.VMTest.ReflectDemo.Person”);</td>
</tr>
<tr>
<td style="text-align:left">Field类</td>
<td style="text-align:left">代表类的成员变量（成员变量也称为类的属性）</td>
<td style="text-align:left">Field field2=clazz.getDeclaredField(“idcard”); <br>field2.setAccessible(true); <br>field2.set(obj, “123456”);</td>
</tr>
<tr>
<td style="text-align:left">Method类</td>
<td style="text-align:left">代表类的方法</td>
<td style="text-align:left">Method m2=clazz.getDeclaredMethod(“show”,String.class); <br>m2.setAccessible(true);<br>m2.invoke(obj,”smt”);</td>
</tr>
<tr>
<td style="text-align:left">Constructor类</td>
<td style="text-align:left">代表类的构造方法</td>
<td style="text-align:left">//获取私有构造方法 <br>Constructor cc3=clazz.getDeclaredConstructor(int.class);<br> //暴力访问 <br>cc3.setAccessible(true); <br>Object oo3=cc3.newInstance(1);</td>
</tr>
</tbody>
</table>
</div>
<h4 id="如何使用反射"><a href="#如何使用反射" class="headerlink" title="如何使用反射"></a><strong>如何使用反射</strong></h4><p>(1)使用Class类,获取出被解剖的这个类的class文件对象  (2) 使用Class类方法,获取出类中的所有成员  (3) 将成员获取出来后,交给对应类,对应类中的方法,运行成员</p>
<blockquote>
<p>如何获取,class文件对象</p>
<blockquote>
<p>使用类的对象获取</p>
<ul>
<li>每个类都使用Object作为父类,Object类方法 getClass()返回这个类的class文件对象,方法返回值Class类型对象</li>
<li>使用类的静态属性获取:类名.class 返回这个类的class文件对象.属性运行结果也是Class类型对象(并不是使用的是编译后的字节码class文件！)</li>
<li>使用Class类的静态方法获取:Class类静态方法 forName(String 类名) 传递字符串类名获取到这个类的class文件对象,方法返回值也是Class类型对象 不管用哪种方式获取的Class对象，他们都是相等的。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>如何创建对象</strong></p>
<p>（1）newInstance方法</p>
<p>（2）获取构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Constructor c=clazz.getDeclaredConstructor(String.class,String.class,<span class="keyword">int</span>.class); </span><br><span class="line">&gt; Person p1=(Person) c.newInstance(<span class="string">"李四"</span>,<span class="string">"男"</span>,<span class="number">20</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="12-Object方法"><a href="#12-Object方法" class="headerlink" title="12.Object方法"></a>12.Object方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">１</td>
<td style="text-align:left">getClass</td>
<td style="text-align:left">native方法，用于返回当前对象的Class对象</td>
</tr>
<tr>
<td style="text-align:left">２</td>
<td style="text-align:left">hashCOde</td>
<td style="text-align:left">native方法，用于返回对象的哈希码（将对象的内存地址转换为整数返回）哈希碰撞，hashcode降低了搜索的成本。</td>
</tr>
<tr>
<td style="text-align:left">３</td>
<td style="text-align:left">equals</td>
<td style="text-align:left">用于比较两个对象的地址是否一样</td>
</tr>
<tr>
<td style="text-align:left">４</td>
<td style="text-align:left">clone</td>
<td style="text-align:left">用于返回当前对象的一份拷贝</td>
</tr>
<tr>
<td style="text-align:left">５</td>
<td style="text-align:left">toString</td>
<td style="text-align:left">返回类的名字@实例的哈希编码的十六进制字符串</td>
</tr>
<tr>
<td style="text-align:left">６</td>
<td style="text-align:left">notify</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">７</td>
<td style="text-align:left">notifyAll</td>
<td style="text-align:left">唤醒监视线程</td>
</tr>
<tr>
<td style="text-align:left">８</td>
<td style="text-align:left">wait</td>
<td style="text-align:left">native方法，不可以重写，暂停线程的执行</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">finalize</td>
<td style="text-align:left">实例被垃圾回收的时候触发的操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="13-POJO"><a href="#13-POJO" class="headerlink" title="13.POJO"></a>13.POJO</h4><blockquote>
<p>POJO是Plain Ordinary Java Object的缩写，但是它通指没有使用Entity Beans的普通java对象，可以把POJO作为支持业务逻辑的协助类。</p>
</blockquote>
<h4 id="14-hashmap为什么是数组-链表，不是数组-数组"><a href="#14-hashmap为什么是数组-链表，不是数组-数组" class="headerlink" title="14.hashmap为什么是数组+链表，不是数组+数组?"></a>14.hashmap为什么是数组+链表，不是数组+数组?</h4><h4 id="15-数组为什么要连续存放？"><a href="#15-数组为什么要连续存放？" class="headerlink" title="15.数组为什么要连续存放？"></a>15.数组为什么要连续存放？</h4><h4 id="16-包装类和基础类的区别？"><a href="#16-包装类和基础类的区别？" class="headerlink" title="16.包装类和基础类的区别？"></a>16.包装类和基础类的区别？</h4><p>拆箱装箱</p>
<h4 id="17-Java中-try-catch关闭流的语法糖"><a href="#17-Java中-try-catch关闭流的语法糖" class="headerlink" title="17.Java中 try..catch关闭流的语法糖?"></a>17.Java中 try..catch关闭流的语法糖?</h4><h4 id="18-final，finally，finalize？"><a href="#18-final，finally，finalize？" class="headerlink" title="18.final，finally，finalize？"></a>18.final，finally，finalize？</h4><blockquote>
<ul>
<li>final修饰类，方法，变量，为什么要final？不想被修改。</li>
<li>finally：出现异常的时候，重要的代码会被执行（比如关闭数据库连接池）</li>
<li>finalize：定义在Object类中，垃圾回收之前调用，在对象回收以前释放资源，没一个对象的finalize方法只会被执行一次，在Java9中已经抛弃了，缺陷：不能保证GC马上执行。finalize执行的流程：在GC的时候判断有没有覆盖finalize，实现了的话就会加入F-QUEUE队列，再次判断reachable是否复活还是回收。进入队列等待低优先级的线程来处理，所以并不一定会被回收。</li>
</ul>
</blockquote>
<h4 id="19-面向对象的原则"><a href="#19-面向对象的原则" class="headerlink" title="19.面向对象的原则"></a>19.面向对象的原则</h4><blockquote>
<ul>
<li>单一职责原则（Single Responsibility Principle）每一个类应该专注于做一件事情。</li>
<li>里氏替换原则（Liskov Substitution Principle）超类存在的地方，子类是可以替换的。</li>
<li>依赖倒置原则（Dependence Inversion Principle）实现尽量依赖抽象，不依赖具体实现。</li>
<li>接口隔离原则（Interface Segregation Principle）应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</li>
<li>迪米特法则（Law Of Demeter）又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</li>
<li>开闭原则（Open Close Principle）面向扩展开放，面向修改关闭。</li>
<li>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。 </li>
</ul>
</blockquote>
<h4 id="20-多态相关"><a href="#20-多态相关" class="headerlink" title="20.多态相关"></a>20.多态相关</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">下列代码的输出结果是：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">    String name=<span class="string">"a"</span>; </span><br><span class="line">    <span class="function">String <span class="title">go</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"- function in A"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">        String name=<span class="string">"b"</span>; </span><br><span class="line">        <span class="function">String <span class="title">go</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"- function in B"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        A a= <span class="keyword">new</span> B(); </span><br><span class="line">        System.out.println(a.name+a.go()); </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a - function in B</p>
<p>1、属性不存在重写，只有方法(非私有方法、非静态方法、非final方法) 才存在重写，才能发生多态； </p>
<p>2、向上转型 </p>
</blockquote>
<h4 id="21-字符串编码的区别？"><a href="#21-字符串编码的区别？" class="headerlink" title="21.字符串编码的区别？"></a>21.字符串编码的区别？</h4><h4 id="22-Math-floor-Math-ceil-Math-round"><a href="#22-Math-floor-Math-ceil-Math-round" class="headerlink" title="22.Math.floor, Math.ceil,Math.round?"></a>22.Math.floor, Math.ceil,Math.round?</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Math.floor</td>
<td style="text-align:left">小于等于自身(向下取整)</td>
<td style="text-align:left">Math.floor(-11.5)=-12.0<br>Math.floor(11.5)=11.0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Math.ceil</td>
<td style="text-align:left">大于等于自身(向上取整)</td>
<td style="text-align:left">Math.ceil(-11.5)=-11.0<br>Math.ceil(11.5)=12.0</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Math.round</td>
<td style="text-align:left">加0.5向下取整</td>
<td style="text-align:left">Math.round(-11.4)=-11<br>Math.round(-11.6)=-12</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ceil  英语含义是天花板</li>
<li>floor英语含义是地板</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------ceil------------</span><br><span class="line">        </span><br><span class="line">         数字</span><br><span class="line"></span><br><span class="line">---------floor-----------</span><br></pre></td></tr></table></figure>
<h4 id="23-修饰范围"><a href="#23-修饰范围" class="headerlink" title="23.修饰范围"></a>23.修饰范围</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">关键字</th>
<th style="text-align:left">修饰位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">static（不想新建对象使用）</td>
<td style="text-align:left">类，方法，属性，代码块（执行一次）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">final（不想被修改）</td>
<td style="text-align:left">类，方法，变量</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">synchronized</td>
<td style="text-align:left">方法，代码块(锁定一个对象)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="24-equals和hashcode"><a href="#24-equals和hashcode" class="headerlink" title="24. equals和hashcode"></a>24. equals和hashcode</h4><ul>
<li><strong>如果两个对象相等，那么它们的hashCode()值一定相同。</strong>这里的相等是指，通过equals()比较两个对象时返回true。</li>
<li><strong>如果两个对象hashCode()相等，它们并不一定相等</strong></li>
</ul>
<h3 id="（二）容器"><a href="#（二）容器" class="headerlink" title="（二）容器"></a>（二）容器</h3><h4 id="0-整体架构"><a href="#0-整体架构" class="headerlink" title="0.整体架构"></a>0.整体架构</h4><p>图中的绿色的虚线代表实现，绿色实线代表接口之间的继承，蓝色实线代表类之间的继承。</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/collection.png?lastModify=1574234543" alt="img"></p>
<h4 id="1-HashMap？"><a href="#1-HashMap？" class="headerlink" title="1.HashMap？"></a>1.HashMap？</h4><blockquote>
<p>并发场景下如果要保证一种可行的方式是使用 Collections.synchronizedMap()方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>
<p>遍历（四种方式）</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTraversal</span> </span>&#123;</span><br><span class="line">&gt; &gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt; &gt;  Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&gt; &gt;   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">&gt; &gt;      map.put(<span class="string">"key_"</span>+String.valueOf(i),i);</span><br><span class="line">&gt; &gt;   &#125;</span><br><span class="line">&gt; &gt;  <span class="comment">//(1)使用keySet</span></span><br><span class="line">&gt; &gt;   <span class="keyword">for</span> (String key:map.keySet())&#123;</span><br><span class="line">&gt; &gt;      System.out.println(key+<span class="string">":"</span>+map.get(key));</span><br><span class="line">&gt; &gt;   &#125;</span><br><span class="line">&gt; &gt;  </span><br><span class="line">&gt; &gt;   System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">&gt; &gt;  </span><br><span class="line">&gt; &gt;   <span class="comment">//(2)entrySet</span></span><br><span class="line">&gt; &gt;   <span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">&gt; &gt;        System.out.println(entry.getKey()+<span class="string">":"</span>+entry.getValue());</span><br><span class="line">&gt; &gt;      &#125;</span><br><span class="line">&gt; &gt;    </span><br><span class="line">&gt; &gt;      System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">&gt; &gt;      </span><br><span class="line">&gt; &gt;      <span class="comment">//(3)和（2）是一致的</span></span><br><span class="line">&gt; &gt;      Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">&gt; &gt;      <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:entrySet)&#123;</span><br><span class="line">&gt; &gt;          System.out.println(entry.getKey()+<span class="string">":"</span>+entry.getValue());</span><br><span class="line">&gt; &gt;      &#125;</span><br><span class="line">&gt; &gt;    </span><br><span class="line">&gt; &gt;      System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">&gt; &gt;      </span><br><span class="line">&gt; &gt;      <span class="comment">//(4)使用Iterator</span></span><br><span class="line">&gt; &gt;      Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = map.entrySet().iterator();<span class="comment">//上下相同, 这个清晰一些</span></span><br><span class="line">&gt; &gt;      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">&gt; &gt;       Map.Entry&lt;String, Integer&gt; tmp=it.next();</span><br><span class="line">&gt; &gt;          System.out.println(tmp.getKey()+<span class="string">":"</span>+tmp.getValue());</span><br><span class="line">&gt; &gt;      &#125;</span><br><span class="line">&gt; &gt;    </span><br><span class="line">&gt; &gt;    &#125;</span><br><span class="line">&gt; &gt;    &#125;</span><br><span class="line">&gt; &gt;    </span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="2-ArrayList的扩容？（扩容为原来的1-5倍）"><a href="#2-ArrayList的扩容？（扩容为原来的1-5倍）" class="headerlink" title="2.ArrayList的扩容？（扩容为原来的1.5倍）"></a>2.ArrayList的扩容？（扩容为原来的1.5倍）</h4><p>(1)先从 ArrayList 的构造函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">构造函数</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist1.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">指定了初始化的容量大小</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist2.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">默认为空，在add的时候会生成一个大小为10的ArrayList</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist3.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">使用集合来构造，会拷贝集合中的值，使用集合大小进行初始化</td>
</tr>
</tbody>
</table>
</div>
<p>（2）扩容（通常大小会变为原来大小的1.5倍，注意和HashMap的扩容机制进行比较）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">add</td>
<td style="text-align:left">确保判断当前要加入的有空间</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">ensureCapacityInternal</td>
<td style="text-align:left">和默认的大小10进行比较</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">ensureExplicitCapacity</td>
<td style="text-align:left">判读是不是需要扩容，需要扩容就进行扩容</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">grow</td>
<td style="text-align:left">将原来的大小变为1.5倍，看看符合要求不，不符合，就是用需求的大小，如果计算出的新的大小必最大值还大，就是用hugeCapacity</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">hugeCapacity</td>
<td style="text-align:left">就是使用最大的整数进行初始化</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">ensureCapacity</td>
<td style="text-align:left">这个函数是提供给用户使用的，可以节约时间</td>
</tr>
</tbody>
</table>
</div>
<p>（3）补充</p>
<ul>
<li><p>System.arraycopy()<code>和</code>Arrays.copyOf()方法</p>
<blockquote>
<p>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</p>
<p>System.arraycopy(elementData, index, elementData, index + 1, size - index);</p>
</blockquote>
</li>
<li><p>使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容</p>
</li>
</ul>
<h4 id="3-HashMap的扩容？（扩容为原来的两倍）"><a href="#3-HashMap的扩容？（扩容为原来的两倍）" class="headerlink" title="3.HashMap的扩容？（扩容为原来的两倍）"></a>3.HashMap的扩容？（扩容为原来的两倍）</h4><blockquote>
<p>HashMap的扩容要和ArrayList的扩容进行区分，HashMap的扩容的真正原因是为了回避Hash冲突，当table中已经倍占用了75%（默认负载因子）就需要进行扩容，扩容的大小为原来的两倍。</p>
<ul>
<li>时机：阈值=负载因子×table大小</li>
<li>扩容table</li>
<li>rehash</li>
</ul>
</blockquote>
<h4 id="4-HashMap和HashTable的区别？"><a href="#4-HashMap和HashTable的区别？" class="headerlink" title="4.HashMap和HashTable的区别？"></a>4.HashMap和HashTable的区别？</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:left">HashMap</th>
<th style="text-align:left">HashTable</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">底层实现</td>
<td style="text-align:left">1.8：Node数组+红黑树，1.8之前（链表散列）</td>
<td style="text-align:left">数组+链表（链表散列）</td>
</tr>
<tr>
<td style="text-align:left">扩容机制</td>
<td style="text-align:left">默认是16，扩容翻倍；HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证）<br><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/tableSizeFor.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left"><span style="color:red">默认是11，扩容2n+1；</span>指定的话，将会按照指定大小。</td>
</tr>
<tr>
<td style="text-align:left">效率</td>
<td style="text-align:left">相对高</td>
<td style="text-align:left">相对低一些</td>
</tr>
<tr>
<td style="text-align:left">对Null key 和Null value的支持</td>
<td style="text-align:left">null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null</td>
<td style="text-align:left">但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException</td>
</tr>
<tr>
<td style="text-align:left">线程是否安全</td>
<td style="text-align:left">HashMap 是非线程安全的</td>
<td style="text-align:left">HashTable 内部的方法基本都经过<code>synchronized</code> 修饰</td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-HashMap中的Node，及其类型？"><a href="#5-HashMap中的Node，及其类型？" class="headerlink" title="5.HashMap中的Node，及其类型？"></a>5.HashMap中的Node，及其类型？</h4><p>（1）Node（实现接口Map.Entry）</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/node.png?lastModify=1574234543" alt="img"></p>
<p>（2）TreeNode(继承自LinkedHashMap.Entry)</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/TreeNode.png?lastModify=1574234543" alt="img"></p>
<p>（3）ConcurrentHash的节点？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Node结点</td>
<td style="text-align:left">默认链接到<code>table[i]</code>——桶上的结点就是Node结点。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">TreeNode结点</td>
<td style="text-align:left">TreeNode就是红黑树的结点，TreeNode不会直接链接到<code>table[i]</code>——桶上面，而是由TreeBin链接，TreeBin会指向红黑树的根结点。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">TreeBin节点</td>
<td style="text-align:left">TreeBin相当于TreeNode的代理结点。TreeBin会直接链接到table[i]——桶上面，该结点提供了一系列红黑树相关的操作，以及加锁、解锁操作。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">ForwardingNode节点</td>
<td style="text-align:left">ForwardingNode结点仅仅在扩容时才会使用。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">ReservationNode节点</td>
<td style="text-align:left">保留结点，ConcurrentHashMap中的一些特殊方法会专门用到该类结点。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/concurrenthashmap.png?lastModify=1574234543" alt="img"></p>
<h4 id="6-ArrayLis实现"><a href="#6-ArrayLis实现" class="headerlink" title="6.ArrayLis实现"></a>6.ArrayLis实现</h4><p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/arraylist0.png?lastModify=1574234543" alt="img"></p>
<ul>
<li><p>实现接口</p>
<ul>
<li>List</li>
<li>RandomAccess</li>
<li>Cloneable</li>
<li>java.io.Serializable</li>
</ul>
</li>
<li><p>继承的类</p>
<ul>
<li>AbstractList</li>
</ul>
</li>
<li><p>内部类</p>
<ul>
<li>private class <strong>Itr</strong> implements Iterator<e>  </e></li>
<li>private class <strong>ListItr</strong> extends Itr implements ListIterator<e>  </e></li>
<li>private class <strong>SubList</strong> extends AbstractList<e> implements RandomAccess  </e></li>
<li>static final class <strong>ArrayListSpliterator</strong><e> implements Spliterator<e> </e></e></li>
</ul>
<blockquote>
<p>ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>，<strong>next()</strong>，<strong>remove()</strong>等方法；其中的<strong>ListItr</strong>继承<strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>，<strong>nextIndex()</strong>，<strong>previousIndex()</strong>，<strong>previous()</strong>，<strong>set(E e)</strong>，<strong>add(E e)</strong>等方法，所以这也可以看出了 <strong>Iterator和ListIterator的区别:</strong>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p>
</blockquote>
</li>
</ul>
<h4 id="7-LinkedList实现"><a href="#7-LinkedList实现" class="headerlink" title="7.LinkedList实现"></a>7.LinkedList实现</h4><ul>
<li>LinkedList是通过双向链表实现的！</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/linkedlist.png?lastModify=1574234543" alt="img"></p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/linkedlist1.png?lastModify=1574234543" alt="img"></p>
<h4 id="8-TreeSet，TreeMap"><a href="#8-TreeSet，TreeMap" class="headerlink" title="8.TreeSet，TreeMap"></a>8.TreeSet，TreeMap</h4><ul>
<li>TreeMap底层是一棵红黑树，TreeMap实现的是NavigableMap</li>
<li>个人认为TreeSet之于TreeMap和HashSet之于HashMap是一样的。</li>
</ul>
<h3 id="（三）并发"><a href="#（三）并发" class="headerlink" title="（三）并发"></a>（三）并发</h3><h4 id="1-Java内存模型？《深入理解Java虚拟机》"><a href="#1-Java内存模型？《深入理解Java虚拟机》" class="headerlink" title="1.Java内存模型？《深入理解Java虚拟机》"></a>1.Java内存模型？《深入理解Java虚拟机》</h4><blockquote>
<p>深入理解Java虚拟机中说：Java虚拟机视图定义一种Java内存模型（Java memory model）来屏蔽各种硬件和操作系统之间的内存访问差异，实现Java程序在各种平台下都能够达到一致性访问的效果。定义了程序中各个变量的访问规则，特别注意的是，这些变量不包括局部变量和方法参数！，因为这些是方法私有的！</p>
</blockquote>
<h4 id="2-单例模式的实现？"><a href="#2-单例模式的实现？" class="headerlink" title="2.单例模式的实现？"></a>2.单例模式的实现？</h4><ul>
<li>双重检查加锁（恶汉模式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); </span></span><br><span class="line">    <span class="comment">//这段代码其实是分为三步执行：</span></span><br><span class="line">    <span class="comment">//1. 为 uniqueInstance 分配内存空间</span></span><br><span class="line">    <span class="comment">//2. 初始化 uniqueInstance</span></span><br><span class="line">    <span class="comment">//3. 将 uniqueInstance 指向分配的内存地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(uniqueInstance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    uniqueInstance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态内部类模式（恶汉模式）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHandler</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 INSTANCE=<span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHandler.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-线程的实现方式？怎么使用lambda的形式？"><a href="#3-线程的实现方式？怎么使用lambda的形式？" class="headerlink" title="3.线程的实现方式？怎么使用lambda的形式？"></a>3.线程的实现方式？怎么使用lambda的形式？</h4><blockquote>
<p>ps:Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。</p>
<p>（1）Thread——————run()方法</p>
<p>（2）Runnable——————run()方法</p>
<p>（3）Callable—————call()—————FutureTask</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaBasic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> ThreadTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 多线程的三种实现方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 19-7-22 上午9:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread by extends Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"thread by implements Runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"thread by implements Callable"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread1 myThread1=<span class="keyword">new</span> MyThread1();</span><br><span class="line">        myThread1.start();</span><br><span class="line"></span><br><span class="line">        MyThread2 myThread2=<span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="keyword">new</span> Thread(myThread2).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//FutureTask的使用</span></span><br><span class="line">        <span class="comment">//Future类的使用</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyThread3());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String res=futureTask.get();</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)使用匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread()+<span class="string">"thread by lambda"</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">"thread by 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;<span class="comment">//创建方式2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">"thread by 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：</p>
<p>对于同一个Thread使用两次start将会有什么结果？</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/multithread/2start.png?lastModify=1574234543" alt="img"></p>
</blockquote>
<h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h4><h5 id="1-为什么要使用线程池？"><a href="#1-为什么要使用线程池？" class="headerlink" title="(1) 为什么要使用线程池？"></a>(1) 为什么要使用线程池？</h5><ul>
<li>在执行大量异步任务的时候能够提供良好的性能。（线程的创建和销毁是有时间开销的）</li>
<li>提供了一种良好的资源限制和管理的方式。</li>
</ul>
<h5 id="2-线程池的架构图"><a href="#2-线程池的架构图" class="headerlink" title="(2) 线程池的架构图"></a>(2) 线程池的架构图</h5><p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/architecture.png?lastModify=1574234543" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Executor</td>
<td style="text-align:left">只有execute方法</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">ExecutorService（继承）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">AbstractExecutorService（实现）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">ThreadPoolExecutor（继承）</td>
<td style="text-align:left">构造器有七个参数</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">Executors（只是一个工具类）</td>
</tr>
</tbody>
</table>
</div>
<p>注意：接口和接口之间不可以使用implements，但是是可以使用继承的！，其实很好理解：implements是需要将所有的方法都实现的，但是interface是不能够包含具体的实现的！切记！</p>
<p>ThreadPoolExecutor继承了AbstractExecutorService，AbstractExecutorService实现了ExecutorService接口，ExecutorService继承了Executor接口。</p>
<ul>
<li>Executors是一个工具类，主要的方法有：<ul>
<li>Executors.newFixedThreadPool</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Executors.newCachedThreadPool</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Executors.newSingleThreadExecutor（一个看来称不上是pool）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ThreadPoolExecutor参数(7个参数)</p>
<blockquote>
<ul>
<li>@param corePoolSize                                核心线程池中的最大线程数</li>
<li>@param maximumPoolSize                      总线程池中的最大线程数</li>
<li>@param keepAliveTime                              空闲线程的存活时间</li>
<li>@param unit                                                 keepAliveTime的单位</li>
<li>@param workQueue                                   任务队列, 保存已经提交但尚未被执行的线程</li>
<li>@param threadFactory                               线程工厂(<span style="color:red">用于指定如果创建一个线程)</span>    </li>
<li>@param handler                                           拒绝策略 (当任务太多导致工作队列满时的处理策略)</li>
</ul>
</blockquote>
</li>
<li><p>线程池的状态（高三位表示状态，第29位表示线程的数量）,ThreadPoolExecutor的ctl属性，三位，取值范围共计5个，特别注意，这一个变量是原子类型的，在谈论原子类型的使用的时候，可以拿来举例！，还要注意的是，只有在线程池的状态等于-1的时候不会产生中断，当状态大于等于0的时候将会产生中断。</p>
<blockquote>
<p>RUNNING                                                              -1 接受新任务, 且处理已经进入阻塞队列的任务</p>
<p>SHUTDOWN                                                           0 不接受新任务, 但处理已经进入阻塞队列的任务</p>
<p>STOP                                                                        1 接受新任务, 且不处理已经进入阻塞队列的任务, 同时中断正在运行的任务</p>
<p>TIDYING                                                                  2 所有任务都已终止, 工作线程数为0, 线程转化为TIDYING状态并准备调用terminated方法</p>
<p>TERMINATED                                                          3 terminated方法已经执行完成</p>
</blockquote>
</li>
<li><p>execute执行流程图</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/execute.png?lastModify=1574234543" alt="img"></p>
<blockquote>
<p>场景：今天是周末，一银行网点只开放了几个窗口，当前值班窗口的数量就是核心线程池的上限。一开始，顾客陆续进来，值班的窗口还有空闲的，则进来一个人就可以直接去柜台办理。随着人数的增加，当天值班窗口全部有人在办理业务，这个时候有人进来，就要在大厅里找个座位坐下来等待，大厅的座位就是阻塞队列。但是，当天人数越来越多，连大厅的座位都坐满了人，这个时候这个网点领导将会通知将当天休息的窗口也打开（所有的窗口数目就是总的线程池上限），当人数还继续增加的话，处于安全考虑，银行就会拒绝继续进入，这就是执行了拒绝策略。</p>
<blockquote>
<ul>
<li>ThreadPoolExecutor：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;<span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));                                                             </span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使⽤ Executors 创建：</li>
</ul>
<blockquote>
<p>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列⻓度为 Integer.MAX_VALUE,可能堆积⼤量的请求，从⽽导致OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ==，可能会创建⼤量线程，从⽽导致OOM。</p>
</blockquote>
<ul>
<li>guava提供的ThreadFactoryBuilder来创建线程池:</li>
</ul>
<blockquote>
<p>通过上述⽅式创建线程时，不仅可以避免OOM的问题，还可以⾃定义线程名称，更加⽅便的出错的时候溯源。</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>拒绝策略</li>
</ul>
<p>| 编号 | 拒绝策略            | 解释                                 |<br>| :—- | :————————— | :—————————————————- |<br>| 1    | CallerRunsPolicy    | 使用调用者所在的线程来执行任务       |<br>| 2    | AbortPolicy         | 抛出异常                             |<br>| 3    | DiscardPolicy       | 默认丢弃，不抛出异常                 |<br>| 4    | DiscardOldestPolicy | 调用poll抛弃一个任务，执行当前的任务 |</p>
</li>
</ul>
<h4 id="5-Java-并发包提供了哪些并发工具类？"><a href="#5-Java-并发包提供了哪些并发工具类？" class="headerlink" title="5.Java 并发包提供了哪些并发工具类？"></a>5.Java 并发包提供了哪些并发工具类？</h4><ul>
<li><p>juc-locks 锁框架</p>
<blockquote>
<p>juc-locks锁框架中一共就三个接口：Lock、Condition、ReadWriteLock</p>
<blockquote>
<p>ReadWriteLock: 一个单独的接口（未继承Lock接口），该接口提供了获取读锁和写锁的方法。</p>
<p>ReentrantLock：ReentrantLock内部通过内部类实现了AQS框架(AbstractQueuedSynchronizer)的API来实现<strong>独占锁</strong>的功能。</p>
<p>ReentrantReadWriteLock：ReentrantReadWriteLock使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。写锁可以降级成读锁，读锁不能升级成写锁。</p>
</blockquote>
</blockquote>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/locks.png?lastModify=1574234543" alt="img"></p>
</li>
<li><p>juc-atomic 原子类框架（ J.U.C之atomic框架：Unsafe类）</p>
<blockquote>
<p>其实底层就是通过Unsafe类实现的一种比较并交换的算法，大致的结构如下（具体入参，根据上下文有所不同）： <code>boolean compareAndSet(expectedValue, updateValue);</code> 当希望修改的值与expectedValue相同时，则尝试将值更新为updateValue，更新成功返回true，否则返回false。</p>
<blockquote>
<p>Unsafe类，来源于<code>sun.misc</code>包。该类封装了许多类似指针操作，可以直接进行内存管理、操纵对象、阻塞/唤醒线程等操作。Java本身不直接支持指针的操作，所以这也是该类命名为Unsafe的原因之一。</p>
</blockquote>
</blockquote>
</li>
<li><p>juc-sync 同步器框架</p>
</li>
<li><p>juc-collections 集合框架</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/juc-collections.png?lastModify=1574234543" alt="img"></p>
</li>
<li><p>juc-executors 执行器框架</p>
<ul>
<li>线程池</li>
<li>Future模式,Future接口仅仅定义了5个方法。</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/future.png?lastModify=1574234543" alt="img"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/futuretask_state.png?lastModify=1574234543" alt="img"></p>
<ul>
<li>Fork/Join框架</li>
</ul>
</li>
</ul>
<h5 id="1-提供了比-synchronized-更加高级的各种同步结构"><a href="#1-提供了比-synchronized-更加高级的各种同步结构" class="headerlink" title="(1)提供了比 synchronized 更加高级的各种同步结构"></a>(1)提供了比 synchronized 更加高级的各种同步结构</h5><blockquote>
<p>包括 CountDownLatch、CyclicBarrier、Sempahore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</p>
<blockquote>
<ul>
<li>CountDownLatch，允许一个或多个线程等待某些操作完成</li>
<li>CyclicBarrier，一种辅助性的同步结构，允许多个线程等待到达某个屏障</li>
</ul>
<blockquote>
<ul>
<li>CountDownLatch 是不可以重置的，所以无法重用；而 CyclicBarrier 则没有这种限制，可以重用。</li>
<li>CountDownLatch 的基本操作组合是 countDown/await。调用 await 的线程阻塞等待countDown 足够的次数，不管你是在一个线程还是多个线程里 countDown，只要次数足够即可。所以就像 Brain Goetz 说过的，CountDownLatch 操作的是事件。</li>
<li>CyclicBarrier 的基本操作组合，则就是 await，当所有的伙伴（parties）都调用了 await，才会继续进行任务，并自动进行重置。</li>
</ul>
</blockquote>
<ul>
<li>Semaphore，Java 版本的信号量实现,总的来说，Semaphore 就是个计数器，其基本逻辑基于 acquire/release.</li>
</ul>
</blockquote>
</blockquote>
<h5 id="2-各种线程安全的容器"><a href="#2-各种线程安全的容器" class="headerlink" title="(2)各种线程安全的容器"></a>(2)各种线程安全的容器</h5><blockquote>
<p>比如最常见的 ConcurrentHashMap、有序的ConcunrrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组CopyOnWriteArrayList 等。</p>
<blockquote>
<p>Concurrent</p>
<p>CopyOnWrite</p>
<p>Blocking</p>
</blockquote>
</blockquote>
<h5 id="3-并发队列实现"><a href="#3-并发队列实现" class="headerlink" title="(3)并发队列实现"></a>(3)并发队列实现</h5><blockquote>
<p>如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等。</p>
</blockquote>
<h5 id="4-强大的-Executor-框架"><a href="#4-强大的-Executor-框架" class="headerlink" title="(4)强大的 Executor 框架"></a>(4)强大的 Executor 框架</h5><blockquote>
<p>可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器</p>
</blockquote>
<h5 id="5-AQS框架-AbstractQueuedSynchronizer抽象类"><a href="#5-AQS框架-AbstractQueuedSynchronizer抽象类" class="headerlink" title="(5)AQS框架(AbstractQueuedSynchronizer抽象类)"></a>(5)AQS框架(AbstractQueuedSynchronizer抽象类)</h5><blockquote>
<blockquote>
<ul>
<li>AQS利用了模板方法模式，其中大多数方法都是final或是private的，我们把这类方法称为<strong>Skeleton Method</strong>，也就是说这些方法是AQS框架自身定义好的骨架，子类是不能覆写的。</li>
<li>支持中断、超时</li>
<li>支持独占模式和共享模式</li>
<li>支持Condition条件等待</li>
</ul>
</blockquote>
<p>AQS方法说明:</p>
<blockquote>
<ul>
<li>CAS操作</li>
<li>等待队列的核心操作</li>
<li>资源的获取操作</li>
<li>资源的释放操作</li>
</ul>
</blockquote>
<p>三个基本问题：</p>
<blockquote>
<ul>
<li>同步状态（synchronization state）的管理</li>
<li>阻塞/唤醒线程的操作</li>
<li>线程等待队列的管理</li>
</ul>
</blockquote>
<p>CLH队列</p>
<blockquote>
<p>CLH队列中的结点是对线程的包装，结点一共有两种类型：独占（EXCLUSIVE）和共享（SHARED）。 每种类型的结点都有一些状态，其中独占结点使用其中的CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)，共享结点使用其中的CANCELLED(1)、SIGNAL(-1)、PROPAGATE(-3)。</p>
</blockquote>
<p>Node节点</p>
</blockquote>
<h4 id="6-哪些队列是有界的，哪些是无界的？"><a href="#6-哪些队列是有界的，哪些是无界的？" class="headerlink" title="6.哪些队列是有界的，哪些是无界的？"></a>6.哪些队列是有界的，哪些是无界的？</h4><p>从源码的角度，常见的线程安全队列是如何实现的，并进行了哪些改进以提高性能表现？</p>
<p>(1)有界or无界</p>
<blockquote>
<ul>
<li>ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量</li>
<li>LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 Integer.MAX_VALUE，成为了无界队列。</li>
<li>SynchronousQueue，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。</li>
<li>PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响</li>
<li>DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。</li>
</ul>
</blockquote>
<p>(2)安全?</p>
<blockquote>
<ul>
<li>BlockingQueue 基本都是基于锁实现</li>
<li>类似 ConcurrentLinkedQueue 等，则是基于 CAS 的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异</li>
</ul>
</blockquote>
<h4 id="7-生产者-消费者"><a href="#7-生产者-消费者" class="headerlink" title="7.生产者 - 消费者?"></a>7.生产者 - 消费者?</h4><ul>
<li>（1）传统版synchronized: sync———————-&gt;wait——————-&gt;notify</li>
<li>（2）传统版lock： lock—————&gt;await—————&gt;Signal</li>
<li>（3）阻塞队列+原子类</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; * 1 线程    操作   资源类</span><br><span class="line">&gt; * 2 判断    干活   通知</span><br><span class="line">&gt;* 3 虚假唤醒</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.MultiThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> ProducerConsumerSync</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 上午8:48 2019/8/9</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareSource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        ++number;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        --number;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerSync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareSource shareSource=<span class="keyword">new</span> ShareSource();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareSource.increment();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"producer-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareSource.decrement();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"consumer-1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition=lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//判断,不能够使用if判断，必须使用while判断</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+number);</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+number);</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTraditional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData=<span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"producer"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"consumer"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.MultiThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> ProducerConsumerBlockingQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用阻塞队列，生产一个消费一个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 下午8:51 2019/8/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG=<span class="keyword">true</span>; <span class="comment">//可见性</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger();<span class="comment">//原子类</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue=<span class="keyword">null</span>;<span class="comment">//阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue=blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retvalue;</span><br><span class="line">        <span class="keyword">while</span> (FLAG)&#123;</span><br><span class="line">            data=atomicInteger.incrementAndGet()+<span class="string">""</span>;</span><br><span class="line">            retvalue=blockingQueue.offer(data,<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retvalue)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">":insert ok "</span>+data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">":insert fail"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">":producer stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myCons</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String result;</span><br><span class="line">        <span class="keyword">while</span> (FLAG)&#123;</span><br><span class="line">            result=blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>==result||result.equalsIgnoreCase(<span class="string">""</span>))&#123;</span><br><span class="line">                FLAG=<span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">":consumer stop"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">":consume ok "</span>+result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Resource resource=<span class="keyword">new</span> Resource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" producer start"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resource.myProd();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"producer"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" consumer start"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resource.myCons();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"consumer"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        resource.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-synchronized和lock的区别？用lock的好处？"><a href="#8-synchronized和lock的区别？用lock的好处？" class="headerlink" title="8.synchronized和lock的区别？用lock的好处？"></a>8.synchronized和lock的区别？用lock的好处？</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:left">synchronized</th>
<th style="text-align:left">lock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">原始构成</td>
<td style="text-align:left">（关键字）jvm层面，底层通过monitor对象来完成，monitorenter和monitorexit（两个monitorexit）</td>
<td style="text-align:left">（具体类）Lock是具体的类（java.concurrent.locks.Lock）,是api层面的锁（使用java p）</td>
</tr>
<tr>
<td style="text-align:left">使用方法</td>
<td style="text-align:left">自动释放</td>
<td style="text-align:left">需要使用try、finally释放</td>
</tr>
<tr>
<td style="text-align:left">等待是否可中断</td>
<td style="text-align:left">不可以被中断</td>
<td style="text-align:left">可以被中断，lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</td>
</tr>
<tr>
<td style="text-align:left">加锁是否公平</td>
<td style="text-align:left">非公平锁</td>
<td style="text-align:left">默认是非公平锁，构造函数传参，true公平，false非公平</td>
</tr>
<tr>
<td style="text-align:left">锁绑定多个条件</td>
<td style="text-align:left">没有</td>
<td style="text-align:left">可以用来实现分组唤醒需要唤醒的线程，可以精确唤醒，synchronized随机唤醒一个或者多个</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> MaoTian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> SyncAndLockCondition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> lock可以绑定多个condition，可以精确唤醒A-B-C-D-A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 下午8:23 2019/8/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by mao&lt;tianmao818@qq.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>; <span class="comment">//A=1,B=2,C=3</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition c1=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3=lock.newCondition();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print_5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">":"</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">1</span>;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print_10</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">":"</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">2</span>;</span><br><span class="line">            c3.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print_15</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                c3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">15</span> ; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">":"</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">            number=<span class="number">0</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndLockCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource=<span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                shareResource.print_5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                shareResource.print_10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                shareResource.print_15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-JUC主要包含的内容？透彻理解Java并发编程"><a href="#9-JUC主要包含的内容？透彻理解Java并发编程" class="headerlink" title="9.JUC主要包含的内容？透彻理解Java并发编程"></a>9.JUC主要包含的内容？<a href="https://segmentfault.com/blog/ressmix_multithread" target="_blank" rel="noopener"><a href="https://segmentfault.com/blog/ressmix_multithread" target="_blank" rel="noopener">透彻理解Java并发编程</a></a></h4><h5 id="（1）概览"><a href="#（1）概览" class="headerlink" title="（1）概览"></a>（1）概览</h5><p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/juc.png?lastModify=1574234543" alt="img"></p>
<h5 id="（2）-并发容器"><a href="#（2）-并发容器" class="headerlink" title="（2） 并发容器"></a>（2） 并发容器</h5><ul>
<li>CopyOnWrite*(List,Set)</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/copyonwrite.png?lastModify=1574234543" alt="img"></p>
<ul>
<li><p>Concurrent*(SkipListSet,SkipListMap,Map,LinkedQueue)</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/concurrent.png?lastModify=1574234543" alt="img"></p>
</li>
<li><p>Blocking*(Queue, Deque)(Array,Linked,Priority)</p>
</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/blocking.png?lastModify=1574234543" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">List，Set</th>
<th style="text-align:left">Map</th>
<th style="text-align:left">Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CopyOnWriteArrayList<br>CopyOnWriteArraySet<br>ConcurrentSkipListSet<br></td>
<td style="text-align:left">ConcurrentHashMap<br>ConcurrentSkipListMap<br></td>
<td style="text-align:left">ArrayBlockingQueue<br>LinkedBlockingQueue<br>ConcurrentLinkedQueue<br>ConcurrentLinkedDeque<br></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">ji(Ctrl+H,Alt+7)</th>
<th style="text-align:left">并发</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CopyOnWriteArrayList</td>
<td style="text-align:left">Cloneable (java.lang)<br>List (java.util)<br>    Collection (java.util)<br>        Iterable (java.lang)<br>Object (java.lang)<br>RandomAccess (java.util)<br>Serializable (java.io)</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/CopyOnWriteArrayList.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">ReentrantLock,读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。<code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的。</td>
</tr>
<tr>
<td style="text-align:left">CopyOnWriteArraySet</td>
<td style="text-align:left">AbstractSet (java.util)<br>    AbstractCollection (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>        Object (java.lang)<br>    Set (java.util)<br>        Collection (java.util)<br>Serializable (java.io)</td>
<td style="text-align:left"><em> A {@link java.util.Set} that uses an internal {@link CopyOnWriteArrayList} </em> for all of its operations.<br>  Thus, it shares the same basic properties*<br><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/CopyOnWriteArraySet.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">ReentrantLock</td>
</tr>
<tr>
<td style="text-align:left">ConcurrentSkipListSet</td>
<td style="text-align:left">AbstractSet (java.util)<br>    AbstractCollection (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>        Object (java.lang)<br>    Set (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>Cloneable (java.lang)<br>NavigableSet (java.util)<br>    SortedSet (java.util)<br>        Set (java.util)<br>            Collection (java.util)<br>                Iterable (java.lang)<br>Serializable (java.io)</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ConcurrentHashMap</td>
<td style="text-align:left">AbstractMap (java.util)<br>    Map (java.util)<br>    Object (java.lang)<br><code>ConcurrentMap (java.util.concurrent)</code><br>    Map (java.util)<br>Serializable (java.io)</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/cas.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">JDK1.8:<br>Node + CAS + Synchronized</td>
</tr>
<tr>
<td style="text-align:left">ConcurrentSkipListMap</td>
<td style="text-align:left">AbstractMap (java.util)<br>    Map (java.util)<br>    Object (java.lang)<br>Cloneable (java.lang)<br>ConcurrentNavigableMap (java.util.concurrent)<br>    ConcurrentMap (java.util.concurrent)<br>        Map (java.util)<br>    <code>NavigableMap (java.util)</code><br>        SortedMap (java.util)<br>            Map (java.util)<br>Serializable (java.io)</td>
<td style="text-align:left">使用跳表实现Map 和使用哈希算法实现Map的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是ConcurrentSkipListMap。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ArrayBlockingQueue</td>
<td style="text-align:left">AbstractQueue (java.util)<br>    AbstractCollection (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>        Object (java.lang)<br>    Queue (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>BlockingQueue (java.util.concurrent)<br>    Queue (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>Serializable (java.io)</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/ArrayBlockingQueue.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">Lock+Condition</td>
</tr>
<tr>
<td style="text-align:left">LinkedBlockingQueue</td>
<td style="text-align:left">AbstractQueue (java.util)<br>    AbstractCollection (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>        Object (java.lang)<br>    Queue (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>BlockingQueue (java.util.concurrent)<br>    Queue (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>Serializable (java.io)</td>
<td style="text-align:left">ArrayBlockingQueue与LinkedBlockingQueue的比较?<br>相同点：<br>ArrayBlockingQueue和LinkedBlockingQueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；<br>ArrayBlockingQueue底层是采用的数组进行实现,而LinkedBlockingQueue则是采用链表数据结构；<br>不同点:<br>ArrayBlockingQueue插入和删除数据，只采用了一个lock，而LinkedBlockingQueue则是在插入和删除分别采用了<code>putLock</code>和<code>takeLock</code>，这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">ConcurrentLinkedQueue</td>
<td style="text-align:left">AbstractQueue (java.util)<br>    AbstractCollection (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>        Object (java.lang)<br>    Queue (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>Queue (java.util)<br>    Collection (java.util)<br>        Iterable (java.lang)<br>Serializable (java.io)</td>
<td style="text-align:left">阻塞队列的典型例子是 BlockingQueue,非阻塞队列的典型例子是ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/ConcurrentLinkedQueue.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">无锁算法，底层基于<strong>自旋+CAS</strong>的方式实现。</td>
</tr>
<tr>
<td style="text-align:left">ConcurrentLinkedDeque</td>
<td style="text-align:left">AbstractCollection (java.util)<br>    Collection (java.util)<br>        Iterable (java.lang)<br>    Object (java.lang)<br>Deque (java.util)<br>    Queue (java.util)<br>        Collection (java.util)<br>            Iterable (java.lang)<br>Serializable (java.io)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>CopyOnWrite*：只有两个</li>
<li>Concurrent*</li>
<li>Blocking*</li>
</ul>
</blockquote>
<h5 id="（3）ConcurrentHashMap"><a href="#（3）ConcurrentHashMap" class="headerlink" title="（3）ConcurrentHashMap"></a>（3）ConcurrentHashMap</h5><blockquote>
<p>(注意，和HashMap相比较，实现上，ConcurrentHashMap节点种类是5种)</p>
<p><strong>针对ConcurrentHashMap的讲解要分析以下的几个点（注意条理！）</strong></p>
<ul>
<li>构成上，分析五个Node<ul>
<li>Node</li>
<li>TreeBin</li>
<li>TreeNode</li>
<li>ForwardingNode</li>
<li>ReservationNode</li>
</ul>
</li>
<li>操作上，分析：<ul>
<li>get方法采用了unsafe方法，来保证线程安全。<ul>
<li>如果table[i]的key和待查找key相同，那直接返回；</li>
<li>如果table[i]对应的结点是特殊结点（hash值小于0），则通过find方法查找；</li>
<li>如果table[i]对应的结点是普通链表结点，则按链表方式查找。</li>
</ul>
</li>
<li>put<ul>
<li>首次初始化table —— 懒加载</li>
<li>table[i]对应的桶为空，最简单的情况，直接CAS操作占用桶<code>table[i]</code>即可。</li>
<li>发现ForwardingNode结点，说明此时table正在扩容，则尝试协助进行数据迁移</li>
<li>出现hash冲突,也就是table[i]桶中已经有了结点<ul>
<li>table[i]的结点类型为Node——链表结点时，就会将新结点以“尾插法”的形式插入链表的尾部。</li>
<li>当table[i]的结点类型为TreeBin——红黑树代理结点时，就会将新结点通过红黑树的插入方式插入。</li>
</ul>
</li>
<li>putVal方法的最后，涉及将链表转换为红黑树 —— treeifyBin ，但实际情况并非立即就会转换，当table的容量小于64时，static final int MIN_TREEIFY_CAPACITY = 64;出于性能考虑，只是对table数组扩容1倍——tryPresize</li>
</ul>
</li>
<li>计数（分段计数）</li>
<li>扩容问题<ul>
<li><strong>table数组的扩容</strong>，一般就是新建一个2倍大小的槽数组，这个过程通过由一个单线程完成，且不允许出现并发。（时机：和负载因子有关系）</li>
<li>数据迁移<ul>
<li>链表</li>
<li>红黑树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2019/11/20/Java总结-2/home/mao/workspace/%E9%9D%A2%E8%AF%95/JavaGuide/JavaInterview/images/juc/concurrenthashmap.png" width="800"></p>
<p><img src="/2019/11/20/Java总结-2/home/mao/workspace/%E9%9D%A2%E8%AF%95/JavaGuide/JavaInterview/images/juc/concurrenthashmap_1.png" width="600"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许 key或value为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//死循环 何时插入成功 何时跳出</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table为空的话，初始化table </span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//根据hash值计算出在table里面的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个位置没有值 ，直接放进去，不需要加锁</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//结点上锁  这里的结点可以理解为hash值相同组成的链表的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//在这里遍历链表所有的结点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果hash值和key值相同  则修改对应结点的value值 </span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                             <span class="comment">//如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果链表长度已经达到临界值8 就需要把链表转换为树结构</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前ConcurrentHashMap的元素数量+1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（4）原子类"><a href="#（4）原子类" class="headerlink" title="（4）原子类"></a>（4）原子类</h5><blockquote>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">基本类型</td>
<td style="text-align:left">AtomicInteger：整型原子类 ，AtomicLong：长整型原子类 ，AtomicBoolean ：布尔型原子类</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">数组类型</td>
<td style="text-align:left">AtomicIntegerArray：整型数组原子类， AtomicLongArray：长整型数组原子类， AtomicReferenceArray：引用类型数组原子类</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">引用类型</td>
<td style="text-align:left">CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，<br>提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象<br>里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并<br>成一个共享变量来操作。<br>AtomicReference：引用类型原子类,AtomicStampedReference：原子更新引用类型里的字段原子类AtomicMarkableReference：原子更新带有标记位的引用类型</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">对象的属性修改类型</td>
<td style="text-align:left">AtomicIntegerFieldUpdater:原子更新整型字段的更新器,AtomicLongFieldUpdater：原子更新长整型字段的更新器</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>引用类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;      AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> AtomicReference&lt;Person&gt;();</span><br><span class="line">&gt;     Person person = <span class="keyword">new</span> Person(<span class="string">"SnailClimb"</span>, <span class="number">22</span>);</span><br><span class="line">&gt;      ar.set(person);</span><br><span class="line">&gt;     Person updatePerson = <span class="keyword">new</span> Person(<span class="string">"Daisy"</span>, <span class="number">20</span>);</span><br><span class="line">&gt;      ar.compareAndSet(person, updatePerson);</span><br><span class="line">&gt;     System.out.println(ar.get().getName());</span><br><span class="line">&gt;      System.out.println(ar.get().getAge());</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&gt;  <span class="keyword">private</span> String name;</span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">&gt;      <span class="keyword">super</span>();</span><br><span class="line">&gt;      <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;         <span class="keyword">this</span>.age = age;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.name = name;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;      <span class="keyword">return</span> age;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.age = age;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="（5）synchronized和ReentrantLock的比较？"><a href="#（5）synchronized和ReentrantLock的比较？" class="headerlink" title="（5）synchronized和ReentrantLock的比较？"></a>（5）synchronized和ReentrantLock的比较？</h5><p>ReentrantLock可以在部分场合替代synchronized，</p>
<ul>
<li>（1）可以实现公平锁———进入队列就是公平，非公平就是抢锁是插队抢，</li>
<li>（2）可以打断上锁的过程，可以使用trylock()或者lockInterruptibly</li>
<li>（3）锁尚明的队列可以指定任意数量</li>
<li>（4）可以手动释放锁，lock.unlock.</li>
</ul>
<h4 id="10-为什么要使用多线程？"><a href="#10-为什么要使用多线程？" class="headerlink" title="10.为什么要使用多线程？"></a>10.为什么要使用多线程？</h4><blockquote>
<p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。    </li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
</blockquote>
<h4 id="11-上下文切换？"><a href="#11-上下文切换？" class="headerlink" title="11.上下文切换？"></a>11.上下文切换？</h4><blockquote>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 </p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<h4 id="12-synchronized-关键字"><a href="#12-synchronized-关键字" class="headerlink" title="12.synchronized 关键字"></a>12.synchronized 关键字</h4><p><span style="color:red"><strong>是什么？（一句话介绍）———&gt;用来做什么？（作用对象）———&gt;实现的原理是什么？（synchronized内存语义，锁状态及其转化）</strong></span></p>
<h5 id="（1）说一说对synchronized关键字？"><a href="#（1）说一说对synchronized关键字？" class="headerlink" title="（1）说一说对synchronized关键字？"></a><strong>（1）说一说对synchronized关键字？</strong></h5><p><span style="color:red">synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。且为非公平锁。 </span> 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。</p>
<p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如<span style="color:red">自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</span></p>
<blockquote>
<p>（1）synchronized 同步语句块的情况？</p>
<blockquote>
<p>synchronized 同步语句块的实现使用的是 <strong>monitorenter 和 monitorexit</strong> 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
</blockquote>
<p>（2）synchronized 修饰方法的的情况</p>
<blockquote>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的是<span style="color:red">ACC_SYNCHRONIZED标识，</span>该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
</blockquote>
</blockquote>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/synchronized-usage.png" alt=""></p>
<h5 id="（2）优化"><a href="#（2）优化" class="headerlink" title="（2）优化"></a><strong>（2）优化</strong></h5><p>锁主要存在四中状态，依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">偏向锁</td>
<td style="text-align:left"><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。<br>但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而<span style="color:red">偏向锁在无竞争的情况下会把整个同步都消除掉</span></strong></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">轻量级锁</td>
<td style="text-align:left"><strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，<span style="color:red">因为使用轻量级锁时，不需要申请互斥量。</span>另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">自旋锁和自适应自旋</td>
<td style="text-align:left">轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。<span style="color:red">互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）</span>。<br>对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。<strong>自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">锁消除</td>
<td style="text-align:left">锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">锁粗化</td>
<td style="text-align:left">原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（3）sychronized-C-实现源码"><a href="#（3）sychronized-C-实现源码" class="headerlink" title="（3）sychronized C++实现源码"></a>（3）sychronized C++实现源码</h5><p>Synchronized  本质是对一个对象监视器(monitor)进行获取：在Java虚拟机执行到monitorenter指令时，（1）首先它会<strong>尝试获取对象的锁</strong>，如果该对象没有锁，或者当前线程已经拥有了这个对象的锁时，它会把计数器+1；然后当执行到monitorexit 指令时就会将计数器-1；然后当计数器为0时，锁就释放了。（2）如果获取锁 失败，那么当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// monitor</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_monitor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value() &amp; monitor_value) != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">ObjectMonitor* <span class="title">monitor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(has_monitor(), <span class="string">"check"</span>);</span><br><span class="line">    <span class="comment">// Use xor instead of &amp;~ to provide one extra tag-bit check.</span></span><br><span class="line">    <span class="keyword">return</span> (ObjectMonitor*) (value() ^ monitor_value);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>; <span class="comment">//markOop对象头</span></span><br><span class="line">    _count        = <span class="number">0</span>;    </span><br><span class="line">    _waiters      = <span class="number">0</span>,   <span class="comment">//等待线程数</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;   <span class="comment">//线程重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;  <span class="comment">//存储Monitor对象</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>;  <span class="comment">//获得ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;  <span class="comment">//wait状态的线程列表</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ; </span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ; <span class="comment">// 单向列表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁BLOCKED状态的线程</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;   </span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ; </span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>; <span class="comment">//监视器前一个拥有线程的ID</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// monitorenter</span></span><br><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  Handle h_obj(thread, elem-&gt;obj());</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//绕过偏向锁，直接进入轻量级锁</span></span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// monitorexit</span></span><br><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  Handle h_obj(thread, elem-&gt;obj());</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (elem == <span class="literal">NULL</span> || h_obj()-&gt;is_unlocked()) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  elem-&gt;set_obj(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 偏向锁</span></span><br><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS) &#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;<span class="comment">//判断是否开启锁</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;<span class="comment">//如果不处于全局安全点</span></span><br><span class="line">      <span class="comment">//通过`revoke_and_rebias`这个函数尝试获取偏向锁</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;<span class="comment">//如果是撤销与重偏向直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果在安全点，撤销偏向锁</span></span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轻量级🔒</span></span><br><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;<span class="comment">//如果当前是无锁状态</span></span><br><span class="line">    <span class="comment">//直接把mark保存到BasicLock对象的_displaced_header字段</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="comment">//通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁</span></span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//如果markword处于加锁状态、且markword中的ptr指针指向当前线程的栈帧，表示为重入操作，不需要争抢锁</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="comment">//代码执行到这里，说明有多个线程竞争轻量级锁，轻量级锁通过`inflate`进行膨胀升级为重量级锁</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多个线程同时访问一段同步代码时，首先会进入 <span style="color:red">_EntryList 队列</span>中，当某个线程获取到对象的 monitor 后进入 _Owner 区域并把 monitor 中的 _owner 变量设置为当前线程，同时 monitor 中的计数器 _count 加 1。即获得对象锁。</p>
<p>若持有 monitor 的线程调用 wait() 方法，将释放当前持有的 monitor，_owner 变量恢复为 null，_count 自减 1，同时该线程进入<span style="color:red"> _WaitSet 集合</span>中等待被唤醒(等待 synchronized 锁的线程<strong>不可被中断</strong>，即使调用了该线程的 interrupt 方法。只有获取到锁之后才会中断。另外中断操作只是给线程一个标记，最终执行是看线程本身的状态)。</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/entrylist_waitset.png" alt=""></p>
<h5 id="（4）openjdk官方文档jdk-wiki"><a href="#（4）openjdk官方文档jdk-wiki" class="headerlink" title="（4）openjdk官方文档jdk wiki"></a>（4）<a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">openjdk官方文档jdk wiki</a></h5><ul>
<li><p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></p>
</li>
<li><p>The following figure shows the layout of the <span style="color:red">header word and the representation of different object states.</span></p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/Synchronization.gif" alt=""></p>
</li>
<li><p>不同的锁状态</p>
</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/synchronized.png" alt=""></p>
<h4 id="12-CAS"><a href="#12-CAS" class="headerlink" title="12. CAS"></a>12. CAS</h4><h5 id="（1）ABA问题"><a href="#（1）ABA问题" class="headerlink" title="（1）ABA问题"></a>（1）ABA问题</h5><ul>
<li>版本号解决，或者直接加一个Boolean类的标记</li>
<li>初看ABA问题像是没有什么问题？但是<span style="color:red">对于引用类型来说就有问题了，比如B线程修改了属性。</span></li>
</ul>
<h5 id="（2）比较和操作的原子性"><a href="#（2）比较和操作的原子性" class="headerlink" title="（2）比较和操作的原子性"></a>（2）比较和操作的原子性</h5><h5 id="（3）-CAS一直在消耗CPU"><a href="#（3）-CAS一直在消耗CPU" class="headerlink" title="（3） CAS一直在消耗CPU"></a>（3） CAS一直在消耗CPU</h5><p>一直在转圈，比如竞争就几个，循环OK。</p>
<h5 id="（4）CAS和synchronized的效率"><a href="#（4）CAS和synchronized的效率" class="headerlink" title="（4）CAS和synchronized的效率"></a>（4）CAS和synchronized的效率</h5><ul>
<li>不同的场景效率不一样</li>
<li>synchronized有排序，但是涉及到cpu的一些列操作</li>
</ul>
<h4 id="12-UNSAFE"><a href="#12-UNSAFE" class="headerlink" title="12. UNSAFE"></a>12. UNSAFE</h4><p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/unsafe.png" alt=""></p>
<p>Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类。</p>
<ul>
<li>compareAndSwapInt</li>
</ul>
<blockquote>
<p>AutomicInteger—-&gt;unsafe.getAndAddInt—-&gt;compareAndSwapInt—-&gt;(native)compareAndSwapInt—-&gt;unsafe.cpp—-&gt;Unsafe_CompareAndSwapInt——&gt;Atomic::cmpxchg—-&gt;<span style="color:red">asm的汇编代码lock comxchg</span>,（comxchg汇编语句不保证原子性，lock指令支持锁总线）</p>
</blockquote>
<h4 id="13-AQS原理分析（AbstractQueuedSynchronizer）"><a href="#13-AQS原理分析（AbstractQueuedSynchronizer）" class="headerlink" title="13.AQS原理分析（AbstractQueuedSynchronizer）"></a>13.AQS原理分析（AbstractQueuedSynchronizer）</h4><blockquote>
<p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，<span style="color:red">这个机制AQS是用CLH队列锁实现的，</span>即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类—<strong>AbstractQueuedSynchronizer</strong>,简称AQS。</p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的<span style="color:red">ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask</span>等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<p><span style="color:red">AQS相当于CAS+volatile.</span></p>
</blockquote>
<h4 id="14-AQS组件"><a href="#14-AQS组件" class="headerlink" title="14.AQS组件"></a>14.AQS组件</h4><blockquote>
<ul>
<li>Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">CountDownLatch</th>
<th style="text-align:left">CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">减数方式</td>
<td style="text-align:left">加数方式</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">countDown函数+await函数</td>
<td style="text-align:left">await函数</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">计数为0以后，无法重置</td>
<td style="text-align:left">计数达到指定的值后，从0重新开始</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">不可重复利用</td>
<td style="text-align:left">可以重复利用</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
</blockquote>
<h4 id="15-AQS对于资源的共享方式"><a href="#15-AQS对于资源的共享方式" class="headerlink" title="15.AQS对于资源的共享方式"></a>15.AQS对于资源的共享方式</h4><blockquote>
<ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>
</ul>
</blockquote>
<h4 id="16-自定义同步器时需要重写下面几个AQS提供的模板方法"><a href="#16-自定义同步器时需要重写下面几个AQS提供的模板方法" class="headerlink" title="16.自定义同步器时需要重写下面几个AQS提供的模板方法"></a>16.自定义同步器时需要重写下面几个AQS提供的模板方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
</blockquote>
<h4 id="17-Future和FutureTask的区别？-Future等结果，FutureTask可以被提交"><a href="#17-Future和FutureTask的区别？-Future等结果，FutureTask可以被提交" class="headerlink" title="17.Future和FutureTask的区别？(Future等结果，FutureTask可以被提交)"></a>17.Future和FutureTask的区别？(Future等结果，FutureTask可以被提交)</h4><blockquote>
<p>线程的创建方式中有两种，一种是实现Runnable接口，另一种是继承Thread，但是这两种方式都有个缺点，那就是在任务执行完成之后无法获取返回结果，于是就有了Callable接口，Future接口与FutureTask类的配和取得返回的结果。FutureTask除了实现了Future接口外还实现了Runnable接口,Future<v>接口是用来获取异步计算结果的.无论是Runnable接口的实现类还是Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行</v></p>
<p><a href="https://segmentfault.com/a/1190000015558810" target="_blank" rel="noopener">Future模式</a>是Java多线程设计模式中的一种常见模式，它的主要作用就是异步地执行任务，并在需要的时候获取结果。我们知道，一般调用一个函数，需要等待函数执行完成，调用线程才会继续往下执行，如果是一些计算密集型任务，需要等待的时间可能就会比较长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&gt; &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//创建线程池  </span></span><br><span class="line">&gt; ExecutorService es = Executors.newSingleThreadExecutor();  </span><br><span class="line">&gt;<span class="comment">//创建Callable对象任务  </span></span><br><span class="line">&gt; CallableDemo calTask=<span class="keyword">new</span> CallableDemo();  </span><br><span class="line">&gt;<span class="comment">//提交任务并获取执行结果  </span></span><br><span class="line">&gt; Future&lt;Integer&gt; future =es.submit(calTask);  </span><br><span class="line">&gt;<span class="comment">//关闭线程池  </span></span><br><span class="line">&gt; es.shutdown(); </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//创建线程池  </span></span><br><span class="line">&gt; ExecutorService es = Executors.newSingleThreadExecutor();  </span><br><span class="line">&gt; <span class="comment">//创建Callable对象任务  </span></span><br><span class="line">&gt; CallableDemo calTask=<span class="keyword">new</span> CallableDemo();  </span><br><span class="line">&gt; <span class="comment">//创建FutureTask  </span></span><br><span class="line">&gt; FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(calTask);  </span><br><span class="line">&gt; <span class="comment">//执行任务  </span></span><br><span class="line">&gt; es.submit(futureTask);  </span><br><span class="line">&gt; <span class="comment">//关闭线程池  </span></span><br><span class="line">&gt; es.shutdown();  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="18-FutureTask的7种状态"><a href="#18-FutureTask的7种状态" class="headerlink" title="18.FutureTask的7种状态"></a>18.FutureTask的7种状态</h4><blockquote>
<p>FutureTask的字段定义非常简单，State标识任务的当前状态，状态之间的转换通过Unsafe来操作，所有操作都基于自旋+CAS完成：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">状态</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">new</td>
<td style="text-align:left">表示任务的初始化状态；</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">canceled</td>
<td style="text-align:left">表示任务还没开始执行就被取消（非中断方式），属于最终状态；</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">interrupting</td>
<td style="text-align:left">表示任务还没开始执行就被取消（中断方式），正式被中断前的过渡状态，属于中间状态；</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">interrupted</td>
<td style="text-align:left">表示任务还没开始执行就被取消（中断方式），且已被中断，属于最终状态。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">completing</td>
<td style="text-align:left">表示任务已执行完成（正常完成或异常完成），但任务结果或异常原因还未设置完成，属于中间状态；</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">exceptional</td>
<td style="text-align:left">表示任务已经执行完成（异常完成），且任务异常已设置完成，属于最终状态；</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">normal</td>
<td style="text-align:left">表示任务已经执行完成（正常完成），且任务结果已设置完成，属于最终状态；</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/juc/FutureTask.png?lastModify=1574234543" alt="img"></p>
</blockquote>
<h4 id="19-Java中的锁"><a href="#19-Java中的锁" class="headerlink" title="19.Java中的锁"></a>19.Java中的锁</h4><h4 id="（1）乐观锁，悲观锁"><a href="#（1）乐观锁，悲观锁" class="headerlink" title="（1）乐观锁，悲观锁"></a>（1）乐观锁，悲观锁</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">类别</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">实现机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">悲观锁</td>
<td style="text-align:left">总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</td>
<td style="text-align:left">乐观锁一般会使用版本号机制或CAS算法实现。（提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">乐观锁</td>
<td style="text-align:left">总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>CAS的问题？</p>
<ul>
<li>ABA 问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ul>
</blockquote>
<h4 id="（2）condition实现的原理？"><a href="#（2）condition实现的原理？" class="headerlink" title="（2）condition实现的原理？"></a>（2）condition实现的原理？</h4><h4 id="20-线程同步和互斥"><a href="#20-线程同步和互斥" class="headerlink" title="20.线程同步和互斥"></a>20.线程同步和互斥</h4><blockquote>
<ul>
<li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li>
<li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li>
<li>互斥是一种特殊的同步。</li>
</ul>
</blockquote>
<h4 id="21-Java如何实现原子操作？"><a href="#21-Java如何实现原子操作？" class="headerlink" title="21.Java如何实现原子操作？"></a>21.Java如何实现原子操作？</h4><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p>
<h4 id="22-Java中AutomicInteger如何实现的？"><a href="#22-Java中AutomicInteger如何实现的？" class="headerlink" title="22.Java中AutomicInteger如何实现的？"></a>22.Java中AutomicInteger如何实现的？</h4><blockquote>
<p>总结一下，AtomicInteger 中主要实现了整型的原子操作，防止并发情况下出现异常结果，其内部主要依靠JDK 中的unsafe  类操作内存中的数据来实现的。volatile 修饰符保证了value在内存中其他线程可以看到其值得改变。CAS操作保证了AtomicInteger 可以安全的修改value 的值。</p>
</blockquote>
<h4 id="23-HashMap为何可能出现环？"><a href="#23-HashMap为何可能出现环？" class="headerlink" title="23.HashMap为何可能出现环？"></a>23.HashMap为何可能出现环？</h4><blockquote>
<p><a href="https://blog.csdn.net/hhx0626/article/details/54024222" target="_blank" rel="noopener">https://blog.csdn.net/hhx0626/article/details/54024222</a></p>
</blockquote>
<h4 id="24-为什么要使用线程池？"><a href="#24-为什么要使用线程池？" class="headerlink" title="24.为什么要使用线程池？"></a>24.为什么要使用线程池？</h4><ul>
<li>b降低资源消耗。 通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提⾼响应速度。 当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。</li>
<li>提⾼线程的可管理性。 线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * returns workersExecutorService.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * returns the service stored in the appContext or creates it if</span></span><br><span class="line"><span class="comment"> * necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ExecutorService for the &#123;<span class="doctag">@code</span> SwingWorkers&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">getWorkersExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppContext appContext = AppContext.getAppContext();</span><br><span class="line">    ExecutorService executorService =</span><br><span class="line">        (ExecutorService) appContext.get(SwingWorker.class);</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//this creates daemon threads.</span></span><br><span class="line">        ThreadFactory threadFactory =</span><br><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="keyword">final</span> ThreadFactory defaultFactory =</span><br><span class="line">                    Executors.defaultThreadFactory();</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">                    Thread thread =</span><br><span class="line">                        defaultFactory.newThread(r);</span><br><span class="line">                    thread.setName(<span class="string">"SwingWorker-"</span></span><br><span class="line">                        + thread.getName());</span><br><span class="line">                    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> thread;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        executorService =</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor(MAX_WORKER_THREADS, MAX_WORKER_THREADS,</span><br><span class="line">                                   <span class="number">10L</span>, TimeUnit.MINUTES,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line">        appContext.put(SwingWorker.class, executorService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't use ShutdownHook here as it's not enough. We should track</span></span><br><span class="line">        <span class="comment">// AppContext disposal instead of JVM shutdown, see 6799345 for details</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService es = executorService;</span><br><span class="line">        appContext.addPropertyChangeListener(AppContext.DISPOSED_PROPERTY_NAME,</span><br><span class="line">            <span class="keyword">new</span> PropertyChangeListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">propertyChange</span><span class="params">(PropertyChangeEvent pce)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">boolean</span> disposed = (Boolean)pce.getNewValue();</span><br><span class="line">                    <span class="keyword">if</span> (disposed) &#123;</span><br><span class="line">                        <span class="keyword">final</span> WeakReference&lt;ExecutorService&gt; executorServiceRef =</span><br><span class="line">                            <span class="keyword">new</span> WeakReference&lt;ExecutorService&gt;(es);</span><br><span class="line">                        <span class="keyword">final</span> ExecutorService executorService =</span><br><span class="line">                            executorServiceRef.get();</span><br><span class="line">                        <span class="keyword">if</span> (executorService != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            AccessController.doPrivileged(</span><br><span class="line">                                <span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        executorService.shutdown();</span><br><span class="line">                                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="25-如何线程安全的实现一个计数器？"><a href="#25-如何线程安全的实现一个计数器？" class="headerlink" title="25.如何线程安全的实现一个计数器？"></a>25.如何线程安全的实现一个计数器？</h4><h4 id="26-volatile关键字？"><a href="#26-volatile关键字？" class="headerlink" title="26.volatile关键字？"></a>26.volatile关键字？</h4><p>参考：volatile: <a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">http://ifeve.com/volatile/</a></p>
<p>Java语言规范第三版中对volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p>
<ul>
<li>Java内存模型</li>
<li><span style="color:red"><strong>内存屏障</strong></span></li>
</ul>
<h4 id="27-Thread-类中的start-和-run-方法有什么区别？"><a href="#27-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="27. Thread 类中的start() 和 run() 方法有什么区别？"></a>27. Thread 类中的start() 和 run() 方法有什么区别？</h4><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。</p>
<p><span style="color:red"><strong>当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</strong></span></p>
<blockquote>
<p>创建线程的方式：</p>
<p>方式1：继承Java.lang.Thread类，并覆盖run() 方法。<br>     优势：编写简单；<br>     劣势：单继承的限制——无法继承其它父类，同时不能实现资源共享。</p>
<p>方式2：实现Java.lang.Runnable接口，并实现run()方法。<br>     优势：可继承其它类，多线程可共享同一个Thread对象；<br>     劣势：编程方式稍微复杂，如需访问当前线程，需调用Thread.currentThread()方法</p>
</blockquote>
<h4 id="28-线程池大小"><a href="#28-线程池大小" class="headerlink" title="28. 线程池大小"></a>28. 线程池大小</h4><ul>
<li><strong>计算密集型：</strong>为什么是核心数+1？对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)</li>
<li><strong>IO密集型：</strong>核心数*2</li>
</ul>
<h4 id="29-什么是可重入锁？实现的原理是什么？"><a href="#29-什么是可重入锁？实现的原理是什么？" class="headerlink" title="29. 什么是可重入锁？实现的原理是什么？"></a>29. 什么是可重入锁？实现的原理是什么？</h4><p>是什么：当一个线程需要获取一个被其他线程锁持有的独占锁的时候，会被阻塞。当一个线程需要获取到自己已经持有的锁的时候是否也会被阻塞呢？如果不被阻塞，那么我们说这个锁是可以重入的，也就是说这个线程获取了这个锁就可以无限次（严格来说是有限次）进入被锁定的代码。</p>
<p>实现的原理：可重入锁实现的原理就是内部维护一个线程标识，使用这个标识来确定当前的锁被哪一个线程占用，然后还需要关联一个计数器。一开始，这个计数器为0，说明这个锁没有被任何线程占用。当一个线程获取到这个锁的时候，计数器的值将会加一，其他线程过来的时候发现持有锁的线程不是自己而被阻塞。如果发现是自己，计数器将会被加一，当释放计数器的时候减一，当计数器为零的时候，锁里面的线程标识重置为null。</p>
<h4 id="30-生产者和消费者问题？"><a href="#30-生产者和消费者问题？" class="headerlink" title="30. 生产者和消费者问题？"></a>30. 生产者和消费者问题？</h4><p>生产者生产满了就阻塞，消费者消费完了就阻塞，notify和notifyAll是如何实现的？</p>
<p>使用Condition去唤醒不同的队列？</p>
<h4 id="31-ABCABC问题"><a href="#31-ABCABC问题" class="headerlink" title="31. ABCABC问题"></a>31. ABCABC问题</h4><p>使用Condition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tset</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argc)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 思路：三个线程。三个不同的队列Condition，A唤醒B，B唤醒C，C唤醒A</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">"Thread A"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">"Thread B"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;, <span class="string">"Thread C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps: t.start()会导致run()方法被调用，run()方法中的内容称为线程体，它就是这个线程需要执行的工作。</p>
<p>用start()来启动线程，实现了真正意义上的启动线程，此时会出现异步执行的效果，即在线程的创建和启动中所述的随机性。而如果使用run()来启动线程，就不是异步执行了，而是同步执行，不会达到使用线程的意义.</p>
</blockquote>
<h4 id="32-有多个任务，一个执行错误，其他都取消（分布式事务）"><a href="#32-有多个任务，一个执行错误，其他都取消（分布式事务）" class="headerlink" title="32. 有多个任务，一个执行错误，其他都取消（分布式事务）"></a>32. 有多个任务，一个执行错误，其他都取消（分布式事务）</h4><h4 id="33-ReentrantLock"><a href="#33-ReentrantLock" class="headerlink" title="33. ReentrantLock"></a>33. ReentrantLock</h4><h5 id="33-0-重点"><a href="#33-0-重点" class="headerlink" title="33.0 重点"></a>33.0 重点</h5><p><span style="color:red">(1)类图，(2)state, (3)子类实现，(4)ConditionObject</span></p>
<p>lock()——-&gt;compareAndSetState——&gt;setExclusiveOwnerThread</p>
<p>​         ———&gt;acquire———&gt;tryAcquire———&gt;acquireQueued（这个方法里有死循环）</p>
<p>lock锁缓存行</p>
<h5 id="33-1-如何实现互斥的？"><a href="#33-1-如何实现互斥的？" class="headerlink" title="33.1 如何实现互斥的？"></a>33.1 如何实现互斥的？</h5><p>使用cas操作state.</p>
<h5 id="33-2-如何和实现重入的？"><a href="#33-2-如何和实现重入的？" class="headerlink" title="33.2 如何和实现重入的？"></a>33.2 如何和实现重入的？</h5><p>使用cas操作AQS的state，如果是当前锁的持有者，state会增加，表示重入的次数，如果哦不是当前线程的持有者，当前线程会被挂起放入到AQS队列中阻塞。</p>
<h5 id="33-3阻塞队列是不是公平的？"><a href="#33-3阻塞队列是不是公平的？" class="headerlink" title="33.3阻塞队列是不是公平的？"></a>33.3阻塞队列是不是公平的？</h5><h4 id="34-Disruptor"><a href="#34-Disruptor" class="headerlink" title="34. Disruptor"></a>34. Disruptor</h4><ul>
<li>环形队列</li>
</ul>
<h4 id="35-Condition"><a href="#35-Condition" class="headerlink" title="35. Condition"></a>35. Condition</h4><ul>
<li>使用condition的步骤：<span style="color:red">lock.newCondition</span>创建condition对象，获取锁，然后调用condition的方法</li>
<li>一个ReentrantLock支持多个condition对象</li>
<li>void await() throws InterruptedException;方法会释放锁，让当前线程等待，支持唤醒，支持线程中断</li>
<li>void awaitUninterruptibly();方法会释放锁，让当前线程等待，支持唤醒，不支持线程中断</li>
<li>long awaitNanos(long nanosTimeout) throws InterruptedException;参数为纳秒，此方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为负数；超时之前返回的，结果为正数（表示返回时距离超时时间相差的纳秒数）</li>
<li>boolean await(long time, TimeUnit unit) throws InterruptedException;方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为false；超时之前返回的，结果为true</li>
<li>boolean awaitUntil(Date deadline) throws InterruptedException;参数表示超时的截止时间点，方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为false；超时之前返回的，结果为true</li>
<li>void signal();会唤醒一个等待中的线程，然后被唤醒的线程会被加入同步队列，去尝试获取锁</li>
<li>void signalAll();会唤醒所有等待中的线程，将所有等待中的线程加入同步队列，然后去尝试获取锁</li>
</ul>
<h4 id="36-LockSupport类介绍"><a href="#36-LockSupport类介绍" class="headerlink" title="36. LockSupport类介绍"></a>36. LockSupport类介绍</h4><h5 id="36-1-原理"><a href="#36-1-原理" class="headerlink" title="36.1 原理"></a>36.1 原理</h5><p>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程。主要是通过<strong>park()</strong>和<strong>unpark(thread)</strong>方法来实现阻塞和唤醒线程的操作的。</p>
<p>每个线程都有一个许可(permit)，<strong>permit</strong>只有两个值<strong>1</strong>和<strong>0</strong>，默认是0。</p>
<ul>
<li>当调用unpark(thread)方法，就会将thread线程的许可permit设置成1(<strong>注意多次调用unpark</strong>方法，不会累加，permit值还是1**)。</li>
<li>当调用park()方法，如果当前线程的permit是1，那么将permit设置为0，并立即返回。如果当前线程的permit是0，那么当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为0，并返回。</li>
</ul>
<blockquote>
<p>注意：因为permit默认是0，所以一开始调用park()方法，线程必定会被阻塞。调用unpark(thread)方法后，会自动唤醒thread线程，即park方法立即返回。</p>
</blockquote>
<h5 id="36-2-LockSupport中常用的方法"><a href="#36-2-LockSupport中常用的方法" class="headerlink" title="36.2 LockSupport中常用的方法"></a>36.2 LockSupport中常用的方法</h5><ul>
<li><p><strong>阻塞线程</strong></p>
<p>•       void park()：阻塞当前线程，如果调用<strong>unpark**</strong>方法<strong>或者</strong>当前线程被中断**，从能从park()方法中返回</p>
<p>•       void park(Object blocker)：功能同方法1，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</p>
<p>•       void parkNanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性</p>
<p>•       void parkNanos(Object blocker, long nanos)：功能同方法3，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</p>
<p>•       void parkUntil(long deadline)：阻塞当前线程，直到deadline，deadline是一个绝对时间，表示某个时间的毫秒格式</p>
<p>•       void parkUntil(Object blocker, long deadline)：功能同方法5，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</p>
</li>
<li><p><strong>唤醒线程</strong></p>
<p>•       void unpark(Thread thread):唤醒处于阻塞状态的指定线程</p>
</li>
</ul>
<h4 id="37-线程唤醒的方法"><a href="#37-线程唤醒的方法" class="headerlink" title="37.线程唤醒的方法"></a>37.线程唤醒的方法</h4><ul>
<li>方式1：Object中的wait、notify、notifyAll方法</li>
<li>方式2：juc中Condition接口提供的await、signal、signalAll方法</li>
<li>方式3：juc中的LockSupport提供的park、unpark方法</li>
</ul>
<p><strong>3种方式对比：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Object</th>
<th>Condtion</th>
<th>LockSupport</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置条件</td>
<td>需要在synchronized中运行</td>
<td>需要先获取Lock的锁</td>
<td>无</td>
</tr>
<tr>
<td>无限等待</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>超时等待</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>等待到将来某个时间返回</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>等待状态中释放锁</td>
<td>会释放</td>
<td>会释放</td>
<td>不会释放</td>
</tr>
<tr>
<td>唤醒方法先于等待方法执行，能否唤醒线程</td>
<td>否</td>
<td>否</td>
<td>可以</td>
</tr>
<tr>
<td>是否能响应线程中断</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>线程中断是否会清除中断标志</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否支持等待状态中不响应中断</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<h4 id="38-并发队列"><a href="#38-并发队列" class="headerlink" title="38. 并发队列"></a>38. 并发队列</h4><p><img src="/2019/11/20/Java总结-2/并发队列.png" alt=""></p>
<p><strong>线程池阻塞队列的设置：</strong></p>
<ul>
<li><strong>无界队列</strong></li>
</ul>
<p>队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而楼主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p>
<ul>
<li><strong>有界队列</strong></li>
</ul>
<p>常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。<br>使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p>
<p>在我们的修复方案中，选择的就是这个类型的队列，虽然会有部分任务被丢失，但是我们线上是排序日志搜集任务，所以对部分对丢失是可以容忍的。</p>
<ul>
<li><strong>同步移交队列</strong></li>
</ul>
<p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p>
<p><strong><span style="color:red">Summary of BlockingQueue methods</span></strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><em>Throws exception</em></th>
<th><em>Special value</em></th>
<th><em>Blocks</em></th>
<th><em>Times out</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Insert</strong></td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td><strong>Remove</strong></td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td><strong>Examine</strong></td>
<td>element()</td>
<td>peek()</td>
<td><em>not applicable</em></td>
<td><em>not applicable</em></td>
</tr>
</tbody>
</table>
</div>
<h3 id="（四）JVM"><a href="#（四）JVM" class="headerlink" title="（四）JVM"></a>（四）JVM</h3><h4 id="1-虚拟机的参数"><a href="#1-虚拟机的参数" class="headerlink" title="1.虚拟机的参数"></a>1.虚拟机的参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">-XX:PrintFlagsInitial</td>
<td style="text-align:left">打印默认的配置信息</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">-Xms8m</td>
<td style="text-align:left">堆空间8m</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">-Xmx8x</td>
<td style="text-align:left">堆空间最大8m</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">-XX:MaxDirectMemorySize=5m</td>
<td style="text-align:left">最大直接内存5m</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</td>
<td style="text-align:left">指定元空间的大小8m</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">-XX:MaxTenuringThreshold</td>
<td style="text-align:left">对象晋升到老年代的年龄阈值</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">-XX:PreBlockSpin</td>
<td style="text-align:left"><strong>自旋次数的默认值是10次</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-JVM内存区域（运行时数据区）"><a href="#2-JVM内存区域（运行时数据区）" class="headerlink" title="2.JVM内存区域（运行时数据区）"></a>2.JVM内存区域（运行时数据区）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">功能</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">堆<br><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/heap.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left">主要用于存放新创建的对象 (所有对象都在这里分配内存)</td>
<td style="text-align:left">jdk1.8之后永久代被替换成为了元空间（Metaspace）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">方法区</td>
<td style="text-align:left">被虚拟机加载的类信息(版本、字段、方法、接口)、常量、静态变量、即时编译器编译后的代码等数据（加常静即）</td>
<td style="text-align:left">运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）方法中的基本类型本地变量将直接存储在工作内存的栈帧结构中；</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">虚拟机栈（线程私有）</td>
<td style="text-align:left">动态链接，方法出口，操作数栈，局部变量表（动方操局）</td>
<td style="text-align:left">每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">本地方法栈（线程私有）</td>
<td style="text-align:left"></td>
<td style="text-align:left">区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">程序计数器（线程私有）</td>
<td style="text-align:left"></td>
<td style="text-align:left">程序计数器主要有下面两个作用：（1）字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。在多线程的情况下，（2）程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</td>
</tr>
</tbody>
</table>
</div>
<p>堆的细节信息（使用虚拟机参数-XX:+PrintGCDetails）</p>
<blockquote>
<p>Heap PSYoungGen      total 74752K, used 3871K [0x000000076d180000, 0x0000000772480000, 0x00000007c0000000) eden space 64512K, 6% used [0x000000076d180000,0x000000076d547c70,0x0000000771080000) from space 10240K, 0% used [0x0000000771a80000,0x0000000771a80000,0x0000000772480000) to   space 10240K, 0% used [0x0000000771080000,0x0000000771080000,0x0000000771a80000) ParOldGen       total 171008K, used 0K [0x00000006c7400000, 0x00000006d1b00000, 0x000000076d180000) object space 171008K, 0% used [0x00000006c7400000,0x00000006c7400000,0x00000006d1b00000) Metaspace       used 3009K, capacity 4496K, committed 4864K, reserved 1056768K class space    used 330K, capacity 388K, committed 512K, reserved 1048576K</p>
<blockquote>
<p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。</p>
</blockquote>
</blockquote>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/jmm-and-memory.png" alt="img"></p>
<h4 id="3-直接内存也会爆出OutOfMemoryError"><a href="#3-直接内存也会爆出OutOfMemoryError" class="headerlink" title="3.直接内存也会爆出OutOfMemoryError"></a>3.直接内存也会爆出OutOfMemoryError</h4><blockquote>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</p>
<p>JDK1.4中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。（demo：修改虚拟机参数，使用allocateDirect方法直接分配直接内存的空间）</p>
</blockquote>
<h4 id="4-对象的创建过程？"><a href="#4-对象的创建过程？" class="headerlink" title="4.对象的创建过程？"></a>4.对象的创建过程？</h4><p>加分初设执, 双亲委派模型</p>
<h5 id="（1）类加载检查"><a href="#（1）类加载检查" class="headerlink" title="（1）类加载检查"></a>（1）类加载检查</h5><blockquote>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<blockquote>
<p>类加载过程（加验准解初）</p>
<ul>
<li>加载<span style="color:red">  protected Class&lt;?&gt; loadClass</span>(String name, boolean resolve)是线程安全的！<ul>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的Class 对象,作为方法区这些数据的访问入口</li>
</ul>
</li>
<li>验证（文元字符）<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
<li>准备：准备阶段是正式为类变量<span style="color:red">分配内存</span>并<span style="color:red">设置类变量初始值</span>的阶段</li>
<li>解析：解析阶段是虚拟机将<span style="color:red">常量池内的符号引用</span>替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</li>
<li>初始化：初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code>方法的过程。</li>
</ul>
</blockquote>
<p>加载器</p>
<blockquote>
<ul>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li>
</ul>
<blockquote>
<p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。<strong>加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。</strong>当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/shuangqinweipai.png?lastModify=1574234543" alt="img"></p>
<p>双亲委派模型保证了Java程序的稳定运行，<strong>可以避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<strong>也保证了 Java 的核心 API 不被篡改。</strong>如果不用没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="（2）分配内存"><a href="#（2）分配内存" class="headerlink" title="（2）分配内存"></a>（2）分配内存</h5><blockquote>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong>两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
</blockquote>
<h5 id="（3）初始化零值"><a href="#（3）初始化零值" class="headerlink" title="（3）初始化零值"></a>（3）初始化零值</h5><blockquote>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
</blockquote>
<h5 id="（4）设置对象头"><a href="#（4）设置对象头" class="headerlink" title="（4）设置对象头"></a>（4）设置对象头</h5><p>（元数据信息，对象的哈希码，对象的GC分代信息）</p>
<blockquote>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，<span style="color:red">如是否启用偏向锁等，对象头会有不同的设置方式。</span></p>
</blockquote>
<h5 id="（5）执行init方法"><a href="#（5）执行init方法" class="headerlink" title="（5）执行init方法"></a>（5）执行init方法</h5><blockquote>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</blockquote>
<h4 id="5-JVM常见面试题"><a href="#5-JVM常见面试题" class="headerlink" title="5.JVM常见面试题"></a>5.JVM常见面试题</h4><h4 id="（1）如何判断对象是否死亡（两种方法）"><a href="#（1）如何判断对象是否死亡（两种方法）" class="headerlink" title="（1）如何判断对象是否死亡（两种方法）?"></a>（1）如何判断对象是否死亡（两种方法）?</h4><blockquote>
<ul>
<li>引用计数法（和引用有关系）</li>
</ul>
<blockquote>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
</blockquote>
<ul>
<li>可达性分析（和引用有关系）</li>
</ul>
<blockquote>
<p>这个算法的基本思想就是通过一系列的称为GC Roots的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
</blockquote>
</blockquote>
<h4 id="（2）简单的介绍一下强引用、软引用、弱引用、虚引用"><a href="#（2）简单的介绍一下强引用、软引用、弱引用、虚引用" class="headerlink" title="（2）简单的介绍一下强引用、软引用、弱引用、虚引用"></a>（2）简单的介绍一下强引用、软引用、弱引用、虚引用</h4><ul>
<li>强引用</li>
</ul>
<blockquote>
<p>我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
</blockquote>
<ul>
<li>软引用</li>
</ul>
<blockquote>
<p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
</blockquote>
<ul>
<li>弱引用</li>
</ul>
<blockquote>
<p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<ul>
<li>虚引用</li>
</ul>
<blockquote>
<p>与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
</blockquote>
<h4 id="（3）如何判断一个常量是废弃常量"><a href="#（3）如何判断一个常量是废弃常量" class="headerlink" title="（3）如何判断一个常量是废弃常量?"></a>（3）如何判断一个常量是废弃常量?</h4><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>
<h4 id="（4）如何判断一个类是无用的类"><a href="#（4）如何判断一个类是无用的类" class="headerlink" title="（4）如何判断一个类是无用的类?"></a>（4）如何判断一个类是无用的类?</h4><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。(双亲委派模型)</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h4 id="（5）垃圾收集有哪些算法，各自的特点？"><a href="#（5）垃圾收集有哪些算法，各自的特点？" class="headerlink" title="（5）垃圾收集有哪些算法，各自的特点？"></a>（5）垃圾收集有哪些算法，各自的特点？</h4><ul>
<li>复制算法</li>
</ul>
<blockquote>
<p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
</blockquote>
<ul>
<li>标记清除</li>
</ul>
<blockquote>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<blockquote>
<p><strong>效率问题</strong></p>
<p>空间问题（标记清除后会产生大量不连续的碎片）</p>
</blockquote>
</blockquote>
<ul>
<li>标记整理</li>
</ul>
<blockquote>
<p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
</blockquote>
<ul>
<li>分代</li>
</ul>
<h4 id="（6）HotSpot-为什么要分为新生代和老年代？"><a href="#（6）HotSpot-为什么要分为新生代和老年代？" class="headerlink" title="（6）HotSpot 为什么要分为新生代和老年代？"></a>（6）HotSpot 为什么要分为新生代和老年代？</h4><blockquote>
<p>根据对象存活周期的不同将内存分为几块。一般将 java 堆分为<strong>新生代和老年代</strong>，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
</blockquote>
<p>分代收集算法（HotSpot 虚拟机 GC 采用分代收集算法）</p>
<p>根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，根据年代的特点来选择最佳的收集算法。</p>
<ul>
<li>新生代：复制算法</li>
<li>老年代：标记-整理算法</li>
</ul>
<p>堆大小=新生代+老年代（默认分别占堆空间为1/3、2/3），新生代又被分为Eden、from survivor、to survivor（默认8:1:1）</p>
<p>这样划分是为了更好的管理堆内存中的对象，方便 GC 算法来进行垃圾回收。 </p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/gc-hotspot.png" alt="img"></p>
<p>对象的分配通常在 Eden 中（大对象（需要大量连续内存空间的 Java 对象，如很长的字符串或数据）直接进入老年代，-XX:PretenureSizeThreshold）。</p>
<p>当 Eden 区满后，会触发 Minor GC，把 Eden 区和 from survivor 区中存活的对象进行转移，其中到达年龄（经过多次Minor GC）的会被放入老年代，未到达年龄的放入 to survivor 区。</p>
<p>然后清空 Eden 区和 from survivor 区，交换 from survivor 与 to survivor 的名字。</p>
<p>若存活对象大于 to survivor 区容量，则会被直接放入老年代。若打开了自适应（-XX:+AdaptiveSizePolicy），GC会自动重新调整新生代大小。</p>
<p>若老年代满了，则触发 Full GC。</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/basic/gc-from-to.png" alt="img"></p>
<p><strong>Minor GC vs Major GC/Full GC：</strong></p>
<ul>
<li>Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。</li>
</ul>
<p>在 JVM 规范中，<span style="color:red">Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。</span></p>
<h4 id="（7）常见的垃圾回收器有那些？"><a href="#（7）常见的垃圾回收器有那些？" class="headerlink" title="（7）常见的垃圾回收器有那些？"></a>（7）常见的垃圾回收器有那些？</h4><p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/gc.png?lastModify=1574234543" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">回收器</th>
<th style="text-align:left">算法</th>
<th style="text-align:left">步骤</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Serial 收集器（串行）</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/serial.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left"></td>
<td style="text-align:left">单CPU的client模式</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">ParNew 收集器（并行）</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/parnew.png?lastModify=1574234543" alt="img"></td>
<td style="text-align:left"></td>
<td style="text-align:left">它是许多运行在Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Parallel Scavenge 收集器（并行）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（吞吐量）Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU），后台运行不需要太多交互</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Serial Old 收集器（串行）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">单CPU的client模式，和CMS配合</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">Parallel Old 收集器（并行）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">（吞吐量）后台运行不需要太多交互</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">CMS 收集器（并发）</td>
<td style="text-align:left"><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/cms.png?lastModify=1574234543" alt="img"><br>标记清除</td>
<td style="text-align:left">（1）初始标记<br>（2）并发标记（混合）<br>（3）重新标记<br>（4）并发清除（混合）</td>
<td style="text-align:left">CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验），集中使用在互联网或者B/S系统服务端</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">G1 收集器（并发）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">面向服务端，将来替换CMS</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（8）Minor-Gc-和-Full-GC-有什么不同呢？"><a href="#（8）Minor-Gc-和-Full-GC-有什么不同呢？" class="headerlink" title="（8）Minor Gc 和 Full GC 有什么不同呢？"></a>（8）Minor Gc 和 Full GC 有什么不同呢？</h4><ul>
<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>
<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>
</ul>
<h4 id="（9）什么时候触发FULL-GC？"><a href="#（9）什么时候触发FULL-GC？" class="headerlink" title="（9）什么时候触发FULL GC？"></a>（9）什么时候触发FULL GC？</h4><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。 </p>
<p><strong><span style="color:red">旧生代空间不足</span></strong>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p><strong><span style="color:red">Permanet Generation空间满</span></strong> PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p><strong><span style="color:red">CMS GC时出现promotion failed和concurrent mode failure</span></strong> 对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。 promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。 应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。</p>
<p><strong><span style="color:red">统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</span></strong> 这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。 当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。 除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>
<h4 id="（10）对象分配规则"><a href="#（10）对象分配规则" class="headerlink" title="（10）对象分配规则"></a>（10）对象分配规则</h4><ul>
<li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li>
<li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</li>
<li><span style="color:red">动态判断对象的年龄</span>。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li>
<li><span style="color:red">空间分配担保</span>。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<h4 id="6-JDK-监控和故障处理工具总结"><a href="#6-JDK-监控和故障处理工具总结" class="headerlink" title="6.JDK 监控和故障处理工具总结"></a>6.JDK 监控和故障处理工具总结</h4><p>故障排查：<a href="https://www.cnblogs.com/stateis0/p/9062196.html" target="_blank" rel="noopener">https://www.cnblogs.com/stateis0/p/9062196.html</a></p>
<p>线上 CPU 飚高问题大家应该都遇到过，那么如何定位问题呢？</p>
<blockquote>
<p>思路：首先找到 CPU 飚高的那个 Java 进程，因为你的服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查,如何操作呢？</p>
<ul>
<li>通过 top 命令找到 CPU 消耗最高的进程，并记住进程 ID。</li>
<li>再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID，并记住线程 ID.</li>
<li>通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] &gt;jstack.log。</li>
<li>由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是16进制的，因此我们需要将10进制的转换成16进制的，并用这个线程 ID 在堆栈中查找。使用 printf “%x\n” [十进制数字] ，可以将10进制转换成16进制。</li>
<li>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。</li>
</ul>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">工具</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">jps</td>
<td style="text-align:left">(JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">jinfo</td>
<td style="text-align:left">(Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</td>
<td style="text-align:left">（1）jinfo -flag MaxHeapSize<br></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">jstat</td>
<td style="text-align:left">(JVM Statistics Monitoring Tool):  用于收集 HotSpot 虚拟机各方面的运行数据;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">jmap</td>
<td style="text-align:left">(Memory Map for Java) :生成堆转储快照;</td>
<td style="text-align:left">（1）可以使用-XX:+HeapDumpOnOutOfMemoryError代替<br></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">jhat</td>
<td style="text-align:left">(JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">jstack</td>
<td style="text-align:left">(Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">jconsole</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">javap</td>
<td style="text-align:left">查看字节码</td>
</tr>
</tbody>
</table>
</div>
<h4 id="7-类文件结构（魔文常访当字方属）"><a href="#7-类文件结构（魔文常访当字方属）" class="headerlink" title="7.类文件结构（魔文常访当字方属）"></a>7.类文件结构（魔文常访当字方属）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">数据</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">魔数</td>
<td style="text-align:left">每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Class文件版本</td>
<td style="text-align:left">高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">常量池</td>
<td style="text-align:left">常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。javap -v *.class查看</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">访问标志</td>
<td style="text-align:left">在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">当前类索引，父类索引和接口索引集合</td>
<td style="text-align:left">类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">字段表集合</td>
<td style="text-align:left">字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">方法表集合</td>
<td style="text-align:left">Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">属性表集合</td>
<td style="text-align:left">在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-常量池存放（字面量，符号引用）"><a href="#8-常量池存放（字面量，符号引用）" class="headerlink" title="8.常量池存放（字面量，符号引用）"></a>8.常量池存放（字面量，符号引用）</h4><p>（1）字面量</p>
<blockquote>
<p>字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。</p>
</blockquote>
<p>（2）符号引用(全限定名，描述符)</p>
<blockquote>
<ul>
<li>类和接口的全限定名 </li>
<li>字段的名称和描述符 </li>
<li>方法的名称和描述符</li>
</ul>
</blockquote>
<h4 id="9-自定义加载器-不要轻易覆盖loadClass"><a href="#9-自定义加载器-不要轻易覆盖loadClass" class="headerlink" title="9.自定义加载器(不要轻易覆盖loadClass)"></a>9.自定义加载器(不要轻易覆盖loadClass)</h4><blockquote>
<p>双亲委派模型是为了保证 如果加载的类是一个系统类，那么会优先由Bootstrap ClassLoader 、Extension ClassLoader先去加载，而不是使用我们自定义的ClassLoader去加载，保证系统的安全！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; URLClassLoader v2 = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(v2dir)&#125;);</span><br><span class="line">&gt; Class&lt;?&gt; depv1Class = v1.loadClass(<span class="string">"JavaDemo.VMTest.DiamondDependency.v1.Dep"</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>为什么要自定义ClassLoader？</strong></p>
<blockquote>
<p>因为系统的ClassLoader只会加载指定目录下的class文件,如果你想加载自己的class文件,那么就可以自定义一个ClassLoader。而且我们可以根据自己的需求，对class文件进行加密和解密。有很多字节码加密技术就是依靠定制 ClassLoader 来实现的。<strong>先使用工具对字节码文件进行加密，运行时使用定制的 ClassLoader 先解密文件内容再加载这些解密后的字节码。</strong></p>
</blockquote>
<p><strong>如何自定义ClassLoader？</strong>（findClass———&gt;defineClass———&gt;loadClass）</p>
<blockquote>
<ul>
<li>新建一个类继承自java.lang.ClassLoader,重写它的findClass方法。</li>
<li>将class字节码数组转换为Class类的实例（这点需要和判断一个类是不是没用建立联系）</li>
<li>使用：调用loadClass方法即可（这点要和判断一个类是不是没用建立联系）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> JavaDemo.VMTest.ClassLoaderDemo;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> java.io.*;</span><br><span class="line">&gt; </span><br><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">&gt;  <span class="comment">//指定路径</span></span><br><span class="line">&gt; <span class="keyword">private</span> String path ;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span></span>&#123;</span><br><span class="line">&gt;      path=classPath;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;     * 重写findClass方法</span></span><br><span class="line"><span class="comment">&gt;      * <span class="doctag">@param</span> name 是我们这个类的全路径</span></span><br><span class="line"><span class="comment">&gt;     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">&gt;      * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">&gt;   */</span></span><br><span class="line">&gt;  <span class="meta">@Override</span></span><br><span class="line">&gt;  <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">&gt;      Class log = <span class="keyword">null</span>;</span><br><span class="line">&gt;      <span class="comment">// 获取该class文件字节码数组</span></span><br><span class="line">&gt;      <span class="keyword">byte</span>[] classData = getData();</span><br><span class="line">&gt; </span><br><span class="line">&gt;      <span class="keyword">if</span> (classData != <span class="keyword">null</span>) &#123;</span><br><span class="line">&gt;          <span class="comment">// 将class的字节码数组转换成Class类的实例</span></span><br><span class="line">&gt;          log = defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      <span class="keyword">return</span> log;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;  <span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;      * 将class文件转化为字节码数组</span></span><br><span class="line"><span class="comment">&gt;      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">&gt;   */</span></span><br><span class="line">&gt;  <span class="keyword">private</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">&gt;      File file = <span class="keyword">new</span> File(path);</span><br><span class="line">&gt;      <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">&gt;          FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">&gt;          ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">&gt;          <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;              in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">&gt;              out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">&gt; </span><br><span class="line">&gt;              <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">&gt;              <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">&gt;              <span class="keyword">while</span> ((size = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">&gt;                  out.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">&gt;              &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&gt;              e.printStackTrace();</span><br><span class="line">&gt;          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">&gt;              <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                  in.close();</span><br><span class="line">&gt;              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&gt;                  e.printStackTrace();</span><br><span class="line">&gt;              &#125;</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;          <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&gt;      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">&gt;          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> JavaDemo.VMTest.ClassLoaderDemo;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;      System.out.println(<span class="string">"load Log class successfully"</span>);</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> JavaDemo.VMTest.ClassLoaderDemo;</span><br><span class="line">&gt; </span><br><span class="line">&gt;<span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line">&gt; <span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderMain</span> </span>&#123;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, InvocationTargetException </span>&#123;</span><br><span class="line">&gt;      <span class="comment">//这个类class的路径</span></span><br><span class="line">&gt;     String classPath = <span class="string">"/home/mao/workspace/java/out/production/java/JavaDemo/VMTest/ClassLoaderDemo/Log.class"</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(classPath);</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">//类的全称</span></span><br><span class="line">&gt;      String packageNamePath = <span class="string">"JavaDemo.VMTest.ClassLoaderDemo.Log"</span>;</span><br><span class="line">&gt;     <span class="comment">//加载Log这个class文件</span></span><br><span class="line">&gt;      Class&lt;?&gt; Log = myClassLoader.loadClass(packageNamePath);</span><br><span class="line">&gt;</span><br><span class="line">&gt;      System.out.println(<span class="string">"类加载器是:"</span> + Log.getClassLoader());</span><br><span class="line">&gt;</span><br><span class="line">&gt;      <span class="comment">//利用反射获取main方法</span></span><br><span class="line">&gt;      Method method = Log.getDeclaredMethod(<span class="string">"main"</span>, String[].class);</span><br><span class="line">&gt;      Object object = Log.newInstance();</span><br><span class="line">&gt;      String[] arg = &#123;<span class="string">"ad"</span>&#125;;</span><br><span class="line">&gt;      method.invoke(object, (Object) arg);</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="10-钻石依赖问题"><a href="#10-钻石依赖问题" class="headerlink" title="10.钻石依赖问题"></a>10.钻石依赖问题</h4><blockquote>
<p>项目管理上有一个著名的概念叫着「钻石依赖」，<strong>是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突</strong>。<strong>ClassLoader固然可以解决依赖冲突问题</strong>，不过它也限制了不同软件包的操作界面必须使用反射或接口的方式进行动态调用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.VMTest.DiamondDependency.v1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"v1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.VMTest.DiamondDependency.v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"v2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaDemo.VMTest.DiamondDependency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiamondDependencyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException,</span></span><br><span class="line"><span class="function">            NoSuchMethodException,</span></span><br><span class="line"><span class="function">            IllegalAccessException,</span></span><br><span class="line"><span class="function">            InvocationTargetException,</span></span><br><span class="line"><span class="function">            InstantiationException </span>&#123;</span><br><span class="line">        String v1dir = <span class="string">"file:///home/mao/workspace/java/out/production/java/JavaDemo/VMTest/DiamondDependency/v1/"</span>;</span><br><span class="line">        String v2dir = <span class="string">"file:///home/mao/workspace/java/out/production/java/JavaDemo/VMTest/DiamondDependency/v2/"</span>;</span><br><span class="line">        URLClassLoader v1 = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(v1dir)&#125;);</span><br><span class="line">        URLClassLoader v2 = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(v2dir)&#125;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; depv1Class = v1.loadClass(<span class="string">"JavaDemo.VMTest.DiamondDependency.v1.Dep"</span>);</span><br><span class="line">        Object depv1 = depv1Class.getConstructor().newInstance();</span><br><span class="line">        depv1Class.getMethod(<span class="string">"print"</span>).invoke(depv1);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; depv2Class = v2.loadClass(<span class="string">"JavaDemo.VMTest.DiamondDependency.v2.Dep"</span>);</span><br><span class="line">        Object depv2 = depv2Class.getConstructor().newInstance();</span><br><span class="line">        depv2Class.getMethod(<span class="string">"print"</span>).invoke(depv2);</span><br><span class="line"></span><br><span class="line">        System.out.println(depv1Class.equals(depv2Class));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-JMM"><a href="#11-JMM" class="headerlink" title="11.JMM"></a>11.JMM</h4><blockquote>
<p>Java内存模型简称<strong>JMM</strong>（Java Memory Model），是Java虚拟机所定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异，让java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>具体说来，JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存（Working Memory，实际上是一个虚拟的概念），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问的，变量在程序中的传递，是依赖主存来完成的。</p>
<blockquote>
<p>JMM描述的是一组规则，围绕原子性、有序性和可见性展开；</p>
<blockquote>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/jvm/jmm.png?lastModify=1574234543" alt="img"></p>
<blockquote>
<p>操作：</p>
<blockquote>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态。</li>
<li>unclock（解锁）：作用于主内存的变量，把一个处于锁定的状态释放出来。</li>
<li>read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中</li>
<li>load（载入）：作用于工作内存的变量，把read操作从主内存 得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的                             值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，把一个从执行引擎接收到的值 赋值给工作内存的变量，每当虚拟机遇到一个给变                             量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传递到主内存，以便write操作使用。</li>
<li>write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="12-内存模型三大特性"><a href="#12-内存模型三大特性" class="headerlink" title="12.内存模型三大特性"></a>12.内存模型三大特性</h4><h5 id="1-原子性"><a href="#1-原子性" class="headerlink" title="(1)原子性"></a>(1)原子性</h5><p>Java 内存模型保证了<span style="color:red"> read、write、load、use、assign、store、lock 和 unlock</span> 操作具有原子性</p>
<h5 id="2-可见性"><a href="#2-可见性" class="headerlink" title="(2)可见性"></a>(2)可见性</h5><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种 happen-before 规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。</p>
<h5 id="3-有序性"><a href="#3-有序性" class="headerlink" title="(3)有序性"></a>(3)有序性</h5><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<h4 id="13-先行发生原则-Happen-Before-（可见性保证）"><a href="#13-先行发生原则-Happen-Before-（可见性保证）" class="headerlink" title="13.先行发生原则(Happen-Before)（可见性保证）"></a>13.先行发生原则(Happen-Before)（可见性保证）</h4><p>由于<strong>指令重排序</strong>的存在，两个操作之间有happen-before关系，<strong>并不意味着前一个操作必须要在后一个操作之前执行。仅仅要求前一个操作的执行结果对于后一个操作是可见的，并且前一个操作按顺序</strong>排在第二个操作之前. 内存模型使用先行发生原则在Java内存模型中保证多线程操作<strong>可见性</strong>的机制</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">单一线程原则（程序员顺序规则）</td>
<td style="text-align:left">在一个线程内，在程序前面的操作先行发生于后面的操作。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">管程锁定规则（监视器锁规则）</td>
<td style="text-align:left">一个 unlock（解锁） 操作先行发生于后面对同一个锁的 lock（加锁） 操作。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">volatile 变量规则</td>
<td style="text-align:left">对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">线程启动规则</td>
<td style="text-align:left">Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">线程加入规则</td>
<td style="text-align:left">Thread 对象的结束先行发生于 join() 方法返回。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">线程中断规则</td>
<td style="text-align:left">对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">对象终结规则</td>
<td style="text-align:left">一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">传递性</td>
<td style="text-align:left">如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="14-一个Main方法执行的过程？"><a href="#14-一个Main方法执行的过程？" class="headerlink" title="14. 一个Main方法执行的过程？"></a>14. 一个Main方法执行的过程？</h4><h4 id="15-JVM调优命令"><a href="#15-JVM调优命令" class="headerlink" title="15. JVM调优命令"></a>15. JVM调优命令</h4><p>Sun JDK监控和故障处理命令有<span style="color:red">jps、jstat、jmap、jhat、jstack、jinfo</span>.</p>
<ul>
<li><strong>jps</strong>，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>
<li><strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>
<li><strong>jmap</strong>，JVM Memory Map命令用于生成heap dump文件</li>
<li><strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li>
<li><strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。</li>
<li><strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li>
</ul>
<h3 id="（五）I-O"><a href="#（五）I-O" class="headerlink" title="（五）I/O"></a>（五）I/O</h3><p>资料（<a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-tutorial.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-tutorial.html</a>）</p>
<h4 id="1-InputStream-OutputStream-Reader-Writer？"><a href="#1-InputStream-OutputStream-Reader-Writer？" class="headerlink" title="1.InputStream,OutputStream,Reader,Writer？"></a>1.InputStream,OutputStream,Reader,Writer？</h4><ul>
<li>InputStream,OutputStream:面向字节流</li>
<li>Reader,Writer:面向字符流</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作对象</th>
<th>文件,数组,基本数据类型,缓冲,管道,打印,对象序列化,转化</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1)文件</td>
<td>FileInputStream FileOutputStream FileReader FileWriter</td>
</tr>
<tr>
<td>(2)数组</td>
<td>ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter</td>
</tr>
<tr>
<td>(3)基本数据类型</td>
<td>DataInputStream DataOutputStream</td>
</tr>
<tr>
<td>(4)缓冲</td>
<td>BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter</td>
</tr>
<tr>
<td>(5)管道</td>
<td>PipedInputStream PipedOutputStream PipedReader PipedWriter</td>
</tr>
<tr>
<td>(6)打印</td>
<td>printStream printWriter</td>
</tr>
<tr>
<td>(7)对象序列化</td>
<td>ObjectInputStream ObjectOutputStream</td>
</tr>
<tr>
<td>(8)转化</td>
<td>InputStreamReader OutputStreamWriter</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-I-O相关的概念（如同步-异步，阻塞-非阻塞）"><a href="#2-I-O相关的概念（如同步-异步，阻塞-非阻塞）" class="headerlink" title="2.I/O相关的概念（如同步/异步，阻塞/非阻塞）"></a>2.I/O相关的概念（如同步/异步，阻塞/非阻塞）</h4><p>（1）I/O分类</p>
<ul>
<li>java 中 IO 流分为几种?<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
</li>
<li>Java Io流共涉及40多个类， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
</li>
</ul>
<p>（2）同步/异步，阻塞/非阻塞</p>
<ul>
<li><p>同步/异步（被调用者不会/会直接返回结果）</p>
</li>
<li><p>阻塞/非阻塞（调用者不会/会去做其他的事情，需不需要一直等）</p>
</li>
</ul>
<h4 id="3-Java-NIO和IO之间的区别"><a href="#3-Java-NIO和IO之间的区别" class="headerlink" title="3.Java NIO和IO之间的区别"></a>3.Java NIO和IO之间的区别</h4><p><span style="color:red">IO是面向流的，NIO是面向缓冲区的.</span></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IO流是阻塞的</td>
<td style="text-align:left">NIO流是不阻塞的</td>
</tr>
<tr>
<td style="text-align:left">IO 面向流(Stream oriented)</td>
<td style="text-align:left">NIO 面向缓冲区(Buffer oriented)</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">NIO 通过Channel（通道） 进行读写。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">NIO有选择器，选择器用于使用单个线程处理多个通道。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>（1）面向流和面向缓冲区比较(Stream Oriented vs. Buffer Oriented)</strong></p>
<p>第一个重大差异是IO是面向流的，而NIO是面向缓存区的。这句话是什么意思呢？</p>
<p>Java IO面向流意思是我们每次从流当中读取一个或多个字节。怎么处理读取到的字节是我们自己的事情。他们不会再任何地方缓存。再有就是我们不能在流数据中向前后移动。如果需要向前后移动读取位置，那么我们需要首先为它创建一个缓存区。socket.getOutputStream().write(),  InputStream inputStream = socket.getInputStream();    inputStream.read(data))  这里data可以被指定为一个数组</p>
<p>Java NIO是面向缓冲区的，这有些细微差异。数据是被读取到缓存当中以便后续加工。我们可以在缓存中向向后移动。这个特性<strong>给我们处理数据提供了更大的弹性空间</strong>。当然我们任然需要在使用数据前检查缓存中是否包含我们需要的所有数据。另外需要确保在往缓存中写入数据时避免覆盖了已经写入但是还未被处理的数据。</p>
<p><strong>（2）阻塞和非阻塞IO比较（Blocking vs. No-blocking IO）</strong></p>
<p>​        <strong>Java IO的各种流都是阻塞的。</strong>这意味着一个线程一旦调用了read(),write()方法，那么该线程就被阻塞住了，知道读取到数据或者数据完整写入了。在此期间线程不能做其他任何事情。</p>
<p>​        <strong>Java NIO的非阻塞模式使得线程可以通过channel来读数据</strong>，并且是返回当前已有的数据，或者什么都不返回如果但钱没有数据可读的话。这样一来线程不会被阻塞住，它可以继续向下执行。 NIO提供了与传统BIO模型中的 Socket和 ServerSocket相对应的 SocketChannel和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</p>
<p>​        通常线程在调用非阻塞操作后，会通知处理其他channel上的IO操作。因此一个线程可以管理多个channel的输入输出。</p>
<h4 id="4-NIO和AIO的对比？"><a href="#4-NIO和AIO的对比？" class="headerlink" title="4.NIO和AIO的对比？"></a>4.NIO和AIO的对比？</h4><ul>
<li>NIO是同步非阻塞的，AIO是异步非阻塞的</li>
<li>由于NIO的读写过程依然在应用线程里完成，所以对于那些读写过程时间长的，NIO就不太适合。而AIO的读写过程完成后才被通知，所以AIO能够胜任那些重量级，读写过程长的任务。</li>
</ul>
<p>NIO:<a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-non-blocking-server.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-non-blocking-server.html</a></p>
<h4 id="5-Channel，Buffer-Seletor"><a href="#5-Channel，Buffer-Seletor" class="headerlink" title="5.Channel，Buffer,Seletor?"></a>5.Channel，Buffer,Seletor?</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Channel</th>
<th style="text-align:left">Buffer</th>
<th style="text-align:left">Selector</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FileChannel <br>DatagramChannel <br>SocketChannel <br>ServerSocketChannel</td>
<td style="text-align:left">7种基本类型+MappedBytesBuffer<br>(1) ByteBuffer<br>(2) CharBuffer<br>(3) DoubleBuffer<br>(4) FloatBuffer<br>(5) IntBuffer<br>(6) LongBuffer<br>(7) ShortBuffer</td>
<td style="text-align:left"><img src="/2019/11/20/Java总结-2/overview-selectors.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<h5 id="（1）Channel"><a href="#（1）Channel" class="headerlink" title="（1）Channel"></a>（1）Channel</h5><ul>
<li>FileChanel</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"><span class="comment">// 首先把数据读取到Buffer中</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">    <span class="comment">// 然后调用flip()方法</span></span><br><span class="line">    buf.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">        <span class="comment">// 接着再把数据读取出来。</span></span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
<p>​    在Java NIO中如果一个channel是<strong>FileChannel类型</strong>的，那么他可以直接把数据传输到另一个channel。逐个特性得益于FileChannel包含的<strong>transferTo和transferFrom</strong>两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count    = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<ul>
<li>SocketChannel</li>
</ul>
<p>​        在Java NIO体系中，SocketChannel是用于TCP网络连接的套接字接口，相当于Java网络编程中的Socket套接字接口。创建SocketChannel主要有两种方式，如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>打开一个SocketChannel并连接网络上的一台服务器。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>当ServerSocketChannel接收到一个连接请求时，会创建一个SocketChannel。</strong></td>
</tr>
</tbody>
</table>
</div>
<p>​        在Java NIO中，ServerSocketChannel是用于监听TCP链接请求的通道，正如Java网络编程中的ServerSocket一样。ServerSocketChannel实现类位于java.nio.channels包下面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bin(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">  <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="（2）Buffer"><a href="#（2）Buffer" class="headerlink" title="（2）Buffer"></a>（2）Buffer</h5><p>​        <strong>Java NIO Buffers</strong>用于和<strong>NIO Channel</strong>交互。我们从channel中读取数据到buffers里，从buffer把数据写入到channels. buffer本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。</p>
<p><strong>利用Buffer读写数据，通常遵循四个步骤：</strong></p>
<ul>
<li><p>把数据写入buffer；</p>
</li>
<li><p>调用flip；</p>
</li>
<li><p>从Buffer中读取数据；</p>
</li>
<li><p>调用buffer.clear()或者buffer.compact()</p>
<p>Java NIO发布时内置了对<strong>scatter / gather</strong>的支持。scatter / gather是通过通道读写数据的两个概念。</p>
<p>| <img src="/2019/11/20/Java总结-2/scatter.png" alt=""> | <img src="/2019/11/20/Java总结-2/gather.png" alt=""> |<br>| :————————————-: | :————————————: |<br>|         <strong>Scatter</strong>         |         <strong>Gather</strong>         |</p>
</li>
</ul>
<h5 id="（3）Selector"><a href="#（3）Selector" class="headerlink" title="（3）Selector"></a>（3）Selector</h5><p>​    Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。<strong>如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册Channel到Selector上</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 四种就绪状态用SelectionKey中的常量表示如下：</span></span><br><span class="line"><span class="comment">* SelectionKey.OP_CONNECT</span></span><br><span class="line"><span class="comment">* SelectionKey.OP_ACCEPT</span></span><br><span class="line"><span class="comment">* SelectionKey.OP_READ</span></span><br><span class="line"><span class="comment">* SelectionKey.OP_WRITE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.selectNow();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-Java-NIO-Channel通道和流的区别"><a href="#6-Java-NIO-Channel通道和流的区别" class="headerlink" title="6.Java NIO Channel通道和流的区别"></a>6.Java NIO Channel通道和流的区别</h4><ul>
<li>通道可以读也可以写，流一般来说是单向的（只能读或者写）。</li>
<li>通道可以异步读写。</li>
<li>通道总是基于缓冲区Buffer来读写。</li>
</ul>
<h4 id="7-SocketChannel-ServerSocketChannel"><a href="#7-SocketChannel-ServerSocketChannel" class="headerlink" title="7.SocketChannel ,  ServerSocketChannel"></a>7.SocketChannel ,  ServerSocketChannel</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">SocketChannel</th>
<th style="text-align:left">ServerSocketChannel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">方法</td>
<td style="text-align:left">open();    close();    write();      read();     connect();</td>
<td style="text-align:left">open();     close();     accept();</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-AsynchronousChannel-提前返回"><a href="#8-AsynchronousChannel-提前返回" class="headerlink" title="8.AsynchronousChannel(提前返回)"></a>8.<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/AsynchronousChannel.html" target="_blank" rel="noopener">AsynchronousChannel</a>(提前返回)</h4><p>(1)read</p>
<ul>
<li>第一种方式（使用CompletionHandler）</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_read_1.png?lastModify=1574234543" alt="img"></p>
<ul>
<li>第二种方式（使用Future）</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_read_2.png?lastModify=1574234543" alt="img"></p>
<p>(2)write</p>
<ul>
<li>第一种方式（使用CompletionHandler）</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_write_1.png?lastModify=1574234543" alt="img"></p>
<ul>
<li>第二种方式（使用Future）</li>
</ul>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/aio_write_2.png?lastModify=1574234543" alt="img"></p>
<h4 id="9-什么是Java序列化，如何实现Java序列化？"><a href="#9-什么是Java序列化，如何实现Java序列化？" class="headerlink" title="9.什么是Java序列化，如何实现Java序列化？"></a>9.什么是Java序列化，如何实现Java序列化？</h4><blockquote>
<p>（1）含义：（扯一点Python相关）</p>
<blockquote>
<p>序列化：把对象转换为字节序列的过程称为对象的序列化。 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p>
</blockquote>
<p>（2）实现：import java.io.Serializable;(注意：这个接口只用来标示，并没有实际的字段和方法)</p>
<blockquote>
<blockquote>
<p>The serialization interface has no methods or fields(没有字段和方法)</p>
<ul>
<li>and serves only to identify the semantics of being serializable.</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;<span class="comment">//序列化</span></span><br><span class="line">&gt; &gt; ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"××××文件名"</span>)));</span><br><span class="line">&gt; &gt; oos.writeObject(flyPig);</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;<span class="comment">//反序列化</span></span><br><span class="line">&gt; &gt; ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"××××××文件名"</span>)));</span><br><span class="line">&gt; &gt;FlyPig person = (FlyPig) ois.readObject();</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>transient 修饰的属性，是不会被序列化的。</p>
</blockquote>
<p>（3） serialVersionUID 的作用和用法?</p>
<p><strong>就是在实现这个Serializable 接口的时候，一定要给这个 serialVersionUID 赋值</strong></p>
</blockquote>
<h4 id="10-Java有几种文件拷贝方式？哪一种最高效？"><a href="#10-Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="10.Java有几种文件拷贝方式？哪一种最高效？"></a>10.Java有几种文件拷贝方式？哪一种最高效？</h4><p>(1)利用 java.io 类库，直接为源文件构建一个 <strong>FileInputStream 读取</strong>，然后再为目标文件构建一个FileOutputStream，完成写入工作.</p>
<p><strong>(2)利用 java.nio 类库提供的transferTo 或 transferFrom方法实现。</strong></p>
<p>(3)Java 标准类库本身提供了几种 Files.copy 的实现。（java.nio.file.Files.copy）</p>
<p><img src="https://damaohongtu.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/io/nio_copy.png?lastModify=1574234543" alt="img"></p>
<blockquote>
<p>对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝 和上下文切换。</p>
</blockquote>
<h4 id="11-FileInputStream在使用完以后，不关闭流，想二次使用可以怎么操作？"><a href="#11-FileInputStream在使用完以后，不关闭流，想二次使用可以怎么操作？" class="headerlink" title="11.FileInputStream在使用完以后，不关闭流，想二次使用可以怎么操作？"></a>11.FileInputStream在使用完以后，不关闭流，想二次使用可以怎么操作？</h4><h4 id="12-Reactor-Proactor"><a href="#12-Reactor-Proactor" class="headerlink" title="12.Reactor, Proactor?"></a>12.Reactor, Proactor?</h4><h4 id="13-Netty"><a href="#13-Netty" class="headerlink" title="13.Netty"></a>13.Netty</h4><p>Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对TCP、 UDP 和文件传输的支持，作为一个异步 NIO 框架， Netty 的所有 IO 操作都是异步非阻塞的， 通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。</p>
<h3 id="（六）Java-8"><a href="#（六）Java-8" class="headerlink" title="（六）Java 8"></a>（六）Java 8</h3><h4 id="1-接口的默认方法-Default-Methods-for-Interfaces"><a href="#1-接口的默认方法-Default-Methods-for-Interfaces" class="headerlink" title="1.接口的默认方法(Default Methods for Interfaces)"></a>1.接口的默认方法(Default Methods for Interfaces)</h4><h4 id="2-函数式接口-Functional-Interfaces-FunctionalInterface"><a href="#2-函数式接口-Functional-Interfaces-FunctionalInterface" class="headerlink" title="2.函数式接口(Functional Interfaces)@FunctionalInterface"></a>2.函数式接口(Functional Interfaces)@FunctionalInterface</h4><h4 id="3-Lamda-表达式作用域-Lambda-Scopes"><a href="#3-Lamda-表达式作用域-Lambda-Scopes" class="headerlink" title="3.Lamda 表达式作用域(Lambda Scopes)"></a>3.Lamda 表达式作用域(Lambda Scopes)</h4><h4 id="4-java-util-Stream"><a href="#4-java-util-Stream" class="headerlink" title="4.java.util.Stream"></a>4.java.util.Stream</h4><p>Filter(过滤),  Sorted(排序),  Map(映射) ,  Match(匹配),  Count(计数), Reduce(规约)</p>
<h4 id="5-时间相关"><a href="#5-时间相关" class="headerlink" title="5.时间相关"></a>5.时间相关</h4><h3 id="（七）quartz和timer对比"><a href="#（七）quartz和timer对比" class="headerlink" title="（七）quartz和timer对比"></a>（七）quartz和timer对比</h3><h3 id="（八）RPC"><a href="#（八）RPC" class="headerlink" title="（八）RPC"></a>（八）RPC</h3><p>RPC（Remote Procedure Call）即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？这个时候就需要 RPC 了！ <strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p>
<h4 id="1-设计一个RPC框架"><a href="#1-设计一个RPC框架" class="headerlink" title="1. 设计一个RPC框架"></a>1. 设计一个RPC框架</h4><p>一个完整的 RPC 框架使用示意图如下：</p>
<p><img src="/2019/11/20/Java总结-2/rpc-design.jpeg" alt=""></p>
<h5 id="（1）注册中心"><a href="#（1）注册中心" class="headerlink" title="（1）注册中心"></a>（1）注册中心</h5><p>服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。</p>
<h5 id="（2）网络传输"><a href="#（2）网络传输" class="headerlink" title="（2）网络传输"></a>（2）网络传输</h5><p>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。你也可以使用同步非阻塞的 I/O 模型 <strong>NIO</strong> ，但是用它来进行网络编程真的太麻烦了。基于 NIO 的网络编程框架 Netty ，它将是你最好的选择！</p>
<h5 id="（3）序列化"><a href="#（3）序列化" class="headerlink" title="（3）序列化"></a>（3）序列化</h5><p>要在网络传输数据就要涉及到<strong>序列化</strong> 。所以，我们还要考虑选择哪种<strong>序列化协议</strong>。序列化方式有很多种，比较常见的有 hessian、kyro、protostuff ……。我会在下一篇文章中简单对比一下这些序列化方式。</p>
<h5 id="（4）动态代理"><a href="#（4）动态代理" class="headerlink" title="（4）动态代理"></a>（4）动态代理</h5><p>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求</p>
<h5 id="（5）负载均衡"><a href="#（5）负载均衡" class="headerlink" title="（5）负载均衡"></a>（5）负载均衡</h5><h3 id="（九）Guava"><a href="#（九）Guava" class="headerlink" title="（九）Guava"></a>（九）Guava</h3><h4 id="1-如何实现限流？"><a href="#1-如何实现限流？" class="headerlink" title="1. 如何实现限流？"></a>1. 如何实现限流？</h4>
      
    </div>

    


    
    
    

    
      <div>
         <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    

    
      <div>
        

      </div>
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>我知道是不会有人点的，但万一有人想不开呢？</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="大袤宏图 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="大袤宏图 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/12/诗词曲/" rel="next" title="诗词曲">
                <i class="fa fa-chevron-left"></i> 诗词曲
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/20/Java总结-4/" rel="prev" title="Java总结-4">
                Java总结-4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
		  <!--<div>
  <font color='#FFC0CB' size=20>Mao&Ping Adventure:</font><canvas id="canvasDiyBlock" style="width:60%;">x</canvas>。
</div>
<script>
	/*生成倒计时数字*/
	function getTimeDiff(){
		var date1= '2020/10/04 00:00:00';  //开始时间  
		var date2 = new Date();    //结束时间  
		var date3 = date2.getTime() - new Date(date1).getTime();   //时间差的毫秒数        

		//计算出相差天数  
		var days=Math.floor(date3/(24*3600*1000))  
		//计算出小时数  
		var leave1=date3%(24*3600*1000)    //计算天数后剩余的毫秒数  
		var hours=Math.floor(leave1/(3600*1000))  
		//计算相差分钟数  
		var leave2=leave1%(3600*1000)        //计算小时数后剩余的毫秒数  
		var minutes=Math.floor(leave2/(60*1000))  
		//计算相差秒数  
		var leave3=leave2%(60*1000)      //计算分钟数后剩余的毫秒数  
		var seconds=Math.round(leave3/1000) 
		return ("00000"+days).substr(-5)+":"+("00"+hours).substr(-2)+":"+("00"+minutes).substr(-2)+":"+("00"+seconds).substr(-2)
	}
(function () {
  var digit =
    [
      [
        [0, 0, 1, 1, 1, 0, 0],
        [0, 1, 1, 0, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 0, 1, 1, 0],
        [0, 0, 1, 1, 1, 0, 0]
      ],//0
      [
        [0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1]
      ],//1
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 1, 1, 1, 1, 1]
      ],//2
      [
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//3
      [
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 0],
        [0, 1, 1, 0, 1, 1, 0],
        [1, 1, 0, 0, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 1]
      ],//4
      [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//5
      [
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//6
      [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0]
      ],//7
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//8
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 0, 0, 0, 0]
      ],//9
      [
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]
      ]//:
    ];

  var canvas = document.getElementById('canvasDiyBlock');

  if (canvas.getContext) {
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100, W = 1200;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10, 10, 50, 50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height / 20 - 1;
	var timeDiff = getTimeDiff();
    (function () {
      var temp = /(\d)(\d)(\d)(\d)(\d):(\d)(\d):(\d)(\d):(\d)(\d)/.exec(timeDiff);
      //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
	  // 天(万,千,百,十,个) 小时(十,个) 分钟(十，个) 秒(十 个)
      data.push(temp[1], temp[2], temp[3], temp[4], temp[5], 10, temp[6], temp[7], 10, temp[8], temp[9], 10, temp[10], temp[11]);
    })();
	

    /*生成点阵数字*/
    function renderDigit(index, num) {
      for (var i = 0; i < digit[num].length; i++) {
        for (var j = 0; j < digit[num][i].length; j++) {
          if (digit[num][i][j] == 1) {
            cxt.beginPath();
            cxt.arc(14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1), i * 2 * (R + 1) + (R + 1), R, 0, 2 * Math.PI);
            cxt.closePath();
            cxt.fill();
          }
        }
      }
    }

    /*更新时钟*/
    function updateDigitTime() {
      var changeNumArray = [];
	  var timeDiff = getTimeDiff();
      var temp = /(\d)(\d)(\d)(\d)(\d):(\d)(\d):(\d)(\d):(\d)(\d)/.exec(timeDiff);
      var NewData = [];
      NewData.push(temp[1], temp[2], temp[3], temp[4], temp[5], 10, temp[6], temp[7], 10, temp[8], temp[9], 10, temp[10], temp[11]);

      for (var i = data.length - 1; i >= 0; i--) {
        //时间发生变化
        if (NewData[i] !== data[i]) {
          //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
          changeNumArray.push(i + '_' + (Number(data[i]) + 1) % 10);
        }
      }
      //增加小球
      for (var i = 0; i < changeNumArray.length; i++) {
        addBalls.apply(this, changeNumArray[i].split('_'));
      }
      data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls() {
      for (var i = 0; i < balls.length; i++) {
        balls[i].stepY += balls[i].disY;
        balls[i].x += balls[i].stepX;
        balls[i].y += balls[i].stepY;
        if (balls[i].x > W + R || balls[i].y > H + R) {
          balls.splice(i, 1);
          i--;
        }
      }
    }

    /*增加要运动的小球*/
    function addBalls(index, num) {
      var numArray = [1, 2, 3];
      var colorArray = ["#3BE", "#09C", "#A6C", "#93C", "#9C0", "#690", "#FB3", "#F80", "#F44", "#C00"];
      for (var i = 0; i < digit[num].length; i++) {
        for (var j = 0; j < digit[num][i].length; j++) {
          if (digit[num][i][j] == 1) {
            var ball = {
              x: 14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1),
              y: i * 2 * (R + 1) + (R + 1),
              stepX: Math.floor(Math.random() * 4 - 2),
              stepY: -2 * numArray[Math.floor(Math.random() * numArray.length)],
              color: colorArray[Math.floor(Math.random() * colorArray.length)],
              disY: 1
            };
            balls.push(ball);
          }
        }
      }
    }

    /*渲染*/
    function render() {
      //重置画布宽度，达到清空画布的效果
      canvas.height = 100;
      //渲染时钟
      for (var i = 0; i < data.length; i++) {
        renderDigit(i, data[i]);
      }
      //渲染小球
      for (var i = 0; i < balls.length; i++) {
        cxt.beginPath();
        cxt.arc(balls[i].x, balls[i].y, R, 0, 2 * Math.PI);
        cxt.fillStyle = balls[i].color;
        cxt.closePath();
        cxt.fill();
      }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function () {
      //更新时钟
      updateDigitTime();
      //更新小球状态
      updateBalls();
      //渲染
      render();
    }, 50);
  }
})();
</script>
-->
          <!--

  


-->
        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/boy.jpg"
                alt="大袤宏图" />
            
              <p class="site-author-name" itemprop="name">大袤宏图</p>
              <p class="site-description motion-element" itemprop="description">我尽我力，我尽我心</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/damaoguo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:tianmao818@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Java"><span class="nav-number">1.</span> <span class="nav-text">五、Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（一）基础"><span class="nav-number">1.1.</span> <span class="nav-text">（一）基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-Java对象"><span class="nav-number">1.1.1.</span> <span class="nav-text">0. Java对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#普通对象"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">普通对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-泛型？"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.泛型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-内部类？（成局静匿）"><span class="nav-number">1.1.3.</span> <span class="nav-text">2.内部类？（成局静匿）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-构造器能不能override？"><span class="nav-number">1.1.4.</span> <span class="nav-text">3.构造器能不能override？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-String，StringBulider，StringBuffer？"><span class="nav-number">1.1.5.</span> <span class="nav-text">4.String，StringBulider，StringBuffer？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-static相关？-类，方法，属性，代码块"><span class="nav-number">1.1.6.</span> <span class="nav-text">5.static相关？(类，方法，属性，代码块)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-接口和抽象类的区别？"><span class="nav-number">1.1.7.</span> <span class="nav-text">6.接口和抽象类的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-equals和hashcode？"><span class="nav-number">1.1.8.</span> <span class="nav-text">7.equals和hashcode？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Throwable类？"><span class="nav-number">1.1.9.</span> <span class="nav-text">8.Throwable类？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）结构？"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">（1）结构？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-Throwable"><span class="nav-number">2.</span> <span class="nav-text">Class Throwable</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）常见的异常和错误？"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">（2）常见的异常和错误？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）Throw和Throws的区别？"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">（3）Throw和Throws的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）异常是怎么实现的？"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">（4）异常是怎么实现的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-OutOfMemory详解"><span class="nav-number">2.0.1.</span> <span class="nav-text">9. OutOfMemory详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Collections和Arrays常见的方法？"><span class="nav-number">2.0.2.</span> <span class="nav-text">10.Collections和Arrays常见的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-反射"><span class="nav-number">2.0.3.</span> <span class="nav-text">11.反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何使用反射"><span class="nav-number">2.0.4.</span> <span class="nav-text">如何使用反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-Object方法"><span class="nav-number">2.0.5.</span> <span class="nav-text">12.Object方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-POJO"><span class="nav-number">2.0.6.</span> <span class="nav-text">13.POJO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-hashmap为什么是数组-链表，不是数组-数组"><span class="nav-number">2.0.7.</span> <span class="nav-text">14.hashmap为什么是数组+链表，不是数组+数组?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-数组为什么要连续存放？"><span class="nav-number">2.0.8.</span> <span class="nav-text">15.数组为什么要连续存放？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-包装类和基础类的区别？"><span class="nav-number">2.0.9.</span> <span class="nav-text">16.包装类和基础类的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-Java中-try-catch关闭流的语法糖"><span class="nav-number">2.0.10.</span> <span class="nav-text">17.Java中 try..catch关闭流的语法糖?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-final，finally，finalize？"><span class="nav-number">2.0.11.</span> <span class="nav-text">18.final，finally，finalize？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-面向对象的原则"><span class="nav-number">2.0.12.</span> <span class="nav-text">19.面向对象的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-多态相关"><span class="nav-number">2.0.13.</span> <span class="nav-text">20.多态相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-字符串编码的区别？"><span class="nav-number">2.0.14.</span> <span class="nav-text">21.字符串编码的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-Math-floor-Math-ceil-Math-round"><span class="nav-number">2.0.15.</span> <span class="nav-text">22.Math.floor, Math.ceil,Math.round?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-修饰范围"><span class="nav-number">2.0.16.</span> <span class="nav-text">23.修饰范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-equals和hashcode"><span class="nav-number">2.0.17.</span> <span class="nav-text">24. equals和hashcode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（二）容器"><span class="nav-number">2.1.</span> <span class="nav-text">（二）容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-整体架构"><span class="nav-number">2.1.1.</span> <span class="nav-text">0.整体架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-HashMap？"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.HashMap？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ArrayList的扩容？（扩容为原来的1-5倍）"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.ArrayList的扩容？（扩容为原来的1.5倍）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-HashMap的扩容？（扩容为原来的两倍）"><span class="nav-number">2.1.4.</span> <span class="nav-text">3.HashMap的扩容？（扩容为原来的两倍）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-HashMap和HashTable的区别？"><span class="nav-number">2.1.5.</span> <span class="nav-text">4.HashMap和HashTable的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-HashMap中的Node，及其类型？"><span class="nav-number">2.1.6.</span> <span class="nav-text">5.HashMap中的Node，及其类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ArrayLis实现"><span class="nav-number">2.1.7.</span> <span class="nav-text">6.ArrayLis实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-LinkedList实现"><span class="nav-number">2.1.8.</span> <span class="nav-text">7.LinkedList实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-TreeSet，TreeMap"><span class="nav-number">2.1.9.</span> <span class="nav-text">8.TreeSet，TreeMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（三）并发"><span class="nav-number">2.2.</span> <span class="nav-text">（三）并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Java内存模型？《深入理解Java虚拟机》"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.Java内存模型？《深入理解Java虚拟机》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-单例模式的实现？"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.单例模式的实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-线程的实现方式？怎么使用lambda的形式？"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.线程的实现方式？怎么使用lambda的形式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-线程池"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-为什么要使用线程池？"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">(1) 为什么要使用线程池？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-线程池的架构图"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">(2) 线程池的架构图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Java-并发包提供了哪些并发工具类？"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.Java 并发包提供了哪些并发工具类？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-提供了比-synchronized-更加高级的各种同步结构"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">(1)提供了比 synchronized 更加高级的各种同步结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-各种线程安全的容器"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">(2)各种线程安全的容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-并发队列实现"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">(3)并发队列实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-强大的-Executor-框架"><span class="nav-number">2.2.5.4.</span> <span class="nav-text">(4)强大的 Executor 框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-AQS框架-AbstractQueuedSynchronizer抽象类"><span class="nav-number">2.2.5.5.</span> <span class="nav-text">(5)AQS框架(AbstractQueuedSynchronizer抽象类)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-哪些队列是有界的，哪些是无界的？"><span class="nav-number">2.2.6.</span> <span class="nav-text">6.哪些队列是有界的，哪些是无界的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-生产者-消费者"><span class="nav-number">2.2.7.</span> <span class="nav-text">7.生产者 - 消费者?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-synchronized和lock的区别？用lock的好处？"><span class="nav-number">2.2.8.</span> <span class="nav-text">8.synchronized和lock的区别？用lock的好处？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-JUC主要包含的内容？透彻理解Java并发编程"><span class="nav-number">2.2.9.</span> <span class="nav-text">9.JUC主要包含的内容？透彻理解Java并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）概览"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">（1）概览</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）-并发容器"><span class="nav-number">2.2.9.2.</span> <span class="nav-text">（2） 并发容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）ConcurrentHashMap"><span class="nav-number">2.2.9.3.</span> <span class="nav-text">（3）ConcurrentHashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）原子类"><span class="nav-number">2.2.9.4.</span> <span class="nav-text">（4）原子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）synchronized和ReentrantLock的比较？"><span class="nav-number">2.2.9.5.</span> <span class="nav-text">（5）synchronized和ReentrantLock的比较？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-为什么要使用多线程？"><span class="nav-number">2.2.10.</span> <span class="nav-text">10.为什么要使用多线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-上下文切换？"><span class="nav-number">2.2.11.</span> <span class="nav-text">11.上下文切换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-synchronized-关键字"><span class="nav-number">2.2.12.</span> <span class="nav-text">12.synchronized 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）说一说对synchronized关键字？"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">（1）说一说对synchronized关键字？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）优化"><span class="nav-number">2.2.12.2.</span> <span class="nav-text">（2）优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）sychronized-C-实现源码"><span class="nav-number">2.2.12.3.</span> <span class="nav-text">（3）sychronized C++实现源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）openjdk官方文档jdk-wiki"><span class="nav-number">2.2.12.4.</span> <span class="nav-text">（4）openjdk官方文档jdk wiki</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-CAS"><span class="nav-number">2.2.13.</span> <span class="nav-text">12. CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）ABA问题"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">（1）ABA问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）比较和操作的原子性"><span class="nav-number">2.2.13.2.</span> <span class="nav-text">（2）比较和操作的原子性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）-CAS一直在消耗CPU"><span class="nav-number">2.2.13.3.</span> <span class="nav-text">（3） CAS一直在消耗CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）CAS和synchronized的效率"><span class="nav-number">2.2.13.4.</span> <span class="nav-text">（4）CAS和synchronized的效率</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-UNSAFE"><span class="nav-number">2.2.14.</span> <span class="nav-text">12. UNSAFE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-AQS原理分析（AbstractQueuedSynchronizer）"><span class="nav-number">2.2.15.</span> <span class="nav-text">13.AQS原理分析（AbstractQueuedSynchronizer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-AQS组件"><span class="nav-number">2.2.16.</span> <span class="nav-text">14.AQS组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-AQS对于资源的共享方式"><span class="nav-number">2.2.17.</span> <span class="nav-text">15.AQS对于资源的共享方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-自定义同步器时需要重写下面几个AQS提供的模板方法"><span class="nav-number">2.2.18.</span> <span class="nav-text">16.自定义同步器时需要重写下面几个AQS提供的模板方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-Future和FutureTask的区别？-Future等结果，FutureTask可以被提交"><span class="nav-number">2.2.19.</span> <span class="nav-text">17.Future和FutureTask的区别？(Future等结果，FutureTask可以被提交)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-FutureTask的7种状态"><span class="nav-number">2.2.20.</span> <span class="nav-text">18.FutureTask的7种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-Java中的锁"><span class="nav-number">2.2.21.</span> <span class="nav-text">19.Java中的锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）乐观锁，悲观锁"><span class="nav-number">2.2.22.</span> <span class="nav-text">（1）乐观锁，悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）condition实现的原理？"><span class="nav-number">2.2.23.</span> <span class="nav-text">（2）condition实现的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-线程同步和互斥"><span class="nav-number">2.2.24.</span> <span class="nav-text">20.线程同步和互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-Java如何实现原子操作？"><span class="nav-number">2.2.25.</span> <span class="nav-text">21.Java如何实现原子操作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-Java中AutomicInteger如何实现的？"><span class="nav-number">2.2.26.</span> <span class="nav-text">22.Java中AutomicInteger如何实现的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-HashMap为何可能出现环？"><span class="nav-number">2.2.27.</span> <span class="nav-text">23.HashMap为何可能出现环？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-为什么要使用线程池？"><span class="nav-number">2.2.28.</span> <span class="nav-text">24.为什么要使用线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-如何线程安全的实现一个计数器？"><span class="nav-number">2.2.29.</span> <span class="nav-text">25.如何线程安全的实现一个计数器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-volatile关键字？"><span class="nav-number">2.2.30.</span> <span class="nav-text">26.volatile关键字？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-Thread-类中的start-和-run-方法有什么区别？"><span class="nav-number">2.2.31.</span> <span class="nav-text">27. Thread 类中的start() 和 run() 方法有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-线程池大小"><span class="nav-number">2.2.32.</span> <span class="nav-text">28. 线程池大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-什么是可重入锁？实现的原理是什么？"><span class="nav-number">2.2.33.</span> <span class="nav-text">29. 什么是可重入锁？实现的原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-生产者和消费者问题？"><span class="nav-number">2.2.34.</span> <span class="nav-text">30. 生产者和消费者问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-ABCABC问题"><span class="nav-number">2.2.35.</span> <span class="nav-text">31. ABCABC问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-有多个任务，一个执行错误，其他都取消（分布式事务）"><span class="nav-number">2.2.36.</span> <span class="nav-text">32. 有多个任务，一个执行错误，其他都取消（分布式事务）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-ReentrantLock"><span class="nav-number">2.2.37.</span> <span class="nav-text">33. ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#33-0-重点"><span class="nav-number">2.2.37.1.</span> <span class="nav-text">33.0 重点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33-1-如何实现互斥的？"><span class="nav-number">2.2.37.2.</span> <span class="nav-text">33.1 如何实现互斥的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33-2-如何和实现重入的？"><span class="nav-number">2.2.37.3.</span> <span class="nav-text">33.2 如何和实现重入的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33-3阻塞队列是不是公平的？"><span class="nav-number">2.2.37.4.</span> <span class="nav-text">33.3阻塞队列是不是公平的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-Disruptor"><span class="nav-number">2.2.38.</span> <span class="nav-text">34. Disruptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-Condition"><span class="nav-number">2.2.39.</span> <span class="nav-text">35. Condition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-LockSupport类介绍"><span class="nav-number">2.2.40.</span> <span class="nav-text">36. LockSupport类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#36-1-原理"><span class="nav-number">2.2.40.1.</span> <span class="nav-text">36.1 原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#36-2-LockSupport中常用的方法"><span class="nav-number">2.2.40.2.</span> <span class="nav-text">36.2 LockSupport中常用的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-线程唤醒的方法"><span class="nav-number">2.2.41.</span> <span class="nav-text">37.线程唤醒的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38-并发队列"><span class="nav-number">2.2.42.</span> <span class="nav-text">38. 并发队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（四）JVM"><span class="nav-number">2.3.</span> <span class="nav-text">（四）JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-虚拟机的参数"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.虚拟机的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-JVM内存区域（运行时数据区）"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.JVM内存区域（运行时数据区）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-直接内存也会爆出OutOfMemoryError"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.直接内存也会爆出OutOfMemoryError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-对象的创建过程？"><span class="nav-number">2.3.4.</span> <span class="nav-text">4.对象的创建过程？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）类加载检查"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">（1）类加载检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）分配内存"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">（2）分配内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）初始化零值"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">（3）初始化零值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）设置对象头"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">（4）设置对象头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）执行init方法"><span class="nav-number">2.3.4.5.</span> <span class="nav-text">（5）执行init方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-JVM常见面试题"><span class="nav-number">2.3.5.</span> <span class="nav-text">5.JVM常见面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）如何判断对象是否死亡（两种方法）"><span class="nav-number">2.3.6.</span> <span class="nav-text">（1）如何判断对象是否死亡（两种方法）?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）简单的介绍一下强引用、软引用、弱引用、虚引用"><span class="nav-number">2.3.7.</span> <span class="nav-text">（2）简单的介绍一下强引用、软引用、弱引用、虚引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）如何判断一个常量是废弃常量"><span class="nav-number">2.3.8.</span> <span class="nav-text">（3）如何判断一个常量是废弃常量?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）如何判断一个类是无用的类"><span class="nav-number">2.3.9.</span> <span class="nav-text">（4）如何判断一个类是无用的类?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）垃圾收集有哪些算法，各自的特点？"><span class="nav-number">2.3.10.</span> <span class="nav-text">（5）垃圾收集有哪些算法，各自的特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（6）HotSpot-为什么要分为新生代和老年代？"><span class="nav-number">2.3.11.</span> <span class="nav-text">（6）HotSpot 为什么要分为新生代和老年代？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（7）常见的垃圾回收器有那些？"><span class="nav-number">2.3.12.</span> <span class="nav-text">（7）常见的垃圾回收器有那些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（8）Minor-Gc-和-Full-GC-有什么不同呢？"><span class="nav-number">2.3.13.</span> <span class="nav-text">（8）Minor Gc 和 Full GC 有什么不同呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（9）什么时候触发FULL-GC？"><span class="nav-number">2.3.14.</span> <span class="nav-text">（9）什么时候触发FULL GC？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（10）对象分配规则"><span class="nav-number">2.3.15.</span> <span class="nav-text">（10）对象分配规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-JDK-监控和故障处理工具总结"><span class="nav-number">2.3.16.</span> <span class="nav-text">6.JDK 监控和故障处理工具总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-类文件结构（魔文常访当字方属）"><span class="nav-number">2.3.17.</span> <span class="nav-text">7.类文件结构（魔文常访当字方属）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-常量池存放（字面量，符号引用）"><span class="nav-number">2.3.18.</span> <span class="nav-text">8.常量池存放（字面量，符号引用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-自定义加载器-不要轻易覆盖loadClass"><span class="nav-number">2.3.19.</span> <span class="nav-text">9.自定义加载器(不要轻易覆盖loadClass)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-钻石依赖问题"><span class="nav-number">2.3.20.</span> <span class="nav-text">10.钻石依赖问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-JMM"><span class="nav-number">2.3.21.</span> <span class="nav-text">11.JMM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-内存模型三大特性"><span class="nav-number">2.3.22.</span> <span class="nav-text">12.内存模型三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-原子性"><span class="nav-number">2.3.22.1.</span> <span class="nav-text">(1)原子性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-可见性"><span class="nav-number">2.3.22.2.</span> <span class="nav-text">(2)可见性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-有序性"><span class="nav-number">2.3.22.3.</span> <span class="nav-text">(3)有序性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-先行发生原则-Happen-Before-（可见性保证）"><span class="nav-number">2.3.23.</span> <span class="nav-text">13.先行发生原则(Happen-Before)（可见性保证）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-一个Main方法执行的过程？"><span class="nav-number">2.3.24.</span> <span class="nav-text">14. 一个Main方法执行的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-JVM调优命令"><span class="nav-number">2.3.25.</span> <span class="nav-text">15. JVM调优命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（五）I-O"><span class="nav-number">2.4.</span> <span class="nav-text">（五）I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-InputStream-OutputStream-Reader-Writer？"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.InputStream,OutputStream,Reader,Writer？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-I-O相关的概念（如同步-异步，阻塞-非阻塞）"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.I/O相关的概念（如同步/异步，阻塞/非阻塞）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Java-NIO和IO之间的区别"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.Java NIO和IO之间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-NIO和AIO的对比？"><span class="nav-number">2.4.4.</span> <span class="nav-text">4.NIO和AIO的对比？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Channel，Buffer-Seletor"><span class="nav-number">2.4.5.</span> <span class="nav-text">5.Channel，Buffer,Seletor?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）Channel"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">（1）Channel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）Buffer"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">（2）Buffer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）Selector"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">（3）Selector</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Java-NIO-Channel通道和流的区别"><span class="nav-number">2.4.6.</span> <span class="nav-text">6.Java NIO Channel通道和流的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-SocketChannel-ServerSocketChannel"><span class="nav-number">2.4.7.</span> <span class="nav-text">7.SocketChannel ,  ServerSocketChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-AsynchronousChannel-提前返回"><span class="nav-number">2.4.8.</span> <span class="nav-text">8.AsynchronousChannel(提前返回)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-什么是Java序列化，如何实现Java序列化？"><span class="nav-number">2.4.9.</span> <span class="nav-text">9.什么是Java序列化，如何实现Java序列化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Java有几种文件拷贝方式？哪一种最高效？"><span class="nav-number">2.4.10.</span> <span class="nav-text">10.Java有几种文件拷贝方式？哪一种最高效？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-FileInputStream在使用完以后，不关闭流，想二次使用可以怎么操作？"><span class="nav-number">2.4.11.</span> <span class="nav-text">11.FileInputStream在使用完以后，不关闭流，想二次使用可以怎么操作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-Reactor-Proactor"><span class="nav-number">2.4.12.</span> <span class="nav-text">12.Reactor, Proactor?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-Netty"><span class="nav-number">2.4.13.</span> <span class="nav-text">13.Netty</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（六）Java-8"><span class="nav-number">2.5.</span> <span class="nav-text">（六）Java 8</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-接口的默认方法-Default-Methods-for-Interfaces"><span class="nav-number">2.5.1.</span> <span class="nav-text">1.接口的默认方法(Default Methods for Interfaces)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-函数式接口-Functional-Interfaces-FunctionalInterface"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.函数式接口(Functional Interfaces)@FunctionalInterface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Lamda-表达式作用域-Lambda-Scopes"><span class="nav-number">2.5.3.</span> <span class="nav-text">3.Lamda 表达式作用域(Lambda Scopes)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-java-util-Stream"><span class="nav-number">2.5.4.</span> <span class="nav-text">4.java.util.Stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-时间相关"><span class="nav-number">2.5.5.</span> <span class="nav-text">5.时间相关</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（七）quartz和timer对比"><span class="nav-number">2.6.</span> <span class="nav-text">（七）quartz和timer对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（八）RPC"><span class="nav-number">2.7.</span> <span class="nav-text">（八）RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-设计一个RPC框架"><span class="nav-number">2.7.1.</span> <span class="nav-text">1. 设计一个RPC框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）注册中心"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">（1）注册中心</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）网络传输"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">（2）网络传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）序列化"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">（3）序列化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）动态代理"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">（4）动态代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）负载均衡"><span class="nav-number">2.7.1.5.</span> <span class="nav-text">（5）负载均衡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（九）Guava"><span class="nav-number">2.8.</span> <span class="nav-text">（九）Guava</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-如何实现限流？"><span class="nav-number">2.8.1.</span> <span class="nav-text">1. 如何实现限流？</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>


<div class="copyright">&copy; 2000 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大袤宏图</span>

  

  
</div>














        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  <!--



	





  





  









-->
  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  


  
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
