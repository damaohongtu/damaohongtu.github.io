<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="2aen8txJ9makMaGgtEKHpowVyKdkJYiySE3ojNCZAwU" />





  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java总结-4">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结-4">
<meta property="og:url" content="https://damaoguo.github.io/2019/11/20/Java总结-4/index.html">
<meta property="og:site_name" content="MaoGuo&#39;s Blog">
<meta property="og:description" content="Java总结-4">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/mysql/page.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//mysql/engine.png">
<meta property="og:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/network/rpc.png">
<meta property="og:updated_time" content="2021-06-02T03:13:19.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java总结-4">
<meta name="twitter:description" content="Java总结-4">
<meta name="twitter:image" content="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/mysql/page.png">






  <link rel="canonical" href="https://damaoguo.github.io/2019/11/20/Java总结-4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java总结-4 | MaoGuo's Blog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ea8bf9b92c205ae2c147d91b5242a6b0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/damaoguo/damaoguo.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MaoGuo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-navigation">
    <a href="/navigation/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />导航</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://damaoguo.github.io/2019/11/20/Java总结-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="袤锅">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/boy.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MaoGuo's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java总结-4
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-20 15:20:53" itemprop="dateCreated datePublished" datetime="2019-11-20T15:20:53+08:00">2019-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-06-02 11:13:19" itemprop="dateModified" datetime="2021-06-02T11:13:19+08:00">2021-06-02</time>
              
            
          </span>

          
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Java总结-4</p>
<a id="more"></a>
<h2 id="八、Redis高并发"><a href="#八、Redis高并发" class="headerlink" title="八、Redis高并发"></a>八、Redis高并发</h2><h3 id="0-Redis线程模型，为什么快？"><a href="#0-Redis线程模型，为什么快？" class="headerlink" title="0.Redis线程模型，为什么快？"></a>0.Redis线程模型，为什么快？</h3><p>Redis是基于<span style="color:red"><strong>Reactor模式</strong></span>开发了网络事件处理器，这个事件处理器叫作file event handler，这个事件是单线程的，因此说Redis是单线程模型。这个事件处理器使用IO多路复用机制监听多个socket，根据每一个socket上的事件类型选择相应的事件处理器处理这个事件。这样可以实现高性能的网络通信模型，又可以跟内部其他的单线程模块进行对接，保证了Redis内部线程模型的简单性。</p>
<pre class="mermaid">graph TB
st(( ))-.->a(文件事件处理器)
a--监听-->b(多个socket)
b-.有.->c(事件)
c--根据事件类型-->d(选择相应的事件处理器)
d--处理-->c
d-.->e(命令处理器)
d-.->f(命令回复处理器)
d-.->g(连接应答处理器)</pre>



<p>文件事件处理器结构由四个部分组成：</p>
<ul>
<li><span style="color:red">多个socket</span></li>
<li><span style="color:red">IO多路复用程序</span></li>
<li><span style="color:red">文件事件分派器</span></li>
<li><span style="color:red">事件处理器（命令处理器、命令回复处理器、连接应答处理器）</span></li>
</ul>
<p>为什么快？</p>
<ul>
<li>完全基于内存操作</li>
<li>核心是基于非阻塞的IO多路复用</li>
<li>单线程避免了上下文切换带来的性能损耗</li>
</ul>
<p><span style="color:red">Ps: netty也是基于Reactor模式实现的！</span></p>
<h3 id="1-Redis的高并发和快速原因？"><a href="#1-Redis的高并发和快速原因？" class="headerlink" title="1.Redis的高并发和快速原因？"></a>1.Redis的高并发和快速原因？</h3><p>（1）Redis是基于内存的，内存的读写速度非常快；</p>
<p>（2）Redis是单线程的，省去了很多上下文切换线程的时间；</p>
<p>（3）<span style="color:red">Redis使用多路复用技术</span>，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</p>
<h3 id="2-为什么Redis是单线程的？"><a href="#2-为什么Redis是单线程的？" class="headerlink" title="2.为什么Redis是单线程的？"></a>2.为什么Redis是单线程的？</h3><p>（1）官方答案</p>
<p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>（2）性能指标</p>
<p>关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>（3）详细原因</p>
<ul>
<li>不需要各种锁的性能消耗</li>
</ul>
<p>Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p>
<ul>
<li>单线程多进程集群方案</li>
</ul>
<p>单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。所以单线程、多进程的集群不失为一个时髦的解决方案。</p>
<ul>
<li>CPU消耗</li>
</ul>
<p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p>
<h3 id="3-Redis支持的数据结构？"><a href="#3-Redis支持的数据结构？" class="headerlink" title="3.Redis支持的数据结构？"></a>3.Redis支持的数据结构？</h3><p>(1)String：String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 </p>
<p>(2)List：list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p>
<p>(3)hash：hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。</p>
<p>(4)Set：set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p>
<p>(5)ZSet：和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<h3 id="4-redis-提供-6种数据淘汰策略？"><a href="#4-redis-提供-6种数据淘汰策略？" class="headerlink" title="4.redis 提供 6种数据淘汰策略？"></a>4.redis 提供 6种数据淘汰策略？</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">volatile-lru</td>
<td style="text-align:left">从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>最近最少使用</strong>的数据淘汰</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">volatile-ttl</td>
<td style="text-align:left">从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>将要过期的数据</strong>淘汰</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">volatile-random</td>
<td style="text-align:left">从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">allkeys-lru</td>
<td style="text-align:left">当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">allkeys-random</td>
<td style="text-align:left">从数据集（server.db[i].dict）中任意选择数据淘汰</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">no-eviction</td>
<td style="text-align:left">禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">volatile-lfu</td>
<td style="text-align:left">从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">allkeys-lfu</td>
<td style="text-align:left">当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</td>
</tr>
</tbody>
</table>
</div>
<p>Redis的过期键的删除策略？Redis使用了这两种策略。</p>
<ul>
<li>惰性过期</li>
<li>定期过期：每个一段时间，会扫描一定数量的数据库的expires字典中的key，删除其中已经过期的key。</li>
</ul>
<h3 id="5-持久化机制？"><a href="#5-持久化机制？" class="headerlink" title="5.持久化机制？"></a>5.持久化机制？</h3><blockquote>
<p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
</blockquote>
<h3 id="6-Redis事务？（REmote-DIctionary-Server-Redis-）"><a href="#6-Redis事务？（REmote-DIctionary-Server-Redis-）" class="headerlink" title="6.Redis事务？（REmote DIctionary Server(Redis)）"></a>6.Redis事务？（REmote DIctionary Server(<em>Redis</em>)）</h3><p>Redis 通过 <span style="color:red">MULTI、EXEC、WATCH 、UNWATCH等命令来实现事务(transaction)功能</span>。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p>
<h3 id="7-epoll相关的原理？"><a href="#7-epoll相关的原理？" class="headerlink" title="7.epoll相关的原理？"></a>7.epoll相关的原理？</h3><h3 id="8-redis-和-memcached-的区别？"><a href="#8-redis-和-memcached-的区别？" class="headerlink" title="8.redis 和 memcached 的区别？"></a>8.redis 和 memcached 的区别？</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">Redis</th>
<th style="text-align:left">memcached</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1（数据类型）</td>
<td style="text-align:left">Redis不仅仅支持简单的k/v类型的数据，<br>同时还提供list，set，zset，hash等数据结构的存储。</td>
<td style="text-align:left">memcache支持简单的数据类型，String。</td>
</tr>
<tr>
<td style="text-align:left">2（持久化）</td>
<td style="text-align:left">Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，<br>重启的时候可以再次加载进行使用</td>
<td style="text-align:left">Memecache把数据全部存在内存之中。</td>
</tr>
<tr>
<td style="text-align:left">3（多线程）</td>
<td style="text-align:left">是<span style="color:red">多线程，</span>非阻塞IO复用的网络模型</td>
<td style="text-align:left">Redis使用单线程的多路 IO 复用模型。</td>
</tr>
<tr>
<td style="text-align:left">4（集群）</td>
<td style="text-align:left">redis 目前是原生支持 cluster 模式的.</td>
<td style="text-align:left">memcached没有原生的集群模式，<br>需要依靠客户端来实现往集群中分片写入数据；</td>
</tr>
</tbody>
</table>
</div>
<h3 id="9-Redis的rehash？"><a href="#9-Redis的rehash？" class="headerlink" title="9.Redis的rehash？"></a>9.Redis的rehash？</h3><ul>
<li>Redis的rehash采用的是渐进式rehash。</li>
<li>rehash要和数据分片区分开！！！</li>
</ul>
<h3 id="10-redis高可用？"><a href="#10-redis高可用？" class="headerlink" title="10.redis高可用？"></a>10.redis高可用？</h3><blockquote>
<p><a href="https://www.cnblogs.com/twinhead/p/9900659.html" target="_blank" rel="noopener">https://www.cnblogs.com/twinhead/p/9900659.html</a></p>
</blockquote>
<h3 id="11-redis相关的命令？"><a href="#11-redis相关的命令？" class="headerlink" title="11.redis相关的命令？"></a>11.redis相关的命令？</h3><blockquote>
<p><a href="http://redisdoc.com/" target="_blank" rel="noopener">http://redisdoc.com/</a></p>
</blockquote>
<h3 id="12-redis集群怎么进行数据分配，hash槽？"><a href="#12-redis集群怎么进行数据分配，hash槽？" class="headerlink" title="12.redis集群怎么进行数据分配，hash槽？"></a>12.redis集群怎么进行数据分配，hash槽？</h3><h3 id="13-aof和rdb的优缺点，你在项目中使用的哪一个？"><a href="#13-aof和rdb的优缺点，你在项目中使用的哪一个？" class="headerlink" title="13.aof和rdb的优缺点，你在项目中使用的哪一个？"></a>13.aof和rdb的优缺点，你在项目中使用的哪一个？</h3><p>（默认的配置是什么？）</p>
<ul>
<li>RDB：Redis Database：fork一个子进程，将数据集写入到临时文件，写入成功后，替换原来的文件，并且使用了压缩存储。</li>
<li>AOF：Append only File</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RDB</strong></td>
<td>（1）整个Redis只包含一个dump.rdb文件，方便持久化。<br>（2）容灾性好，方便备份。<br>（3）性能最大化，fork进程完成写操作，主进程批量处理命令，所以是IO最大化。使用单独的子进程进行持久化，主进程不会有任何IO操作，保证了Redis的性能。<br>（4）相对于数据集大的时候，比AOF效率更高。</td>
<td>（1）数据安全性低。RDB是间隔一段时间进行持久化的，如果在持久化之前发生故障，会导致数据丢失。<br>（2）由于RDB是通过fork子进程来协助完成数据持久化工作的，如果数据集大，可能导致整个服务暂停服务几百毫秒，甚至更长。</td>
</tr>
<tr>
<td><strong>AOF</strong></td>
<td>（1）数据安全，存在三种同步模式，每秒同步、每次修改同步、不同步。<br>（2）通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的文件内容，可以通过redis-check-aof工具解决一致性问题。<br>（3）AOF的rewrite模式，定期对AOF文件进行重写，达到压缩的目的。</td>
<td>（1）AOF文件大。<br>（2）数据集大的时候，比rdb慢。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="14-Redis资料"><a href="#14-Redis资料" class="headerlink" title="14. Redis资料"></a>14. Redis资料</h3><blockquote>
<p><a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-3-commands-in-redis/3-5-sorted-sets/" target="_blank" rel="noopener">https://redislabs.com/ebook/part-2-core-concepts/chapter-3-commands-in-redis/3-5-sorted-sets/</a></p>
</blockquote>
<h3 id="15-Rehash"><a href="#15-Rehash" class="headerlink" title="15.Rehash"></a>15.Rehash</h3><h3 id="16-Jedis"><a href="#16-Jedis" class="headerlink" title="16.Jedis"></a>16.Jedis</h3><ul>
<li>使用zset实现积分榜</li>
<li>跳表实现</li>
</ul>
<h3 id="17-缓存雪崩、缓存击穿、缓存穿透"><a href="#17-缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="17.缓存雪崩、缓存击穿、缓存穿透"></a>17.缓存雪崩、缓存击穿、缓存穿透</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>缓存雪崩</th>
<th>缓存击穿</th>
<th>缓存穿透（一般来自攻击）</th>
</tr>
</thead>
<tbody>
<tr>
<td>现象</td>
<td>同一个事件大量的key失效，请求落在数据库上，导致数据库短时间承担了大量的请求而崩溃。<span style="color:red">（<strong>查询多条数据</strong>）</span></td>
<td>缓存中没有的数据数据库中有的数据，由于并发用户特别多，同时没有读到数据，有同时去数据库读取数据，和缓存雪崩不同，<strong>缓存击穿指的是查询同一条数据</strong>。</td>
<td>缓存和数据库中都没有数据，导致请求落在了数据库上。</td>
</tr>
<tr>
<td>原因</td>
<td>- 同一时间key大面积过期<br>- 系统刚启动的时候缓存没有数据<br></td>
<td></td>
<td></td>
</tr>
<tr>
<td>解决方案</td>
<td>- 将过期键设置为随机<br>- 缓存预热<br>- 给缓存添加标记位，记录缓存是否失效<br>- 互斥锁</td>
<td>- 设置热键永远不过期<br>- 互斥加锁</td>
<td>- 接口层校验，比如用户鉴权，基础校验拦截<br>- 从缓存中取不到、数据库中也取不到，使用key-null，并且设置过期时间。<br>- 使用布隆过滤器，将所有可能出现的数据hash到同一个bitmap中，一定不存在的数据会被这个bitmap拦截。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="18-集群机制"><a href="#18-集群机制" class="headerlink" title="18. 集群机制"></a>18. 集群机制</h3><h4 id="18-1-哨兵模式"><a href="#18-1-哨兵模式" class="headerlink" title="18.1 哨兵模式"></a>18.1 哨兵模式</h4><h4 id="18-2-cluster模式"><a href="#18-2-cluster模式" class="headerlink" title="18.2 cluster模式"></a>18.2 cluster模式</h4><h4 id="18-3-Redis-sharding（客户端分片）"><a href="#18-3-Redis-sharding（客户端分片）" class="headerlink" title="18.3 Redis sharding（客户端分片）"></a>18.3 Redis sharding（客户端分片）</h4><p>redis集群可以被分为<span style="color:red">16384个槽</span>，只有这些槽全被指派了处理的节点的情况下，集群的状态才能是上线状态(ok)<br> 操作redis集群的时候，将key作为参数，就可以计算出对应的处理槽上，所以存储等操作都应该在该槽对应的节点上。</p>
<p>重要的数据结构包括：</p>
<ul>
<li>ClusterNode：slots，numslots</li>
<li>ClusterState：slots</li>
</ul>
<h4 id="18-4-集群故障转移"><a href="#18-4-集群故障转移" class="headerlink" title="18.4 集群故障转移"></a>18.4 集群故障转移</h4><p>（1）发现故障节点</p>
<ul>
<li>集群内的节点会向其他节点发送PING命令，检查是否在线</li>
<li>如果未能在规定时间内做出PONG响应，则会把对应的节点标记为<strong>疑似下线</strong></li>
<li>集群中一半以上负责处理槽的主节点都将主节点X标记为疑似下线的话，那么这个主节点X就会被认为是<strong>已下线</strong></li>
<li>向集群广播主节点X已下线,大家收到消息后都会把自己维护的结构体里的主节点X标记为已下线</li>
</ul>
<p>（2）从节点选举</p>
<ul>
<li>当从节点发现自己复制的主节点已下线了，会向集群里面广播一条消息，要求所有有投票权的节点给自己投票(所有负责处理槽的主节点都有投票权)</li>
<li>主节点会向第一个给他发选举消息的从节点回复支持</li>
<li>当支持数量超过N/2+1的情况下，该从节点当选新的主节点</li>
</ul>
<p>（3）故障的转移</p>
<ul>
<li>新当选的从节点执行 SLAVEOF no one,修改成主节点</li>
<li>新的主节点会撤销所有已下线的老的主节点的槽指派，指派给自己</li>
<li>新的主节点向集群发送命令，通知其他节点自己已经变成主节点了，负责哪些槽指派</li>
<li>新的主节点开始处理自己负责的槽的命令</li>
</ul>
<h4 id="18-5-哨兵模式故障转移"><a href="#18-5-哨兵模式故障转移" class="headerlink" title="18.5 哨兵模式故障转移"></a>18.5 哨兵模式故障转移</h4><p>（1）主观下线</p>
<p> 哨兵(Sentinel)节点会每秒一次的频率向建立了命令连接的实例发送PING命令，如果在down-after-milliseconds毫秒内没有做出有效响应包括(PONG/LOADING/MASTERDOWN)以外的响应，哨兵就会将该实例在本结构体中的状态标记为SRI_S_DOWN主观下线。</p>
<p>（2）客观下线</p>
<p> 当一个哨兵节点发现主节点处于主观下线状态是，会向其他的哨兵节点发出询问，该节点是不是已经主观下线了。如果超过配置参数quorum个节点认为是主观下线时，该哨兵节点就会将自己维护的结构体中该主节点标记为SRI_O_DOWN客观下线</p>
<p>询问命令SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <run_id></run_id></current_epoch></port></ip></p>
<p>（3）leader选举</p>
<ul>
<li>新当选的从节点执行 SLAVEOF no one,修改成主节点</li>
</ul>
<p>（4）故障迁移</p>
<ul>
<li><p>在从节点中挑选出新的主节点（通讯正常、<strong>优先级</strong>排序、优先级相同是选择<strong>offset</strong>最大的）</p>
</li>
<li><p>将该节点设置成新的主节点 SLAVEOF no one,并确保在后续的INFO命令时，该节点返回状态为master</p>
</li>
<li><p>将其他的从节点设置成从新的主节点复制, SLAVEOF命令</p>
</li>
<li><p>将旧的主节点变成新的主节点的从节点</p>
</li>
</ul>
<h2 id="九、Kafka"><a href="#九、Kafka" class="headerlink" title="九、Kafka"></a>九、Kafka</h2><h3 id="1-kafka"><a href="#1-kafka" class="headerlink" title="1.kafka"></a>1.kafka</h3><p><a href="https://www.cnblogs.com/qingyunzong/p/9004509.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingyunzong/p/9004509.html</a></p>
<h4 id="（0）概念"><a href="#（0）概念" class="headerlink" title="（0）概念"></a>（0）概念</h4><p>kafka中有不同的broker，保存数据的是topic，一个topic被分为多个partition。一个partition又被分为多个segment，一个segment又被分为index和log两部分构成。</p>
<p>partion：负载均衡使用</p>
<p>topic中有partition，partition有副本，客服端读写都是找leader，不会找follower</p>
<p>消费者组：同组的不能够消费同一个分区，可以消费不同的分区，不同的组的可以消费同一个分区。</p>
<p>zookeeper：consumer和broker和zookeeper打交道，producer不会。</p>
<blockquote>
<p>（1）broker.id每一个broker，唯一的int类型数据 （2）delete.topic.enable （3）logs.dirs存储数据的位置 （4）zookeeper的集群 （4）配置zookeeper （5）时间 7天，168小时 （6）大小 1G kafka-server-start</p>
<ul>
<li>生产数据的流程</li>
</ul>
<p>kafka-topics —create —zookeeper hadoop：2181 —partition 2 —replication-factor —topic first</p>
<p>副本数目不能够超过broker的数目。</p>
<p>kafka-console-consumer kafka-console-producer</p>
<p>启动的进程的时候要记录进程名和id，jps -l</p>
<p>新版本：offset维护在本地，需要和leader通信，这样就会提高效率，—bootsrap-server。</p>
<p>面试的时候介绍：</p>
<p>（1）数据的流程，</p>
<p>（2）生产过程分析：</p>
<ul>
<li>每一个消息都会append到分区（partition），属于顺序写磁盘（保证吞吐率）</li>
<li>写：分区内有序，每一个消息都赋予了一个offset</li>
<li>分区原则（三种分区规则）：指定partition，直接使用；指定了key，通过key的value进行hash；都没指定就采用轮询。</li>
<li>写入流程：1）producer首先从broker-list中获取partition的leader；2）producer将消息发送给leader；3）leader将消息写入到本地的log。4）follower从leader pull消息；5）写入本地的log后向leader发送ack。</li>
<li>ACK应答（0（不管leader）,1（不管follower）,2（多完成））follower（如何producer不丢失数据—-ACK设置为2）</li>
</ul>
<p>（3）存储</p>
<p>1）broker</p>
<p>2）zookeeper</p>
<p>broker————&gt;[ids,topics,seqid],  topics————-&gt;partitions——-&gt;state</p>
<p>consumer———-&gt;offset</p>
</blockquote>
<h4 id="（1）request-required-acks来设置数据的可靠性："><a href="#（1）request-required-acks来设置数据的可靠性：" class="headerlink" title="（1）request.required.acks来设置数据的可靠性："></a>（1）<strong>request.required.acks来设置数据的可靠性：</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">可靠性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">发送即可，不管是否成功</td>
<td style="text-align:left">会丢失数据</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Leader写成功即可</td>
<td style="text-align:left">主备切换的时候可能丢失数据</td>
</tr>
<tr>
<td style="text-align:left">-1</td>
<td style="text-align:left">ISR中所有的机器写成功才算成功</td>
<td style="text-align:left">不会丢失数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（2）Kafka的用途有哪些？使用场景如何？"><a href="#（2）Kafka的用途有哪些？使用场景如何？" class="headerlink" title="（2）Kafka的用途有哪些？使用场景如何？"></a>（2）Kafka的用途有哪些？使用场景如何？</h4><h4 id="（3）Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"><a href="#（3）Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么" class="headerlink" title="（3）Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"></a>（3）Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</h4><p>Kafka的高可靠性的保障来源于其健壮的副本（replication）策略。</p>
<blockquote>
<p>ISR：排好序，最接近的顺序排序，用于leader挂了选举用的。</p>
<p>分区中的所有副本统称为AR（Assigned Repllicas）。所有与leader副本保持一定程度同步的副本（包括Leader）组成ISR（In-Sync Replicas），ISR集合是AR集合中的一个子集。消息会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间内follower副本相对于leader副本而言会有一定程度的滞后。前面所说的“一定程度”是指可以忍受的滞后范围，这个范围可以通过参数进行配置。与leader副本同步滞后过多的副本（不包括leader）副本，组成OSR(Out-Sync Relipcas),由此可见：AR=ISR+OSR。在正常情况下，所有的follower副本都应该与leader副本保持一定程度的同步，即AR=ISR,OSR集合为空。</p>
</blockquote>
<h4 id="（4）Kafka中的HW、LEO、LSO、LW等分别代表什么？"><a href="#（4）Kafka中的HW、LEO、LSO、LW等分别代表什么？" class="headerlink" title="（4）Kafka中的HW、LEO、LSO、LW等分别代表什么？"></a>（4）Kafka中的HW、LEO、LSO、LW等分别代表什么？</h4><h4 id="（5）Kafka中是怎么体现消息顺序性的？"><a href="#（5）Kafka中是怎么体现消息顺序性的？" class="headerlink" title="（5）Kafka中是怎么体现消息顺序性的？"></a>（5）Kafka中是怎么体现消息顺序性的？</h4><blockquote>
<p>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的<strong>一个</strong>消费者消费，保证了消费时也是有序的。整个topic不保证有序</p>
</blockquote>
<h4 id="（6）Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？"><a href="#（6）Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？" class="headerlink" title="（6）Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？"></a>（6）Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？</h4><h4 id="（7）Kafka生产者客户端的整体结构是什么样子的？"><a href="#（7）Kafka生产者客户端的整体结构是什么样子的？" class="headerlink" title="（7）Kafka生产者客户端的整体结构是什么样子的？"></a>（7）Kafka生产者客户端的整体结构是什么样子的？</h4><h4 id="（8）Kafka生产者客户端中使用了几个线程来处理？分别是什么？"><a href="#（8）Kafka生产者客户端中使用了几个线程来处理？分别是什么？" class="headerlink" title="（8）Kafka生产者客户端中使用了几个线程来处理？分别是什么？"></a>（8）Kafka生产者客户端中使用了几个线程来处理？分别是什么？</h4><h4 id="（9）Kafka的旧版Scala的消费者客户端的设计有什么缺陷？"><a href="#（9）Kafka的旧版Scala的消费者客户端的设计有什么缺陷？" class="headerlink" title="（9）Kafka的旧版Scala的消费者客户端的设计有什么缺陷？"></a>（9）Kafka的旧版Scala的消费者客户端的设计有什么缺陷？</h4><h4 id="（10）“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？"><a href="#（10）“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？" class="headerlink" title="（10）“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？"></a>（10）“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？</h4><h4 id="（11）消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1"><a href="#（11）消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1" class="headerlink" title="（11）消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?"></a>（11）消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?</h4><p>offset+1</p>
<h4 id="（12）有哪些情形会造成重复消费？"><a href="#（12）有哪些情形会造成重复消费？" class="headerlink" title="（12）有哪些情形会造成重复消费？"></a>（12）有哪些情形会造成重复消费？</h4><blockquote>
<p>消费者消费后没有commit offset(程序崩溃/强行kill/消费耗时/自动提交偏移情况下unscrible)</p>
</blockquote>
<h4 id="（13）那些情景下会造成消息漏消费？"><a href="#（13）那些情景下会造成消息漏消费？" class="headerlink" title="（13）那些情景下会造成消息漏消费？"></a>（13）那些情景下会造成消息漏消费？</h4><blockquote>
<p>消费者没有处理完消息 提交offset(自动提交偏移 未处理情况下程序异常结束)</p>
</blockquote>
<h4 id="（14）KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？"><a href="#（14）KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？" class="headerlink" title="（14）KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？"></a>（14）KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？</h4><h4 id="（15）简述消费者与消费组之间的关系"><a href="#（15）简述消费者与消费组之间的关系" class="headerlink" title="（15）简述消费者与消费组之间的关系"></a>（15）简述消费者与消费组之间的关系</h4><h4 id="（16）当你使用kafka-topics-sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？"><a href="#（16）当你使用kafka-topics-sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？" class="headerlink" title="（16）当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？"></a>（16）当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？</h4><blockquote>
<p>创建topic后的逻辑：</p>
<p>删除topic后的逻辑：</p>
</blockquote>
<h4 id="（17）topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？"><a href="#（17）topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？" class="headerlink" title="（17）topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？"></a>（17）topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？</h4><p>分区可以增加</p>
<h4 id="（18）topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？"><a href="#（18）topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？" class="headerlink" title="（18）topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？"></a>（18）topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？</h4><blockquote>
<p>分区不可以减少，会丢失数据.ps：topic是可以删除的。</p>
</blockquote>
<h4 id="（19）创建topic时如何选择合适的分区数？"><a href="#（19）创建topic时如何选择合适的分区数？" class="headerlink" title="（19）创建topic时如何选择合适的分区数？"></a>（19）创建topic时如何选择合适的分区数？</h4><h4 id="（20）Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？"><a href="#（20）Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？" class="headerlink" title="（20）Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？"></a>（20）Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？</h4><blockquote>
<p>__consumer_offsets 以双下划线开头，保存消费组的偏移</p>
</blockquote>
<h4 id="（21）优先副本是什么？它有什么特殊的作用？"><a href="#（21）优先副本是什么？它有什么特殊的作用？" class="headerlink" title="（21）优先副本是什么？它有什么特殊的作用？"></a>（21）优先副本是什么？它有什么特殊的作用？</h4><h4 id="（22）Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理"><a href="#（22）Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理" class="headerlink" title="（22）Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理"></a>（22）Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理</h4><h4 id="（23）简述Kafka的日志目录结构"><a href="#（23）简述Kafka的日志目录结构" class="headerlink" title="（23）简述Kafka的日志目录结构"></a>（23）简述Kafka的日志目录结构</h4><p>partition相当于一个大文件，平均分成了多个segment数据文件，每一个segment由两个文件构成×××.index （索引）和×××.log（数据）两部分组成。</p>
<h4 id="（24）Kafka中有那些索引文件？"><a href="#（24）Kafka中有那些索引文件？" class="headerlink" title="（24）Kafka中有那些索引文件？"></a>（24）Kafka中有那些索引文件？</h4><h4 id="（25）如果我指定了一个offset，Kafka怎么查找到对应的消息？"><a href="#（25）如果我指定了一个offset，Kafka怎么查找到对应的消息？" class="headerlink" title="（25）如果我指定了一个offset，Kafka怎么查找到对应的消息？"></a>（25）如果我指定了一个offset，Kafka怎么查找到对应的消息？</h4><h4 id="（26）如果我指定了一个timestamp，Kafka怎么查找到对应的消息？"><a href="#（26）如果我指定了一个timestamp，Kafka怎么查找到对应的消息？" class="headerlink" title="（26）如果我指定了一个timestamp，Kafka怎么查找到对应的消息？"></a>（26）如果我指定了一个timestamp，Kafka怎么查找到对应的消息？</h4><h4 id="（27）聊一聊你对Kafka的Log-Retention的理解"><a href="#（27）聊一聊你对Kafka的Log-Retention的理解" class="headerlink" title="（27）聊一聊你对Kafka的Log Retention的理解"></a>（27）聊一聊你对Kafka的Log Retention的理解</h4><h4 id="（28）聊一聊你对Kafka的Log-Compaction的理解"><a href="#（28）聊一聊你对Kafka的Log-Compaction的理解" class="headerlink" title="（28）聊一聊你对Kafka的Log Compaction的理解"></a>（28）聊一聊你对Kafka的Log Compaction的理解</h4><h4 id="（29）聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）"><a href="#（29）聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）" class="headerlink" title="（29）聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）"></a>（29）聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）</h4><h4 id="（30）聊一聊Kafka的延时操作的原理"><a href="#（30）聊一聊Kafka的延时操作的原理" class="headerlink" title="（30）聊一聊Kafka的延时操作的原理"></a>（30）聊一聊Kafka的延时操作的原理</h4><h4 id="（31）聊一聊Kafka控制器的作用"><a href="#（31）聊一聊Kafka控制器的作用" class="headerlink" title="（31）聊一聊Kafka控制器的作用"></a>（31）聊一聊Kafka控制器的作用</h4><h4 id="（32）消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）"><a href="#（32）消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）" class="headerlink" title="（32）消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）"></a>（32）消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）</h4><h4 id="（33）Kafka中的幂等是怎么实现的"><a href="#（33）Kafka中的幂等是怎么实现的" class="headerlink" title="（33）Kafka中的幂等是怎么实现的"></a>（33）Kafka中的幂等是怎么实现的</h4><h4 id="（34）Kafka中的事务是怎么实现的（这题我去面试6家被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ…-”）"><a href="#（34）Kafka中的事务是怎么实现的（这题我去面试6家被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ…-”）" class="headerlink" title="（34）Kafka中的事务是怎么实现的（这题我去面试6家被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ….”）"></a>（34）Kafka中的事务是怎么实现的（这题我去面试6家被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ….”）</h4><h4 id="（35）Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"><a href="#（35）Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？" class="headerlink" title="（35）Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"></a>（35）Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？</h4><h4 id="（36）失效副本是指什么？有那些应对措施？"><a href="#（36）失效副本是指什么？有那些应对措施？" class="headerlink" title="（36）失效副本是指什么？有那些应对措施？"></a>（36）失效副本是指什么？有那些应对措施？</h4><h4 id="（37）多副本下，各个副本中的HW和LEO的演变过程"><a href="#（37）多副本下，各个副本中的HW和LEO的演变过程" class="headerlink" title="（37）多副本下，各个副本中的HW和LEO的演变过程"></a>（37）多副本下，各个副本中的HW和LEO的演变过程</h4><h4 id="（38）为什么Kafka不支持读写分离？"><a href="#（38）为什么Kafka不支持读写分离？" class="headerlink" title="（38）为什么Kafka不支持读写分离？"></a>（38）为什么Kafka不支持读写分离？</h4><h4 id="（39）Kafka在可靠性方面做了哪些改进？（HW-LeaderEpoch）"><a href="#（39）Kafka在可靠性方面做了哪些改进？（HW-LeaderEpoch）" class="headerlink" title="（39）Kafka在可靠性方面做了哪些改进？（HW, LeaderEpoch）"></a>（39）Kafka在可靠性方面做了哪些改进？（HW, LeaderEpoch）</h4><h4 id="（40）Kafka中怎么实现死信队列和重试队列？"><a href="#（40）Kafka中怎么实现死信队列和重试队列？" class="headerlink" title="（40）Kafka中怎么实现死信队列和重试队列？"></a>（40）Kafka中怎么实现死信队列和重试队列？</h4><h4 id="（41）Kafka中的延迟队列怎么实现（这题被问的比事务那题还要多！！！听说你会Kafka，那你说说延迟队列怎么实现？）"><a href="#（41）Kafka中的延迟队列怎么实现（这题被问的比事务那题还要多！！！听说你会Kafka，那你说说延迟队列怎么实现？）" class="headerlink" title="（41）Kafka中的延迟队列怎么实现（这题被问的比事务那题还要多！！！听说你会Kafka，那你说说延迟队列怎么实现？）"></a>（41）Kafka中的延迟队列怎么实现（这题被问的比事务那题还要多！！！听说你会Kafka，那你说说延迟队列怎么实现？）</h4><h4 id="（42）Kafka中怎么做消息审计？"><a href="#（42）Kafka中怎么做消息审计？" class="headerlink" title="（42）Kafka中怎么做消息审计？"></a>（42）Kafka中怎么做消息审计？</h4><h4 id="（43）Kafka中怎么做消息轨迹？"><a href="#（43）Kafka中怎么做消息轨迹？" class="headerlink" title="（43）Kafka中怎么做消息轨迹？"></a>（43）Kafka中怎么做消息轨迹？</h4><h4 id="（44）Kafka中有那些配置参数比较有意思？聊一聊你的看法"><a href="#（44）Kafka中有那些配置参数比较有意思？聊一聊你的看法" class="headerlink" title="（44）Kafka中有那些配置参数比较有意思？聊一聊你的看法"></a>（44）Kafka中有那些配置参数比较有意思？聊一聊你的看法</h4><h4 id="（45）Kafka中有那些命名比较有意思？聊一聊你的看法"><a href="#（45）Kafka中有那些命名比较有意思？聊一聊你的看法" class="headerlink" title="（45）Kafka中有那些命名比较有意思？聊一聊你的看法"></a>（45）Kafka中有那些命名比较有意思？聊一聊你的看法</h4><h4 id="（46）Kafka有哪些指标需要着重关注？"><a href="#（46）Kafka有哪些指标需要着重关注？" class="headerlink" title="（46）Kafka有哪些指标需要着重关注？"></a>（46）Kafka有哪些指标需要着重关注？</h4><h4 id="（47）怎么计算Lag？"><a href="#（47）怎么计算Lag？" class="headerlink" title="（47）怎么计算Lag？"></a>（47）怎么计算Lag？</h4><h4 id="注意read-uncommitted和read-committed状态下的不同"><a href="#注意read-uncommitted和read-committed状态下的不同" class="headerlink" title="(注意read_uncommitted和read_committed状态下的不同)"></a>(注意read_uncommitted和read_committed状态下的不同)</h4><h4 id="（48）Kafka的那些设计让它有如此高的性能？"><a href="#（48）Kafka的那些设计让它有如此高的性能？" class="headerlink" title="（48）Kafka的那些设计让它有如此高的性能？"></a>（48）Kafka的那些设计让它有如此高的性能？</h4><h4 id="（49）Kafka有什么优缺点？"><a href="#（49）Kafka有什么优缺点？" class="headerlink" title="（49）Kafka有什么优缺点？"></a>（49）Kafka有什么优缺点？</h4><h4 id="（50）还用过什么同质类的其它产品，与Kafka相比有什么优缺点？为什么选择Kafka"><a href="#（50）还用过什么同质类的其它产品，与Kafka相比有什么优缺点？为什么选择Kafka" class="headerlink" title="（50）还用过什么同质类的其它产品，与Kafka相比有什么优缺点？为什么选择Kafka?"></a>（50）还用过什么同质类的其它产品，与Kafka相比有什么优缺点？为什么选择Kafka?</h4><h4 id="（51）在使用Kafka的过程中遇到过什么困难？怎么解决的？"><a href="#（51）在使用Kafka的过程中遇到过什么困难？怎么解决的？" class="headerlink" title="（51）在使用Kafka的过程中遇到过什么困难？怎么解决的？"></a>（51）在使用Kafka的过程中遇到过什么困难？怎么解决的？</h4><h4 id="（52）怎么样才能确保Kafka极大程度上的可靠性？"><a href="#（52）怎么样才能确保Kafka极大程度上的可靠性？" class="headerlink" title="（52）怎么样才能确保Kafka极大程度上的可靠性？"></a>（52）怎么样才能确保Kafka极大程度上的可靠性？</h4><h2 id="十、MySQL"><a href="#十、MySQL" class="headerlink" title="十、MySQL"></a>十、MySQL</h2><h3 id="0-MySQL结构"><a href="#0-MySQL结构" class="headerlink" title="0. MySQL结构"></a>0. MySQL结构</h3><pre class="mermaid">graph TB
A1(客户端)-.->B1(连接器)
B1-.->C1(优化器)
C1-.->D1(执行器)
D1-.->E1(存储引擎)
E1-.->F1(InnoDB)</pre>



<h3 id="1-数据库引擎？（InnoDB和MyISAM区别）"><a href="#1-数据库引擎？（InnoDB和MyISAM区别）" class="headerlink" title="1.数据库引擎？（InnoDB和MyISAM区别）"></a>1.数据库引擎？（InnoDB和MyISAM区别）</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">区别</th>
<th style="text-align:left">InnoDB</th>
<th style="text-align:left">MyISAM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">锁</td>
<td style="text-align:left">InnoDB 支持行级锁(row-level locking)和表级锁</td>
<td style="text-align:left">MyISAM 只有表级锁(table-level locking)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">索引</td>
<td style="text-align:left"><span style="color:red">（B+树，存具体数据，聚簇索引）</span>其数据文件本身就是索引文件。相比MyISAM，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，<span style="color:red">因此InnoDB表数据文件本身就是主索引</span>。这被称为“聚簇索引（或聚集索引）”。</td>
<td style="text-align:left"><span style="color:red">（B+树，存地址，非聚簇索引）</span>B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">事务</td>
<td style="text-align:left"><strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</td>
<td style="text-align:left">强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">外键</td>
<td style="text-align:left">InnoDB支持</td>
<td style="text-align:left">MyISAM不支持</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">崩溃恢复</td>
<td style="text-align:left">InnoDB支持</td>
<td style="text-align:left">MyISAM不支持</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">MVCC</td>
<td style="text-align:left">应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现</td>
<td style="text-align:left">MyISAM不支持</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/mysql/page.png" alt="img"></p>
<blockquote>
<p>特变注意，两种数据库引擎对应的文件是不同的</p>
<ul>
<li>InnoDB：由数据库的结构文件和（数据+索引）两部分构成：test_innodb_lock.frm,test_innodb_lock.idb，叶子节点存储看数据，索引文件和数据文件合并了。聚集索引：数据和索引聚集在一起了，主键索引和其他索引之间的区别：其他索引存储的是主键，主键存的是data。为什么推荐整型数据自增？主要是在分裂的时候减少平衡操作。</li>
<li>MyISAM：由数据库的结构文件，数据，索引三部分构成：test_myisam.frm,test_myisam.MYD,test_myisam.MYI，非聚集索引数据文件和索引文件是分开的。</li>
</ul>
</blockquote>
<h3 id="2-sql语句"><a href="#2-sql语句" class="headerlink" title="2.sql语句"></a>2.sql语句</h3><h4 id="（1）建立一张表格？"><a href="#（1）建立一张表格？" class="headerlink" title="（1）建立一张表格？"></a>（1）建立一张表格？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户Id'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`avatar`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="string">'https://www.tupianku.com/view/large/13862/640.jpeg'</span> <span class="keyword">COMMENT</span> <span class="string">'头像'</span>,</span><br><span class="line">  <span class="string">`resume`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'简介'</span>,</span><br><span class="line">  <span class="string">`register_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'注册时间'</span>,</span><br><span class="line">  <span class="string">`login_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'上一次登录时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ix_user_username`</span> (<span class="string">`username`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ix_user_email`</span> (<span class="string">`email`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'用户表'</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br></pre></td></tr></table></figure>
<h4 id="（2）分页limit？"><a href="#（2）分页limit？" class="headerlink" title="（2）分页limit？"></a>（2）分页limit？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.* <span class="keyword">FROM</span> 表 <span class="number">1</span> a, (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> 表 <span class="number">1</span> <span class="keyword">where</span> 条件 <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id=b.id</span><br></pre></td></tr></table></figure>
<h4 id="（3）成绩排名第三？"><a href="#（3）成绩排名第三？" class="headerlink" title="（3）成绩排名第三？"></a>（3）成绩排名第三？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> hire_date=(<span class="keyword">select</span> <span class="keyword">distinct</span> hire_date <span class="keyword">from</span> employees <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">Desc</span> <span class="keyword">limit</span> <span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>DML———数据库操作语言</p>
</li>
<li><p>DDL———数据库定义语言</p>
</li>
</ul>
<h3 id="3-什么是事务"><a href="#3-什么是事务" class="headerlink" title="3.什么是事务?"></a>3.什么是事务?</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<ul>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="4-并发事务带来哪些问题"><a href="#4-并发事务带来哪些问题" class="headerlink" title="4.并发事务带来哪些问题?"></a>4.并发事务带来哪些问题?</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">脏读(<span style="color:red">读了还没有提交的数据</span>)</td>
<td style="text-align:left">当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，<br>这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，<br>那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。（写读）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">数据丢失</td>
<td style="text-align:left">指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，<br>第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。（写写）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">不可重复读（已提交事务更改数据）</td>
<td style="text-align:left">在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。（同一个事务中多次读）(<span style="color:red">read_view在read committed隔离级别下，read_view会在别的事务commit后更新，因此在这个事务中可能会不一样)</span></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">幻读（针对其他事务已提交新增加的数据）</td>
<td style="text-align:left">它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。<br>在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录（同一个事务中多次读）(<span style="color:red">read_view在read repeatable 隔离级别下，read_view是在事务开始的时候建立的，当前的事务没有结束不会更新。)</span></td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-事务隔离级别？"><a href="#5-事务隔离级别？" class="headerlink" title="5.事务隔离级别？"></a>5.事务隔离级别？</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">read uncommitted（读取未提交）</td>
<td style="text-align:left">最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">read committed（读取已提交）</td>
<td style="text-align:left">允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">repeatable read（可重复读）</td>
<td style="text-align:left">对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。（默认的级别）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">serializable（可串行化）</td>
<td style="text-align:left">最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行</td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-MySQL-InnoDB的锁？"><a href="#6-MySQL-InnoDB的锁？" class="headerlink" title="6.MySQL InnoDB的锁？"></a>6.MySQL InnoDB的锁？</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><span style="color:red">Record lock（行锁）</span></td>
<td style="text-align:left">单个行记录上的锁</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><span style="color:red">Gap lock（间隙锁）</span></td>
<td style="text-align:left">间隙锁，锁定一个范围，不包括记录本身</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Next-key lock</td>
<td style="text-align:left">record+gap 锁定一个范围，包含记录本身</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-大表优化？"><a href="#7-大表优化？" class="headerlink" title="7.大表优化？"></a>7.大表优化？</h3><p><strong>（1）限定数据的范围</strong>：务必禁止不带任何限制数据范围条件的查询语句。</p>
<p>（<strong>2）读写分离</strong>：经典的数据库拆分方案，主库负责写，从库负责读；</p>
<p><strong>（3）垂直分表</strong></p>
<p>（<strong>4）水平分表</strong></p>
<h3 id="8-一条sql执行的过程？-基本结构-执行-日志"><a href="#8-一条sql执行的过程？-基本结构-执行-日志" class="headerlink" title="8.一条sql执行的过程？(基本结构+执行+日志)"></a>8.一条sql执行的过程？(基本结构+执行+日志)</h3><blockquote>
<p>（1）MySQL的基本架构</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93//mysql/engine.png" alt="img"></p>
<blockquote>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存:</strong>  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器:</strong>  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>  按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
</blockquote>
<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>
<blockquote>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
</blockquote>
<p>两个日志模块 redo log和bin log</p>
<blockquote>
<p>更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="9-一条sql很慢的原因？"><a href="#9-一条sql很慢的原因？" class="headerlink" title="9.一条sql很慢的原因？"></a>9.一条sql很慢的原因？</h3><blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN#rd" target="_blank" rel="noopener">参考资料</a></p>
<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<p>（1）大多数情况下很正常，偶尔很慢，则有如下原因</p>
<ul>
<li>数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</li>
<li>执行的时候，遇到锁，如表锁、行锁。</li>
</ul>
<p>（2）这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<ul>
<li>没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</li>
<li>数据库选错了索引。</li>
</ul>
</blockquote>
<h3 id="10-MySQL-join操作？"><a href="#10-MySQL-join操作？" class="headerlink" title="10.MySQL join操作？"></a>10.MySQL join操作？</h3><p><a href="https://www.cnblogs.com/reaptomorrow-flydream/p/8145610.html" target="_blank" rel="noopener">https://www.cnblogs.com/reaptomorrow-flydream/p/8145610.html</a></p>
<p>最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）、SQL LEFT JOIN、SQL  RIGHT JOIN、SQL FULL JOIN</p>
<blockquote>
<p>表A</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Google</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">淘宝</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">微博</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Facebook</td>
</tr>
</tbody>
</table>
</div>
<p>表B</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">美国</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">美国</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<h4 id="（1）Inner-join"><a href="#（1）Inner-join" class="headerlink" title="（1）Inner join"></a>（1）Inner join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Table</span> A <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">Table</span> B</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">Table</span> A.id=<span class="keyword">Table</span> B.id</span><br></pre></td></tr></table></figure>
<p>执行以上SQL输出结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Google</td>
<td style="text-align:left">美国</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">微博</td>
<td style="text-align:left">中国</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（2）left-join"><a href="#（2）left-join" class="headerlink" title="（2）left join"></a>（2）left join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Google</td>
<td style="text-align:left">美国</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">淘宝</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">微博</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Facebook</td>
<td style="text-align:left">null</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（3）right-join"><a href="#（3）right-join" class="headerlink" title="（3）right join"></a>（3）right join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Google</td>
<td style="text-align:left">美国</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">null</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">微博</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">null</td>
<td style="text-align:left">美国</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（4）outer-join"><a href="#（4）outer-join" class="headerlink" title="（4）outer join"></a>（4）outer join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Google</td>
<td style="text-align:left">美国</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">淘宝</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">微博</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">Facebook</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">null</td>
<td style="text-align:left">中国</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">null</td>
<td style="text-align:left">美国</td>
</tr>
</tbody>
</table>
</div>
<h3 id="11-MySQL索引？"><a href="#11-MySQL索引？" class="headerlink" title="11.MySQL索引？"></a>11.MySQL索引？</h3><h4 id="（0）底层的数据结构"><a href="#（0）底层的数据结构" class="headerlink" title="（0）底层的数据结构"></a>（0）底层的数据结构</h4><p>B+树，主要是考虑二叉树的深度，主要考虑的是IO特别耗时间。一个节点会存储多个索引。</p>
<blockquote>
<ul>
<li>主键索引名为pk_字段名； </li>
<li><em>唯一索引名为 uk</em>字段名； </li>
<li>普通索引名则为 idx_字段名。</li>
</ul>
</blockquote>
<h4 id="（1）索引的类别？"><a href="#（1）索引的类别？" class="headerlink" title="（1）索引的类别？"></a>（1）索引的类别？</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">普通索引</td>
<td style="text-align:left">是最基本的索引，它没有任何限制.</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">唯一索引</td>
<td style="text-align:left">与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一.</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">主键索引</td>
<td style="text-align:left">是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">组合索引</td>
<td style="text-align:left">指多个字段上创建的索引，只有在查询条件中使用了创建一个字段，索引才会被使用。使用组合索引时遵循最左前缀。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">全文索引</td>
<td style="text-align:left">主要用来查找文本中的关键字，而不是直接与索引中的值相比较.fulltext索引跟其它索引大不相同，<br>它更像是一个搜索引擎，而不是简单的，其中语句的参数匹配.fulltext索引配合匹配操作使用，而不是一般的where语句加像。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（2）Hash索引和B-树所有有什么区别或者说优劣呢"><a href="#（2）Hash索引和B-树所有有什么区别或者说优劣呢" class="headerlink" title="（2）Hash索引和B+树所有有什么区别或者说优劣呢?"></a>（2）Hash索引和B+树所有有什么区别或者说优劣呢?</h4><h4 id="（3）InnoDB为什么需要主键？"><a href="#（3）InnoDB为什么需要主键？" class="headerlink" title="（3）InnoDB为什么需要主键？"></a>（3）InnoDB为什么需要主键？</h4><h4 id="（4）B树，B-树，B-树？"><a href="#（4）B树，B-树，B-树？" class="headerlink" title="（4）B树，B-树，B+树？"></a>（4）B树，B-树，B+树？</h4><ul>
<li>B树：B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。</li>
<li>B-树：就是B树</li>
<li>B+树：在B树基础上，最大的改动是B+树叶子节点存放了关键字，添加了索引。</li>
</ul>
<h3 id="12-阿里巴巴技术手册SQL？"><a href="#12-阿里巴巴技术手册SQL？" class="headerlink" title="12.阿里巴巴技术手册SQL？"></a>12.阿里巴巴技术手册SQL？</h3><ul>
<li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。</p>
<ul>
<li>说明： 其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。 </li>
<li>gmt_create,gmt_modified 的类型均为datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</li>
</ul>
</li>
<li><p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p>
<blockquote>
<p>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p>
</blockquote>
</li>
</ul>
<h3 id="13-sql的explain？"><a href="#13-sql的explain？" class="headerlink" title="13.sql的explain？"></a>13.sql的explain？</h3><h3 id="14-超大分页处理？"><a href="#14-超大分页处理？" class="headerlink" title="14.超大分页处理？"></a>14.超大分页处理？</h3><h4 id="（1）分页limit"><a href="#（1）分页limit" class="headerlink" title="（1）分页limit"></a>（1）分页limit</h4><blockquote>
<p>【推荐】利用延迟关联或者子查询优化超多分页场景。(阿里巴巴技术手册)</p>
<p>说明： MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。 正例： 先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
<blockquote>
<p>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select <em> from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select </em> from table where id in (select id from table where age &gt; 20 limit  1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据</p>
</blockquote>
</blockquote>
<h4 id="（2）在Spring-boot中的实践？"><a href="#（2）在Spring-boot中的实践？" class="headerlink" title="（2）在Spring boot中的实践？"></a>（2）在Spring boot中的实践？</h4><h3 id="15-触发器，视图？"><a href="#15-触发器，视图？" class="headerlink" title="15.触发器，视图？"></a>15.触发器，视图？</h3><h3 id="16-什么是聚集索引？"><a href="#16-什么是聚集索引？" class="headerlink" title="16.什么是聚集索引？"></a>16.什么是聚集索引？</h3><h3 id="17-数据库如何建立索引？"><a href="#17-数据库如何建立索引？" class="headerlink" title="17.数据库如何建立索引？"></a>17.数据库如何建立索引？</h3><h3 id="18-MVCC"><a href="#18-MVCC" class="headerlink" title="18. MVCC"></a>18. MVCC</h3><ul>
<li>版本链：trx_id</li>
<li>read_view</li>
<li>undo日志</li>
<li>记录版本链</li>
<li>record header里的deleted flag设置为true</li>
<li>begin/start transaction</li>
</ul>
<p>不同的session查询到的数据可能不一致。read_view的时机生成的时机是session在执行第一条select语句，</p>
<h3 id="19-Q-amp-A？"><a href="#19-Q-amp-A？" class="headerlink" title="19. Q&amp;A？"></a>19. Q&amp;A？</h3><h4 id="19-1-简述数据库三大范式"><a href="#19-1-简述数据库三大范式" class="headerlink" title="19.1 简述数据库三大范式"></a><strong>19.1 简述数据库三大范式</strong></h4><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>数据库第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名称）中，学号-&gt;姓名，而专业编号-&gt;专业名称，不满足数据库第二范式</p>
<p>数据库第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即每个属性都跟主键有直接关系而不是间接关系。接着以学生表举例，对于关系模型（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范式。</p>
<h4 id="19-2-简述MySQL的架构"><a href="#19-2-简述MySQL的架构" class="headerlink" title="19.2 简述MySQL的架构"></a><strong>19.2 简述MySQL的架构</strong></h4><p>MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。</p>
<p>应用层：负责和客户端，响应客户端请求，建立连接，返回数据。</p>
<p>逻辑层：包括SQK接口，解析器，优化器，Cache与buffer。</p>
<p>数据库引擎层：有常见的MyISAM,InnoDB等等。</p>
<p>物理层：负责文件存储，日志等等。</p>
<h4 id="19-3-简述执行SQL语言的过程"><a href="#19-3-简述执行SQL语言的过程" class="headerlink" title="19.3 简述执行SQL语言的过程"></a><strong>19.3 简述执行SQL语言的过程</strong></h4><ol>
<li>客户端首先通过连接器进行身份认证和权限相关</li>
<li>如果是执行查询语句的时候，会先查询缓存，但MySQL 8.0 版本后该步骤移除。</li>
<li>没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。</li>
<li>通过优化器，将用户的SQL语句按照 MySQL 认为最优的方案去执行。</li>
<li>执行语句，并从存储引擎返回数据。</li>
</ol>
<h4 id="19-4-简述MySQL的共享锁排它锁"><a href="#19-4-简述MySQL的共享锁排它锁" class="headerlink" title="19.4 简述MySQL的共享锁排它锁"></a><strong>19.4 简述MySQL的共享锁排它锁</strong></h4><p>共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p>
<h4 id="19-5-简述MySQL中的按粒度的锁分类"><a href="#19-5-简述MySQL中的按粒度的锁分类" class="headerlink" title="19.5 简述MySQL中的按粒度的锁分类"></a><strong>19.5 简述MySQL中的按粒度的锁分类</strong></h4><p>表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。</p>
<p>行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>
<p>Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。</p>
<p>Next-key Lock： 行锁+gap锁。</p>
<h4 id="19-6-如何解决数据库死锁"><a href="#19-6-如何解决数据库死锁" class="headerlink" title="19.6 如何解决数据库死锁"></a><strong>19.6 如何解决数据库死锁</strong></h4><ol>
<li>预先检测到死锁的循环依赖，并立即返回一个错误。</li>
<li>当查询的时间达到锁等待超时的设定后放弃锁请求。</li>
</ol>
<h4 id="19-7-简述乐观锁和悲观锁"><a href="#19-7-简述乐观锁和悲观锁" class="headerlink" title="19.7 简述乐观锁和悲观锁"></a><strong>19.7 简述乐观锁和悲观锁</strong></h4><p>乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。</p>
<p>悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p>
<h4 id="19-8-简述InnoDB存储引擎"><a href="#19-8-简述InnoDB存储引擎" class="headerlink" title="19.8 简述InnoDB存储引擎"></a><strong>19.8 简述InnoDB存储引擎</strong></h4><p>InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。</p>
<p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p>
<h4 id="19-9-简述MyISAM存储引擎"><a href="#19-9-简述MyISAM存储引擎" class="headerlink" title="19.9 简述MyISAM存储引擎"></a><strong>19.9 简述MyISAM存储引擎</strong></h4><p>MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM不支持事务，Myisam支持表级锁，不支持行级锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况</p>
<h4 id="19-10-简述Memory存储引擎"><a href="#19-10-简述Memory存储引擎" class="headerlink" title="19.10 简述Memory存储引擎"></a><strong>19.10 简述Memory存储引擎</strong></h4><p>Memory存储引擎将所有数据都保存在内存，不需要磁盘 IO。支持哈希索引，因此查找速度极快。Memory 表使用表级锁，因此并发写入的性能较低。</p>
<h4 id="19-11索引是什么？"><a href="#19-11索引是什么？" class="headerlink" title="19.11索引是什么？"></a><strong>19.11索引是什么？</strong></h4><p>索引是存储引擎中用于快速找到记录的一种数据结构。在关系型数据库中，索引具体是一种对数据库中一列或多列的值进行排序的存储结构。</p>
<h4 id="19-12-为什么引入索引？"><a href="#19-12-为什么引入索引？" class="headerlink" title="19.12 为什么引入索引？"></a><strong>19.12 为什么引入索引？</strong></h4><p>为了提高数据查询的效率。索引对数据库查询良好的性能非常关键，当表中数据量越来越大，索引对性能的影响越重要。</p>
<p>但是，（1）索引会降低插入、删除、更新表的速度。（2）索引需要占据物理空间。聚集索引一旦改变，还需要改变非聚集索引。</p>
<h4 id="19-13-Mysql有哪些常见索引类型？"><a href="#19-13-Mysql有哪些常见索引类型？" class="headerlink" title="19.13 Mysql有哪些常见索引类型？"></a><strong>19.13 Mysql有哪些常见索引类型？</strong></h4><ul>
<li>数据结构角度<br>B-Tree索引 、哈希索引 、R-Tree索引 、全文索引（使用ES更好）</li>
</ul>
<ul>
<li>物理存储角度<br>主键索引（聚簇索引）：叶子节点存的是整行的数据 非主键索引（二级索引）：叶子节点存的主键的值</li>
</ul>
<h4 id="19-14-简述B-Tree与B-树"><a href="#19-14-简述B-Tree与B-树" class="headerlink" title="19.14 简述B-Tree与B+树"></a><strong>19.14 简述B-Tree与B+树</strong></h4><p>B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字值，且右子节点的关键字值大于或等于该节点关键字值。</p>
<p>B+树也是是一种自平衡的多叉树。其基本定义与B树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。</p>
<p>B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。</p>
<p>B树每一个节点都包含key和value，查询效率比B+树高。</p>
<h4 id="19-15-简述Hash索引"><a href="#19-15-简述Hash索引" class="headerlink" title="19.15 简述Hash索引"></a><strong>19.15 简述Hash索引</strong></h4><p>哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。只有 Memory 引擎显式支持哈希索引。</p>
<p>Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找。</p>
<h4 id="19-16-简述自适应Hash索引"><a href="#19-16-简述自适应Hash索引" class="headerlink" title="19.16 简述自适应Hash索引"></a><strong>19.16 简述自适应Hash索引</strong></h4><p>InnoDB对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应Hash索引。</p>
<h4 id="19-17-简述聚集索引和稀疏索引"><a href="#19-17-简述聚集索引和稀疏索引" class="headerlink" title="19.17 简述聚集索引和稀疏索引"></a><strong>19.17 简述聚集索引和稀疏索引</strong></h4><p>聚集索引按每张表的主键构建一棵B+树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。</p>
<p>稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺序搜索，直到找到所需的数据为止。</p>
<h4 id="19-18-简述辅助索引与回表查询"><a href="#19-18-简述辅助索引与回表查询" class="headerlink" title="19.18 简述辅助索引与回表查询"></a><strong>19.18 简述辅助索引与回表查询</strong></h4><p>辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。</p>
<p>通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查询。</p>
<h4 id="19-19-简述联合索引和最左匹配原则"><a href="#19-19-简述联合索引和最左匹配原则" class="headerlink" title="19.19 简述联合索引和最左匹配原则"></a><strong>19.19 简述联合索引和最左匹配原则</strong></h4><p>联合索引是指对表上的多个列的关键词进行索引。</p>
<p>对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则mysql会一直向右匹配直到遇到范围查询（&gt;,&lt;,between,like）就停止匹配。Mysql会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序。</p>
<p>联合索引怎么实现？<strong>采用B+树实现，每个节点含有多个关键字</strong>，排序时按照多个关键字来排序。最左前缀原则：顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上，</p>
<p>注：在创建联合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。这样的话扩展性较好。</p>
<h4 id="19-20-简述覆盖索引"><a href="#19-20-简述覆盖索引" class="headerlink" title="19.20 简述覆盖索引"></a><strong>19.20 简述覆盖索引</strong></h4><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的值。</p>
<h4 id="19-21-为什么数据库不用红黑树用B-树"><a href="#19-21-为什么数据库不用红黑树用B-树" class="headerlink" title="19.21 为什么数据库不用红黑树用B+树"></a><strong>19.21 为什么数据库不用红黑树用B+树</strong></h4><p>红黑树的出度为 2，而 B Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B Tree 大非常多，IO次数很多，导致会比较慢，因此检索的次数也就更多。</p>
<p>B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度，IO次数较少，检索效率会更高。</p>
<h4 id="19-22-基于主键索引的查询和非主键索引的查询有什么区别？"><a href="#19-22-基于主键索引的查询和非主键索引的查询有什么区别？" class="headerlink" title="19.22 基于主键索引的查询和非主键索引的查询有什么区别？"></a><strong>19.22 基于主键索引的查询和非主键索引的查询有什么区别？</strong></h4><p>对于select <em> from 主键=XX，基于主键的普通查询仅查找主键这棵树，对于select </em> from 非主键=XX，基于非主键的查询有可能存在回表过程（回到主键索引树搜索的过程称为回表），因为非主键索引叶子节点仅存主键值，无整行全部信息。</p>
<h4 id="19-23-非主键索引的查询一定会回表吗？"><a href="#19-23-非主键索引的查询一定会回表吗？" class="headerlink" title="19.23 非主键索引的查询一定会回表吗？"></a><strong>19.23 非主键索引的查询一定会回表吗？</strong></h4><p>不一定，当查询语句的要求字段全部命中索引，不用回表查询。如select 主键 from 非主键=XX，此时非主键索引叶子节点即可拿到主键信息，不用回表。</p>
<h4 id="19-24-简述MySQL使用EXPLAIN-的关键字段"><a href="#19-24-简述MySQL使用EXPLAIN-的关键字段" class="headerlink" title="19.24 简述MySQL使用EXPLAIN 的关键字段"></a><strong>19.24 简述MySQL使用EXPLAIN 的关键字段</strong></h4><p>explain关键字用于分析sql语句的执行情况，可以通过他进行sql语句的性能分析。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>type：表示连接类型，</td>
<td>从好到差的类型排序为：<br>system：系统表，数据已经加载到内存里。<br>const：常量连接，通过索引一次就找到。 <br>eq_ref：唯一性索引扫描，返回所有匹配某个单独值的行。<br>ref：非主键非唯一索引等值扫描，const或eq_ref改为普通非唯一索引。<br>range：范围扫描，在索引上扫码特定范围内的值。 index：索引树扫描，扫描索引上的全部数据。 <br>all：全表扫描。</td>
</tr>
<tr>
<td>key：显示MySQL实际决定使用的键。</td>
<td></td>
</tr>
<tr>
<td>key_len</td>
<td>显示MySQL决定使用的键长度，长度越短越好</td>
</tr>
<tr>
<td>Extra：额外信息</td>
<td>Using filesort：MySQL使用外部的索引排序，很慢需要优化。<br>Using temporary：使用了临时表保存中间结果，很慢需要优化。 <br>Using index：使用了覆盖索引。 <br>Using where：使用了where。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="19-25-简述MySQL优化流程"><a href="#19-25-简述MySQL优化流程" class="headerlink" title="19.25 简述MySQL优化流程"></a><strong>19.25 简述MySQL优化流程</strong></h4><ol>
<li>通过慢日志定位执行较慢的SQL语句</li>
<li>利用explain对这些关键字段进行分析</li>
<li>根据分析结果进行优化</li>
</ol>
<h4 id="19-26-简述MySQL中的日志log"><a href="#19-26-简述MySQL中的日志log" class="headerlink" title="19.26 简述MySQL中的日志log"></a><strong>19.26 简述MySQL中的日志log</strong></h4><p>redo log: 存储引擎级别的log（InnoDB有，MyISAM没有），该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。</p>
<p>undo log：是存储引擎级别的log（InnoDB有，MyISAM没有）保证数据的原子性，该log保存了事务发生之前的数据的一个版本，可以用于回滚，是MVCC的重要实现方法之一。</p>
<p>bin log：数据库级别的log，关注恢复数据库的数据。</p>
<h4 id="19-27-简述事务"><a href="#19-27-简述事务" class="headerlink" title="19.27 简述事务"></a><strong>19.27 简述事务</strong></h4><p>事务内的语句要么全部执行成功，要么全部执行失败。</p>
<p>事务满足如下几个特性：</p>
<ul>
<li>原子性（Atomicity）: 一个事务中的所有操作要么全部完成，要么全部不完成。</li>
</ul>
<ul>
<li>一致性（Consistency）: 事务执行前后数据库的状态保存一致。</li>
</ul>
<ul>
<li>隔离性（Isolation） 多个并发事务对数据库进行操作，事务间互不干扰。</li>
</ul>
<ul>
<li>持久性（Durability） 事务执行完毕，对数据的修改是永久的，即使系统故障也不会丢失</li>
</ul>
<h4 id="19-28-数据库中多个事务同时进行可能会出现什么问题？"><a href="#19-28-数据库中多个事务同时进行可能会出现什么问题？" class="headerlink" title="19.28 数据库中多个事务同时进行可能会出现什么问题？"></a><strong>19.28 数据库中多个事务同时进行可能会出现什么问题？</strong></h4><ul>
<li>丢失修改</li>
<li>脏读：当前事务可以查看到别的事务未提交的数据。</li>
<li>不可重读：在同一事务中，使用相同的查询语句，同一数据资源莫名改变了。</li>
<li>幻读：在同一事务中，使用相同的查询语句，莫名多出了一些之前不存在的数据，或莫名少了一些原先存在的数据。</li>
</ul>
<h4 id="19-29-SQL的事务隔离级别有哪些？"><a href="#19-29-SQL的事务隔离级别有哪些？" class="headerlink" title="19.29 SQL的事务隔离级别有哪些？"></a><strong>19.29 SQL的事务隔离级别有哪些？</strong></h4><ul>
<li><p>读未提交： 一个事务还没提交，它做的变更就能被别的事务看到。</p>
</li>
<li><p>读提交： 一个事务提交后，它做的变更才能被别的事务看到。</p>
</li>
<li><p>可重复读： 一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到。</p>
</li>
<li><p>串行化： 对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行的事务完成才能继续执行。</p>
</li>
</ul>
<h4 id="19-30-什么是MVCC？"><a href="#19-30-什么是MVCC？" class="headerlink" title="19.30 什么是MVCC？"></a><strong>19.30 什么是MVCC？</strong></h4><p>MVCC为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰,从而实现数据库的隔离性,在事务隔离级别为读提交和可重复读中使用到。</p>
<p>在InnoDB中，事务在开始前会向事务系统申请一个事务ID，该ID是按申请顺序严格递增的。每行数据具有多个版本，每次事务更新数据都会生成新的数据版本，而不会直接覆盖旧的数据版本。数据的行结构中包含多个信息字段。其中实现MVCC的主要涉及最近更改该行数据的事务ID（DB_TRX_ID）和可以找到历史数据版本的指针（DB_ROLL_PTR）。InnoDB在每个事务开启瞬间会为其构造一个记录当前已经开启但未提交的事务ID的视图数组。通过比较链表中的事务ID与该行数据的值与对应的DB_TRX_ID，并通过DB_ROLL_PTR找到历史数据的值以及对应的DB_TRX_ID来决定当前版本的数据是否应该被当前事务所见。最终实现在不加锁的情况下保证数据的一致性。</p>
<h4 id="19-31-读提交和可重复读都基于MVCC实现，有什么区别？"><a href="#19-31-读提交和可重复读都基于MVCC实现，有什么区别？" class="headerlink" title="19.31 读提交和可重复读都基于MVCC实现，有什么区别？"></a><strong>19.31 读提交和可重复读都基于MVCC实现，有什么区别？</strong></h4><p>在可重复读级别下，只会在事务开始前创建视图，事务中后续的查询共用一个视图。而读提交级别下每个语句执行前都会创建新的视图。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。而对于读提交，查询能看到每个语句启动前已经提交的数据。</p>
<h4 id="19-32-InnoDB如何保证事务的原子性、持久性和一致性？"><a href="#19-32-InnoDB如何保证事务的原子性、持久性和一致性？" class="headerlink" title="19.32 InnoDB如何保证事务的原子性、持久性和一致性？"></a><strong>19.32 InnoDB如何保证事务的原子性、持久性和一致性？</strong></h4><ul>
<li><p><span style="color:red">利用undo log保障原子性</span>。该log保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务原子性。</p>
</li>
<li><p><span style="color:red">利用redo log保证事务的持久性，</span>该log关注于事务的恢复.在重启mysql服务的时候，根据redo log进行重做，从而使事务有持久性。</p>
</li>
<li><p><span style="color:red">利用undo log+redo log保障一致性。</span>事务中的执行需要redo log，如果执行失败，需要undo log 回滚。</p>
</li>
</ul>
<h4 id="19-33-MySQL是如何保证主备一致的？"><a href="#19-33-MySQL是如何保证主备一致的？" class="headerlink" title="19.33 MySQL是如何保证主备一致的？"></a><strong>19.33 MySQL是如何保证主备一致的？</strong></h4><p>MySQL通过binlog（二进制日志）实现主备一致。<strong>binlog记录了所有修改了数据库或可能修改数据库的语句，而不会记录select、show这种不会修改数据库的语句。在备份的过程中，<span style="color:red">主库A会有一个专门的线程将主库A的binlog发送给备库B进行备份</span>。其中binlog有三种记录格式：</strong></p>
<ol>
<li>statement:记录<span style="color:red">对数据库进行修改的语句本身，</span>有可能会记录一些额外的相关信息。优点是binlog日志量少，IO压力小，性能较高。缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环境不同可能导致主备不一致。</li>
<li>row:记录<span style="color:red">对数据库做出修改的语句所影响到的数据行以及对这些行的修改</span>。比如当修改涉及多行数据，会把涉及的每行数据都记录到binlog。优点是能够完全的还原或者复制日志被记录时的操作。缺点是日志量占用空间较大，IO压力大，性能消耗较大。</li>
<li>mixed:混合使用上述两种模式，一般的语句使用statment方式进行保存，如果遇到一些特殊的函数，则使用row模式进行记录。MySQL自己会判断这条SQL语句是否可能引起主备不一致，如果有可能，就用row格式， 否则就用statement格式。但是在生产环境中，一般会使用row模式。</li>
</ol>
<h4 id="19-34-redo-log与binlog的区别？"><a href="#19-34-redo-log与binlog的区别？" class="headerlink" title="19.34 redo log与binlog的区别？"></a><strong>19.34 redo log与binlog的区别？</strong></h4><ul>
<li><p>redo log是InnoDB引擎特有的，只记录<span style="color:red">该引擎中表的修改记录。</span>binlog是MySQL的Server层实现的，会记录<span style="color:red">所有引擎对数据库的修改</span>。</p>
</li>
<li><p>redo log是物理日志，记录的是在具体某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑。</p>
</li>
<li><p>redo log是循环写的，空间固定会用完；binlog是可以追加写入的，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</li>
</ul>
<h4 id="19-35-crash-safe能力是什么？"><a href="#19-35-crash-safe能力是什么？" class="headerlink" title="19.35 crash-safe能力是什么？"></a><strong>19.35 crash-safe能力是什么？</strong></h4><p>InnoDB通过<span style="color:red">redo log保证即使数据库发生异常重启</span>，之前提交的记录都不会丢失，这个能力称为crash-safe。</p>
<h4 id="19-36-WAL技术是什么？"><a href="#19-36-WAL技术是什么？" class="headerlink" title="19.36 WAL技术是什么？"></a><strong>19.36 WAL技术是什么？</strong></h4><p>WAL的全称是Write-Ahead Logging，<span style="color:red">它的关键点就是先写日志，再写磁盘。</span>事务在提交写入磁盘前，会先写到redo log里面去。如果直接写入磁盘涉及磁盘的随机I/O访问，涉及磁盘随机I/O访问是非常消耗时间的一个过程，相比之下先写入redo log，后面再找合适的时机批量刷盘能提升性能。</p>
<h4 id="19-37-两阶段提交是什么？"><a href="#19-37-两阶段提交是什么？" class="headerlink" title="19.37 两阶段提交是什么？"></a><strong>19.37 两阶段提交是什么？</strong></h4><p>为了<span style="color:red">保证binlog和redo log两份日志的逻辑一致，最终保证恢复到主备数据库的数据是一致的，采用两阶段提交的机制。</span></p>
<ul>
<li>执行器调用存储引擎接口，存储引擎将修改更新到内存中后，<strong>将修改操作记录redo log中，此时redo log处于prepare状态。</strong></li>
<li>存储引擎告知执行器执行完毕，执行器生成这个操作对应的<strong>binlog，并把binlog写入磁盘</strong>。</li>
<li>执行器调用引擎的提交事务接口，引擎把<strong>刚刚写入的redo log改成提交commit状态，更新完成。</strong></li>
</ul>
<h4 id="19-38-只靠binlog可以支持数据库崩溃恢复吗？"><a href="#19-38-只靠binlog可以支持数据库崩溃恢复吗？" class="headerlink" title="19.38 只靠binlog可以支持数据库崩溃恢复吗？"></a><strong>19.38 只靠binlog可以支持数据库崩溃恢复吗？</strong></h4><p>不可以。 历史原因：</p>
<ol>
<li>InnoDB在作为MySQL的插件加入MySQL引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB接入了MySQL后，发现既然binlog没有崩溃恢复的能力，那引入InnoDB原有的redo log来保证崩溃恢复能力。 实现原因：</li>
<li>binlog没有记录数据页修改的详细信息，不具备恢复数据页的能力。binlog记录着数据行的增删改，但是不记录事务对数据页的改动，这样细致的改动只记录在redo log中。当一个事务做增删改时，其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动，甚至b+tree会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到redo log中。因为数据库系统进程crash时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过程。这些信息，都是binlog中没有记录的，只记录在了存储引擎的redo log中。</li>
<li>操作写入binlog可细分为write和fsync两个过程，write指的就是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘,fsync才是将数据持久化到磁盘的操作。通过参数设置sync_binlog为0的时候，表示每次提交事务都只write，不fsync。此时数据库崩溃可能导致部分提交的事务以及binlog日志由于没有持久化而丢失。</li>
</ol>
<h4 id="19-39-简述MySQL主从复制"><a href="#19-39-简述MySQL主从复制" class="headerlink" title="19.39 简述MySQL主从复制"></a><strong>19.39 简述MySQL主从复制</strong></h4><p>MySQL提供主从复制功能，可以方便的实现数据的多处自动备份，不仅能增加数据库的安全性，还能进行读写分离，提升数据库负载性能。</p>
<p>主从复制流程：</p>
<ol>
<li>在事务完成之前，<span style="color:red">主库在binlog上记录这些改变，</span>完成binlog写入过程后，主库通知存储引擎提交事物</li>
<li><span style="color:red">从库将主库的binlog复制到对应的中继日志，即开辟一个I/O工作线程，I/O线程在主库上打开一个普通的连接，然后开始binlog dump process，</span>&gt;将这些事件写入中继日志。从主库的binlog中读取事件，如果已经读到最新了，线程进入睡眠并等待ma主库产生新的事件。</li>
</ol>
<p>读写分离：即只在MySQL主库上写，只在MySQL从库上读，以减少数据库压力，提高性能。</p>
<h4 id="19-40-如何保证数据库和缓存数据一致"><a href="#19-40-如何保证数据库和缓存数据一致" class="headerlink" title="19.40 如何保证数据库和缓存数据一致"></a>19.40 如何保证数据库和缓存数据一致</h4><p>binlog刷新缓存。</p>
<h3 id="20-MySQL事务和Spring事务"><a href="#20-MySQL事务和Spring事务" class="headerlink" title="20. MySQL事务和Spring事务"></a>20. MySQL事务和Spring事务</h3><p><span style="color:red"><strong>spring事务本质上使用数据库事务，而数据库事务本质上使用数据库锁</strong>，</span>所以spring事务本质上使用数据库锁，开启spring事务意味着使用数据库锁。假如数据库不支持事务的话,spring的事务是没有作用的.数据库的事务说简单就只有开启,回滚和关闭,spring对数据库事务的包装,原理就是拿一个数据连接,根据spring的事务配置,操作这个数据连接对数据库进行事务开启,回滚或关闭操作.但是spring除了实现这些,还配合spring的传播行为对事务进行了更广泛的管理.其实这里还有个重要的点,那就是事务中涉及的隔离级别,以及spring如何对数据库的隔离级别进行封装</p>
<h4 id="20-1-Spring-事务的传播属性"><a href="#20-1-Spring-事务的传播属性" class="headerlink" title="20.1 Spring 事务的传播属性"></a>20.1 Spring 事务的传播属性</h4><p>所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表：<span style="color:red">默认的传播级别是什么？</span></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>常量名称</th>
<th>常量解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_<span style="color:red">REQUIRED</span></td>
<td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，<span style="color:red">也是 Spring 默认的事务的传播。</span></td>
</tr>
<tr>
<td>PROPAGATION_<span style="color:red">REQUIRES_NEW</span></td>
<td>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</td>
</tr>
<tr>
<td>PROPAGATION_<span style="color:red">SUPPORTS</span></td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_<span style="color:red">MANDATORY</span></td>
<td>支持当前事务，如果当前没有事务，就抛出异常。(ps: <span style="color:red">mandatory强制的; 法定的; 义务的;</span>)</td>
</tr>
<tr>
<td>PROPAGATION_<span style="color:red">NOT_SUPPORTED</span></td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_<span style="color:red">NEVER</span></td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_<span style="color:red">NESTED</span></td>
<td>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</td>
</tr>
</tbody>
</table>
</div>
<p>传播行为和数据库功能无关，只是事务管理器为了处理复杂业务而设计的一个机制。比如现在有这样一个调用场景，<code>A Service -&gt; B Service -&gt; C Service</code>，<span style="color:red">但是希望A/B在一个事务内，C是一个独立的事务，同时C如果出错，不影响AB所在的事务。</span>此时，就可以通过传播行为来处理；将C Service的事务配置为<code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code>即可</p>
<h4 id="20-2-数据库隔离级别"><a href="#20-2-数据库隔离级别" class="headerlink" title="20.2 数据库隔离级别"></a>20.2 数据库隔离级别</h4><div class="table-container">
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>隔离级别的值</th>
<th>导致的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read-Uncommitted</td>
<td>0</td>
<td>导致脏读</td>
</tr>
<tr>
<td>Read-Committed</td>
<td>1</td>
<td>避免脏读，允许不可重复读和幻读</td>
</tr>
<tr>
<td>Repeatable-Read</td>
<td>2</td>
<td>避免脏读，不可重复读，允许幻读</td>
</tr>
<tr>
<td>Serializable</td>
<td>3</td>
<td>串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重</td>
</tr>
</tbody>
</table>
</div>
<h4 id="20-3-Spring中的隔离级别"><a href="#20-3-Spring中的隔离级别" class="headerlink" title="20.3 Spring中的隔离级别"></a>20.3 Spring中的隔离级别</h4><div class="table-container">
<table>
<thead>
<tr>
<th>常量</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>这是个 PlatfromTransactionManager 默认的隔离级别，<span style="color:red">使用数据库默认的事务隔离级别</span>。另外四个与 JDBC 的隔离级别相对应。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="20-4-Spring-事务同步管理器的原理"><a href="#20-4-Spring-事务同步管理器的原理" class="headerlink" title="20.4 Spring 事务同步管理器的原理"></a>20.4 Spring 事务同步管理器的原理</h4><h5 id="20-4-1-事务管理的关键抽象"><a href="#20-4-1-事务管理的关键抽象" class="headerlink" title="20.4.1 事务管理的关键抽象"></a>20.4.1 事务管理的关键抽象</h5><pre class="mermaid">graph TB
B1(PlatformTransactionManager)<-.->A1(TransactionDefinition)
B1-.->C1(TransactionStatus)</-.-></pre>

<ul>
<li>TransactionDefinition：描述事务的隔离级别、超时时间、是否为只读事务、事务的传播规则等控制事务具体行为的事务属性。</li>
<li>PlatformTransactionManager：根据TransactionDefinition提供的事务属性配置创建事务。（采用事务管理器提交/回滚事务操作）</li>
<li>TransactionStatus：描述事务的状态。</li>
</ul>
<h5 id="20-4-2-ThreadLocal的使用"><a href="#20-4-2-ThreadLocal的使用" class="headerlink" title="20.4.2 ThreadLocal的使用"></a>20.4.2 ThreadLocal的使用</h5><p>Spring将JDBC的Connection，Hibernate的Session等访问数据库的连接或者会话对象统称为资源，这些资源在同一时刻是不能够被多线程共享的，为了让DAO，Service类可以做到singleton，Spring的事务同步管理器Transaction SynchronizationManager使用ThreadLocal为不同的事务提供独立的资源。</p>
<h5 id="20-4-3-编程式事务、申明式事务"><a href="#20-4-3-编程式事务、申明式事务" class="headerlink" title="20.4.3 编程式事务、申明式事务"></a>20.4.3 编程式事务、申明式事务</h5><ul>
<li>try catch住事务提交还是回滚？答案：<span style="color:red">提交</span>,异常没有提交给AOP拦截！！！使用@Transactional注解的时候不要使用try catch，如果try catch后需要手动使用<span style="color:red">TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span>回滚。</li>
<li></li>
</ul>
<h2 id="十一、tomcat等web服务"><a href="#十一、tomcat等web服务" class="headerlink" title="十一、tomcat等web服务"></a>十一、tomcat等web服务</h2><h2 id="十二、RPC"><a href="#十二、RPC" class="headerlink" title="十二、RPC"></a>十二、RPC</h2><p><a href="https://xiaomi-info.github.io/2020/03/02/rpc-achieve/" target="_blank" rel="noopener">https://xiaomi-info.github.io/2020/03/02/rpc-achieve/</a></p>
<ul>
<li>Proxy、InvocationHandler </li>
<li>网络通信</li>
<li>序列化、反序列化，编解码</li>
<li>管理服务地址</li>
<li>响应</li>
</ul>
<p>本文主要论述的是“RPC 实现原理”，那么首先明确一个问题什么是 RPC 呢？RPC 是 <strong>Remote Procedure Call</strong> 的缩写，即，远程过程调用。RPC 是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外地为这个交互编程。<br>值得注意是，两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样。接下来我们便来分析一下一次 RPC 调用发生了些什么？</p>
<p>现在业界内比较流行的一些 RPC 框架，例如 Dubbo 提供的是基于接口的远程方法调用，即客户端只需要知道接口的定义即可调用远程服务。<span style="color:red">在 Java 中接口并不能直接调用实例方法，必须通过其实现类对象来完成此操作，这意味着客户端必须为这些接口生成代理对象，对此 Java 提供了 Proxy、InvocationHandler 生成动态代理的支持；生成了代理对象，那么每个具体的发方法是怎么调用的呢？jdk 动态代理生成的代理对象调用指定方法时实际会执行 InvocationHandler 中定义的 #invoke 方法，在该方法中完成远程方法调用并获取结果。</span> </p>
<p>抛开客户端，回过头来看<span style="color:red"> RPC 是两台计算机间的调用</span>，实质上是两台主机间的网络通信，涉及到网络通信又必然会有<strong>序列化、反序列化</strong>，<strong>编解码</strong>等一些必须要考虑的问题；同时实际上现在大多系统都是集群部署的，多台主机/容器对外提供相同的服务，如果集群的节点数量很大的话，那么管理服务地址也将是一件十分繁琐的事情，常见的做法是各个服务节点将自己的地址和提供的服务列表注册到一个 注册中心，由 注册中心 来统一管理服务列表；这样的做法解决了一些问题同时为客户端增加了一项新的工作——那就是服务发现，通俗来说就是从注册中心中找到远程方法对应的服务列表并通过某种策略从中选取一个服务地址来完成网络通信。</p>
<p>聊了客户端和 注册中心，另外一个重要的角色自然是服务端，服务端最重要的任务便是提供服务接口的真正实现并在某个端口上监听网络请求，监听到请求后从网络请求中获取到对应的参数（比如服务接口、方法、请求参数等），再根据这些参数通过反射的方式调用接口的真正实现获取结果并将其写入对应的响应流中。</p>
<p>综上所述，一次基本的 RPC 调用流程大致如下：</p>
<p><img src="https://damaoguo.github.io/2016/11/20/Java%E6%80%BB%E7%BB%93/network/rpc.png" alt="img"></p>
<ul>
<li>生产者端流程：<ul>
<li>加载服务接口，并缓存</li>
<li>服务注册，将服务接口以及服务主机信息写入注册中心（本例使用的是 zookeeper)</li>
<li>启动网络服务器并监听</li>
<li>反射，本地调用</li>
</ul>
</li>
<li>消费者端流程：<ul>
<li>代理服务接口生成代理对象</li>
<li>服务发现（连接 zookeeper，拿到服务地址列表，通过客户端负载策略获取合适的服务地址）</li>
<li>远程方法调用（本例通过 Netty，发送消息，并获取响应结果）</li>
</ul>
</li>
</ul>
<h2 id="十三、服务发现设计"><a href="#十三、服务发现设计" class="headerlink" title="十三、服务发现设计"></a>十三、服务发现设计</h2><h3 id="1-为什么需要服务发现？"><a href="#1-为什么需要服务发现？" class="headerlink" title="1. 为什么需要服务发现？"></a>1. 为什么需要服务发现？</h3><p>​        为什么一定需要一个服务发现系统呢？服务启动的时候直接读取一个本地配置，然后通过远程配置系统，动态推送下来不行吗？实际上，当服务节点规模较小时，该方案也行得通，但如果遇到以下的场景呢？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 在微服务的世界中，服务节点的扩缩容、服务版本的迭代是常态，服务消费端需要能够快速及时的感知到节点信息的变更（网络地址、节点数量）。</td>
</tr>
<tr>
<td>2. 当服务节点规模巨大时，节点的不可用也会变成常态，服务提供者要能够及时上报自己的健康状态，从而做到及时剔除不健康节点（或降低权重）。</td>
</tr>
<tr>
<td>3. 当服务部署在多个可用区时，需要将多个可用区的服务节点信息互相同步，当某个可用区的服务不可用时，服务消费者能够及时切换到其他可用区（通过负载均衡算法自动切换或手动紧急切换），从而做到多活和高可用。</td>
</tr>
<tr>
<td>4. 服务发现背后的存储应该是分布式的，这样当部分服务发现节点不可用的时候，也能提供基本的服务发现功能</td>
</tr>
<tr>
<td>5. 除了ip、port我们需要更多的信息，比如节点权重、路由标签信息等等。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-服务发现设计？"><a href="#2-服务发现设计？" class="headerlink" title="2. 服务发现设计？"></a>2. 服务发现设计？</h3><h4 id="2-1-客户端发现模式"><a href="#2-1-客户端发现模式" class="headerlink" title="2.1 客户端发现模式"></a>2.1 客户端发现模式</h4><h4 id="2-2-服务端发现模式"><a href="#2-2-服务端发现模式" class="headerlink" title="2.2 服务端发现模式"></a>2.2 服务端发现模式</h4><h3 id="3-服务发现中的数据一致性问题"><a href="#3-服务发现中的数据一致性问题" class="headerlink" title="3. 服务发现中的数据一致性问题"></a>3. 服务发现中的数据一致性问题</h3><h3 id="4-健康检查"><a href="#4-健康检查" class="headerlink" title="4. 健康检查"></a>4. 健康检查</h3><h3 id="5-服务优雅上下线"><a href="#5-服务优雅上下线" class="headerlink" title="5. 服务优雅上下线"></a>5. 服务优雅上下线</h3><h3 id="6-容灾和高可用"><a href="#6-容灾和高可用" class="headerlink" title="6. 容灾和高可用"></a>6. 容灾和高可用</h3><h2 id="十四、设计模式"><a href="#十四、设计模式" class="headerlink" title="十四、设计模式"></a>十四、设计模式</h2><h3 id="1-设计模式大纲？"><a href="#1-设计模式大纲？" class="headerlink" title="1. 设计模式大纲？"></a>1. 设计模式大纲？</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">设计模式</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">举例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">观察者模式</td>
<td style="text-align:left">表示对象与对象之间具有依赖关系,当一个对象发生改变的时候,这个对象依赖的对象也会作出响应.(Observable,Obser)</td>
<td style="text-align:left"><span style="color:red">Spring 事件驱动模型</span>就是观察者模式很经典的⼀个应⽤。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">装饰者模式</td>
<td style="text-align:left">不修改底层代码的前提下，给对象赋予新的职责</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">工厂模式</td>
<td style="text-align:left"></td>
<td style="text-align:left">BeanFactory（AppliclicationContext）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">单例模式</td>
<td style="text-align:left">创建独一无二的，只能有一个的实例对象。(懒汉，恶汉)</td>
<td style="text-align:left">Spring Bean默认是单例模式</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">命令模式</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">适配器模式和外观模式</td>
<td style="text-align:left">适配器模式将一个接口转换成客户希望的另外一个接口,适配器模式使接口不兼容的那些类可以一起工作</td>
<td style="text-align:left">Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、Spring MVC 中也是⽤到了适配器模式适配 Controller 。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">模板方法模式</td>
<td style="text-align:left"></td>
<td style="text-align:left">Mysql，Redis，Kafaka，MongoDB（Spring中jdbcTemplate, hibernateTemplate）</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">迭代和组合模式</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">状态模式</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">代理模式</td>
<td style="text-align:left"></td>
<td style="text-align:left">Spring AOP的实现</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">复合模式</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    


    
    
    

    
      <div>
         <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    

    
      <div>
        

      </div>
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>我知道是不会有人点的，但万一有人想不开呢？</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="袤锅 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="袤锅 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/20/Java总结-1/" rel="next" title="Java总结-1">
                <i class="fa fa-chevron-left"></i> Java总结-1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/20/行业前瞻/" rel="prev" title="行业前瞻">
                行业前瞻 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
		  <!--<div>
  <font color='#FFC0CB' size=20>Mao&Ping Adventure:</font><canvas id="canvasDiyBlock" style="width:60%;">x</canvas>。
</div>
<script>
	/*生成倒计时数字*/
	function getTimeDiff(){
		var date1= '2020/10/04 00:00:00';  //开始时间  
		var date2 = new Date();    //结束时间  
		var date3 = date2.getTime() - new Date(date1).getTime();   //时间差的毫秒数        

		//计算出相差天数  
		var days=Math.floor(date3/(24*3600*1000))  
		//计算出小时数  
		var leave1=date3%(24*3600*1000)    //计算天数后剩余的毫秒数  
		var hours=Math.floor(leave1/(3600*1000))  
		//计算相差分钟数  
		var leave2=leave1%(3600*1000)        //计算小时数后剩余的毫秒数  
		var minutes=Math.floor(leave2/(60*1000))  
		//计算相差秒数  
		var leave3=leave2%(60*1000)      //计算分钟数后剩余的毫秒数  
		var seconds=Math.round(leave3/1000) 
		return ("00000"+days).substr(-5)+":"+("00"+hours).substr(-2)+":"+("00"+minutes).substr(-2)+":"+("00"+seconds).substr(-2)
	}
(function () {
  var digit =
    [
      [
        [0, 0, 1, 1, 1, 0, 0],
        [0, 1, 1, 0, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 0, 1, 1, 0],
        [0, 0, 1, 1, 1, 0, 0]
      ],//0
      [
        [0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [1, 1, 1, 1, 1, 1, 1]
      ],//1
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 1, 1, 1, 1, 1]
      ],//2
      [
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//3
      [
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 0],
        [0, 1, 1, 0, 1, 1, 0],
        [1, 1, 0, 0, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 1]
      ],//4
      [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//5
      [
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//6
      [
        [1, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0],
        [0, 0, 1, 1, 0, 0, 0]
      ],//7
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 1, 1, 0]
      ],//8
      [
        [0, 1, 1, 1, 1, 1, 0],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [1, 1, 0, 0, 0, 1, 1],
        [0, 1, 1, 1, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 0, 1, 1],
        [0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 1, 1, 0, 0],
        [0, 1, 1, 0, 0, 0, 0]
      ],//9
      [
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 1, 1, 1, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]
      ]//:
    ];

  var canvas = document.getElementById('canvasDiyBlock');

  if (canvas.getContext) {
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100, W = 1200;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10, 10, 50, 50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height / 20 - 1;
	var timeDiff = getTimeDiff();
    (function () {
      var temp = /(\d)(\d)(\d)(\d)(\d):(\d)(\d):(\d)(\d):(\d)(\d)/.exec(timeDiff);
      //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
	  // 天(万,千,百,十,个) 小时(十,个) 分钟(十，个) 秒(十 个)
      data.push(temp[1], temp[2], temp[3], temp[4], temp[5], 10, temp[6], temp[7], 10, temp[8], temp[9], 10, temp[10], temp[11]);
    })();
	

    /*生成点阵数字*/
    function renderDigit(index, num) {
      for (var i = 0; i < digit[num].length; i++) {
        for (var j = 0; j < digit[num][i].length; j++) {
          if (digit[num][i][j] == 1) {
            cxt.beginPath();
            cxt.arc(14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1), i * 2 * (R + 1) + (R + 1), R, 0, 2 * Math.PI);
            cxt.closePath();
            cxt.fill();
          }
        }
      }
    }

    /*更新时钟*/
    function updateDigitTime() {
      var changeNumArray = [];
	  var timeDiff = getTimeDiff();
      var temp = /(\d)(\d)(\d)(\d)(\d):(\d)(\d):(\d)(\d):(\d)(\d)/.exec(timeDiff);
      var NewData = [];
      NewData.push(temp[1], temp[2], temp[3], temp[4], temp[5], 10, temp[6], temp[7], 10, temp[8], temp[9], 10, temp[10], temp[11]);

      for (var i = data.length - 1; i >= 0; i--) {
        //时间发生变化
        if (NewData[i] !== data[i]) {
          //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
          changeNumArray.push(i + '_' + (Number(data[i]) + 1) % 10);
        }
      }
      //增加小球
      for (var i = 0; i < changeNumArray.length; i++) {
        addBalls.apply(this, changeNumArray[i].split('_'));
      }
      data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls() {
      for (var i = 0; i < balls.length; i++) {
        balls[i].stepY += balls[i].disY;
        balls[i].x += balls[i].stepX;
        balls[i].y += balls[i].stepY;
        if (balls[i].x > W + R || balls[i].y > H + R) {
          balls.splice(i, 1);
          i--;
        }
      }
    }

    /*增加要运动的小球*/
    function addBalls(index, num) {
      var numArray = [1, 2, 3];
      var colorArray = ["#3BE", "#09C", "#A6C", "#93C", "#9C0", "#690", "#FB3", "#F80", "#F44", "#C00"];
      for (var i = 0; i < digit[num].length; i++) {
        for (var j = 0; j < digit[num][i].length; j++) {
          if (digit[num][i][j] == 1) {
            var ball = {
              x: 14 * (R + 2) * index + j * 2 * (R + 1) + (R + 1),
              y: i * 2 * (R + 1) + (R + 1),
              stepX: Math.floor(Math.random() * 4 - 2),
              stepY: -2 * numArray[Math.floor(Math.random() * numArray.length)],
              color: colorArray[Math.floor(Math.random() * colorArray.length)],
              disY: 1
            };
            balls.push(ball);
          }
        }
      }
    }

    /*渲染*/
    function render() {
      //重置画布宽度，达到清空画布的效果
      canvas.height = 100;
      //渲染时钟
      for (var i = 0; i < data.length; i++) {
        renderDigit(i, data[i]);
      }
      //渲染小球
      for (var i = 0; i < balls.length; i++) {
        cxt.beginPath();
        cxt.arc(balls[i].x, balls[i].y, R, 0, 2 * Math.PI);
        cxt.fillStyle = balls[i].color;
        cxt.closePath();
        cxt.fill();
      }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function () {
      //更新时钟
      updateDigitTime();
      //更新小球状态
      updateBalls();
      //渲染
      render();
    }, 50);
  }
})();
</script>
-->
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjEzNC8xMjY2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/boy.jpg"
                alt="袤锅" />
            
              <p class="site-author-name" itemprop="name">袤锅</p>
              <p class="site-description motion-element" itemprop="description">我尽我力，我尽我心</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/damaoguo" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:tianmao818@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" title="Hexo个性化设置" target="_blank">Hexo个性化设置</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#八、Redis高并发"><span class="nav-number">1.</span> <span class="nav-text">八、Redis高并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-Redis线程模型，为什么快？"><span class="nav-number">1.1.</span> <span class="nav-text">0.Redis线程模型，为什么快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Redis的高并发和快速原因？"><span class="nav-number">1.2.</span> <span class="nav-text">1.Redis的高并发和快速原因？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-为什么Redis是单线程的？"><span class="nav-number">1.3.</span> <span class="nav-text">2.为什么Redis是单线程的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Redis支持的数据结构？"><span class="nav-number">1.4.</span> <span class="nav-text">3.Redis支持的数据结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-redis-提供-6种数据淘汰策略？"><span class="nav-number">1.5.</span> <span class="nav-text">4.redis 提供 6种数据淘汰策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-持久化机制？"><span class="nav-number">1.6.</span> <span class="nav-text">5.持久化机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Redis事务？（REmote-DIctionary-Server-Redis-）"><span class="nav-number">1.7.</span> <span class="nav-text">6.Redis事务？（REmote DIctionary Server(Redis)）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-epoll相关的原理？"><span class="nav-number">1.8.</span> <span class="nav-text">7.epoll相关的原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-redis-和-memcached-的区别？"><span class="nav-number">1.9.</span> <span class="nav-text">8.redis 和 memcached 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Redis的rehash？"><span class="nav-number">1.10.</span> <span class="nav-text">9.Redis的rehash？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-redis高可用？"><span class="nav-number">1.11.</span> <span class="nav-text">10.redis高可用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-redis相关的命令？"><span class="nav-number">1.12.</span> <span class="nav-text">11.redis相关的命令？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-redis集群怎么进行数据分配，hash槽？"><span class="nav-number">1.13.</span> <span class="nav-text">12.redis集群怎么进行数据分配，hash槽？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-aof和rdb的优缺点，你在项目中使用的哪一个？"><span class="nav-number">1.14.</span> <span class="nav-text">13.aof和rdb的优缺点，你在项目中使用的哪一个？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Redis资料"><span class="nav-number">1.15.</span> <span class="nav-text">14. Redis资料</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-Rehash"><span class="nav-number">1.16.</span> <span class="nav-text">15.Rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Jedis"><span class="nav-number">1.17.</span> <span class="nav-text">16.Jedis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-缓存雪崩、缓存击穿、缓存穿透"><span class="nav-number">1.18.</span> <span class="nav-text">17.缓存雪崩、缓存击穿、缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-集群机制"><span class="nav-number">1.19.</span> <span class="nav-text">18. 集群机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-1-哨兵模式"><span class="nav-number">1.19.1.</span> <span class="nav-text">18.1 哨兵模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-cluster模式"><span class="nav-number">1.19.2.</span> <span class="nav-text">18.2 cluster模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-3-Redis-sharding（客户端分片）"><span class="nav-number">1.19.3.</span> <span class="nav-text">18.3 Redis sharding（客户端分片）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-4-集群故障转移"><span class="nav-number">1.19.4.</span> <span class="nav-text">18.4 集群故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-5-哨兵模式故障转移"><span class="nav-number">1.19.5.</span> <span class="nav-text">18.5 哨兵模式故障转移</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、Kafka"><span class="nav-number">2.</span> <span class="nav-text">九、Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-kafka"><span class="nav-number">2.1.</span> <span class="nav-text">1.kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（0）概念"><span class="nav-number">2.1.1.</span> <span class="nav-text">（0）概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）request-required-acks来设置数据的可靠性："><span class="nav-number">2.1.2.</span> <span class="nav-text">（1）request.required.acks来设置数据的可靠性：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）Kafka的用途有哪些？使用场景如何？"><span class="nav-number">2.1.3.</span> <span class="nav-text">（2）Kafka的用途有哪些？使用场景如何？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"><span class="nav-number">2.1.4.</span> <span class="nav-text">（3）Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）Kafka中的HW、LEO、LSO、LW等分别代表什么？"><span class="nav-number">2.1.5.</span> <span class="nav-text">（4）Kafka中的HW、LEO、LSO、LW等分别代表什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）Kafka中是怎么体现消息顺序性的？"><span class="nav-number">2.1.6.</span> <span class="nav-text">（5）Kafka中是怎么体现消息顺序性的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（6）Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？"><span class="nav-number">2.1.7.</span> <span class="nav-text">（6）Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（7）Kafka生产者客户端的整体结构是什么样子的？"><span class="nav-number">2.1.8.</span> <span class="nav-text">（7）Kafka生产者客户端的整体结构是什么样子的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（8）Kafka生产者客户端中使用了几个线程来处理？分别是什么？"><span class="nav-number">2.1.9.</span> <span class="nav-text">（8）Kafka生产者客户端中使用了几个线程来处理？分别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（9）Kafka的旧版Scala的消费者客户端的设计有什么缺陷？"><span class="nav-number">2.1.10.</span> <span class="nav-text">（9）Kafka的旧版Scala的消费者客户端的设计有什么缺陷？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（10）“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？"><span class="nav-number">2.1.11.</span> <span class="nav-text">（10）“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（11）消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1"><span class="nav-number">2.1.12.</span> <span class="nav-text">（11）消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（12）有哪些情形会造成重复消费？"><span class="nav-number">2.1.13.</span> <span class="nav-text">（12）有哪些情形会造成重复消费？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（13）那些情景下会造成消息漏消费？"><span class="nav-number">2.1.14.</span> <span class="nav-text">（13）那些情景下会造成消息漏消费？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（14）KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？"><span class="nav-number">2.1.15.</span> <span class="nav-text">（14）KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（15）简述消费者与消费组之间的关系"><span class="nav-number">2.1.16.</span> <span class="nav-text">（15）简述消费者与消费组之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（16）当你使用kafka-topics-sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？"><span class="nav-number">2.1.17.</span> <span class="nav-text">（16）当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（17）topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？"><span class="nav-number">2.1.18.</span> <span class="nav-text">（17）topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（18）topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？"><span class="nav-number">2.1.19.</span> <span class="nav-text">（18）topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（19）创建topic时如何选择合适的分区数？"><span class="nav-number">2.1.20.</span> <span class="nav-text">（19）创建topic时如何选择合适的分区数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（20）Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？"><span class="nav-number">2.1.21.</span> <span class="nav-text">（20）Kafka目前有那些内部topic，它们都有什么特征？各自的作用又是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（21）优先副本是什么？它有什么特殊的作用？"><span class="nav-number">2.1.22.</span> <span class="nav-text">（21）优先副本是什么？它有什么特殊的作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（22）Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理"><span class="nav-number">2.1.23.</span> <span class="nav-text">（22）Kafka有哪几处地方有分区分配的概念？简述大致的过程及原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（23）简述Kafka的日志目录结构"><span class="nav-number">2.1.24.</span> <span class="nav-text">（23）简述Kafka的日志目录结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（24）Kafka中有那些索引文件？"><span class="nav-number">2.1.25.</span> <span class="nav-text">（24）Kafka中有那些索引文件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（25）如果我指定了一个offset，Kafka怎么查找到对应的消息？"><span class="nav-number">2.1.26.</span> <span class="nav-text">（25）如果我指定了一个offset，Kafka怎么查找到对应的消息？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（26）如果我指定了一个timestamp，Kafka怎么查找到对应的消息？"><span class="nav-number">2.1.27.</span> <span class="nav-text">（26）如果我指定了一个timestamp，Kafka怎么查找到对应的消息？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（27）聊一聊你对Kafka的Log-Retention的理解"><span class="nav-number">2.1.28.</span> <span class="nav-text">（27）聊一聊你对Kafka的Log Retention的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（28）聊一聊你对Kafka的Log-Compaction的理解"><span class="nav-number">2.1.29.</span> <span class="nav-text">（28）聊一聊你对Kafka的Log Compaction的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（29）聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）"><span class="nav-number">2.1.30.</span> <span class="nav-text">（29）聊一聊你对Kafka底层存储的理解（页缓存、内核层、块层、设备层）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（30）聊一聊Kafka的延时操作的原理"><span class="nav-number">2.1.31.</span> <span class="nav-text">（30）聊一聊Kafka的延时操作的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（31）聊一聊Kafka控制器的作用"><span class="nav-number">2.1.32.</span> <span class="nav-text">（31）聊一聊Kafka控制器的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（32）消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）"><span class="nav-number">2.1.33.</span> <span class="nav-text">（32）消费再均衡的原理是什么？（提示：消费者协调器和消费组协调器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（33）Kafka中的幂等是怎么实现的"><span class="nav-number">2.1.34.</span> <span class="nav-text">（33）Kafka中的幂等是怎么实现的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（34）Kafka中的事务是怎么实现的（这题我去面试6家被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ…-”）"><span class="nav-number">2.1.35.</span> <span class="nav-text">（34）Kafka中的事务是怎么实现的（这题我去面试6家被问4次，照着答案念也要念十几分钟，面试官简直凑不要脸。实在记不住的话…只要简历上不写精通Kafka一般不会问到，我简历上写的是“熟悉Kafka，了解RabbitMQ….”）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（35）Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"><span class="nav-number">2.1.36.</span> <span class="nav-text">（35）Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（36）失效副本是指什么？有那些应对措施？"><span class="nav-number">2.1.37.</span> <span class="nav-text">（36）失效副本是指什么？有那些应对措施？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（37）多副本下，各个副本中的HW和LEO的演变过程"><span class="nav-number">2.1.38.</span> <span class="nav-text">（37）多副本下，各个副本中的HW和LEO的演变过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（38）为什么Kafka不支持读写分离？"><span class="nav-number">2.1.39.</span> <span class="nav-text">（38）为什么Kafka不支持读写分离？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（39）Kafka在可靠性方面做了哪些改进？（HW-LeaderEpoch）"><span class="nav-number">2.1.40.</span> <span class="nav-text">（39）Kafka在可靠性方面做了哪些改进？（HW, LeaderEpoch）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（40）Kafka中怎么实现死信队列和重试队列？"><span class="nav-number">2.1.41.</span> <span class="nav-text">（40）Kafka中怎么实现死信队列和重试队列？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（41）Kafka中的延迟队列怎么实现（这题被问的比事务那题还要多！！！听说你会Kafka，那你说说延迟队列怎么实现？）"><span class="nav-number">2.1.42.</span> <span class="nav-text">（41）Kafka中的延迟队列怎么实现（这题被问的比事务那题还要多！！！听说你会Kafka，那你说说延迟队列怎么实现？）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（42）Kafka中怎么做消息审计？"><span class="nav-number">2.1.43.</span> <span class="nav-text">（42）Kafka中怎么做消息审计？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（43）Kafka中怎么做消息轨迹？"><span class="nav-number">2.1.44.</span> <span class="nav-text">（43）Kafka中怎么做消息轨迹？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（44）Kafka中有那些配置参数比较有意思？聊一聊你的看法"><span class="nav-number">2.1.45.</span> <span class="nav-text">（44）Kafka中有那些配置参数比较有意思？聊一聊你的看法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（45）Kafka中有那些命名比较有意思？聊一聊你的看法"><span class="nav-number">2.1.46.</span> <span class="nav-text">（45）Kafka中有那些命名比较有意思？聊一聊你的看法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（46）Kafka有哪些指标需要着重关注？"><span class="nav-number">2.1.47.</span> <span class="nav-text">（46）Kafka有哪些指标需要着重关注？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（47）怎么计算Lag？"><span class="nav-number">2.1.48.</span> <span class="nav-text">（47）怎么计算Lag？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意read-uncommitted和read-committed状态下的不同"><span class="nav-number">2.1.49.</span> <span class="nav-text">(注意read_uncommitted和read_committed状态下的不同)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（48）Kafka的那些设计让它有如此高的性能？"><span class="nav-number">2.1.50.</span> <span class="nav-text">（48）Kafka的那些设计让它有如此高的性能？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（49）Kafka有什么优缺点？"><span class="nav-number">2.1.51.</span> <span class="nav-text">（49）Kafka有什么优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（50）还用过什么同质类的其它产品，与Kafka相比有什么优缺点？为什么选择Kafka"><span class="nav-number">2.1.52.</span> <span class="nav-text">（50）还用过什么同质类的其它产品，与Kafka相比有什么优缺点？为什么选择Kafka?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（51）在使用Kafka的过程中遇到过什么困难？怎么解决的？"><span class="nav-number">2.1.53.</span> <span class="nav-text">（51）在使用Kafka的过程中遇到过什么困难？怎么解决的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（52）怎么样才能确保Kafka极大程度上的可靠性？"><span class="nav-number">2.1.54.</span> <span class="nav-text">（52）怎么样才能确保Kafka极大程度上的可靠性？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、MySQL"><span class="nav-number">3.</span> <span class="nav-text">十、MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-MySQL结构"><span class="nav-number">3.1.</span> <span class="nav-text">0. MySQL结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数据库引擎？（InnoDB和MyISAM区别）"><span class="nav-number">3.2.</span> <span class="nav-text">1.数据库引擎？（InnoDB和MyISAM区别）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-sql语句"><span class="nav-number">3.3.</span> <span class="nav-text">2.sql语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）建立一张表格？"><span class="nav-number">3.3.1.</span> <span class="nav-text">（1）建立一张表格？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）分页limit？"><span class="nav-number">3.3.2.</span> <span class="nav-text">（2）分页limit？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）成绩排名第三？"><span class="nav-number">3.3.3.</span> <span class="nav-text">（3）成绩排名第三？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-什么是事务"><span class="nav-number">3.4.</span> <span class="nav-text">3.什么是事务?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-并发事务带来哪些问题"><span class="nav-number">3.5.</span> <span class="nav-text">4.并发事务带来哪些问题?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-事务隔离级别？"><span class="nav-number">3.6.</span> <span class="nav-text">5.事务隔离级别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-MySQL-InnoDB的锁？"><span class="nav-number">3.7.</span> <span class="nav-text">6.MySQL InnoDB的锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-大表优化？"><span class="nav-number">3.8.</span> <span class="nav-text">7.大表优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-一条sql执行的过程？-基本结构-执行-日志"><span class="nav-number">3.9.</span> <span class="nav-text">8.一条sql执行的过程？(基本结构+执行+日志)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-一条sql很慢的原因？"><span class="nav-number">3.10.</span> <span class="nav-text">9.一条sql很慢的原因？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-MySQL-join操作？"><span class="nav-number">3.11.</span> <span class="nav-text">10.MySQL join操作？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）Inner-join"><span class="nav-number">3.11.1.</span> <span class="nav-text">（1）Inner join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）left-join"><span class="nav-number">3.11.2.</span> <span class="nav-text">（2）left join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）right-join"><span class="nav-number">3.11.3.</span> <span class="nav-text">（3）right join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）outer-join"><span class="nav-number">3.11.4.</span> <span class="nav-text">（4）outer join</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-MySQL索引？"><span class="nav-number">3.12.</span> <span class="nav-text">11.MySQL索引？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（0）底层的数据结构"><span class="nav-number">3.12.1.</span> <span class="nav-text">（0）底层的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）索引的类别？"><span class="nav-number">3.12.2.</span> <span class="nav-text">（1）索引的类别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）Hash索引和B-树所有有什么区别或者说优劣呢"><span class="nav-number">3.12.3.</span> <span class="nav-text">（2）Hash索引和B+树所有有什么区别或者说优劣呢?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）InnoDB为什么需要主键？"><span class="nav-number">3.12.4.</span> <span class="nav-text">（3）InnoDB为什么需要主键？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）B树，B-树，B-树？"><span class="nav-number">3.12.5.</span> <span class="nav-text">（4）B树，B-树，B+树？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-阿里巴巴技术手册SQL？"><span class="nav-number">3.13.</span> <span class="nav-text">12.阿里巴巴技术手册SQL？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-sql的explain？"><span class="nav-number">3.14.</span> <span class="nav-text">13.sql的explain？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-超大分页处理？"><span class="nav-number">3.15.</span> <span class="nav-text">14.超大分页处理？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）分页limit"><span class="nav-number">3.15.1.</span> <span class="nav-text">（1）分页limit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）在Spring-boot中的实践？"><span class="nav-number">3.15.2.</span> <span class="nav-text">（2）在Spring boot中的实践？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-触发器，视图？"><span class="nav-number">3.16.</span> <span class="nav-text">15.触发器，视图？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-什么是聚集索引？"><span class="nav-number">3.17.</span> <span class="nav-text">16.什么是聚集索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-数据库如何建立索引？"><span class="nav-number">3.18.</span> <span class="nav-text">17.数据库如何建立索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-MVCC"><span class="nav-number">3.19.</span> <span class="nav-text">18. MVCC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Q-amp-A？"><span class="nav-number">3.20.</span> <span class="nav-text">19. Q&amp;A？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#19-1-简述数据库三大范式"><span class="nav-number">3.20.1.</span> <span class="nav-text">19.1 简述数据库三大范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-2-简述MySQL的架构"><span class="nav-number">3.20.2.</span> <span class="nav-text">19.2 简述MySQL的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-3-简述执行SQL语言的过程"><span class="nav-number">3.20.3.</span> <span class="nav-text">19.3 简述执行SQL语言的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-4-简述MySQL的共享锁排它锁"><span class="nav-number">3.20.4.</span> <span class="nav-text">19.4 简述MySQL的共享锁排它锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-5-简述MySQL中的按粒度的锁分类"><span class="nav-number">3.20.5.</span> <span class="nav-text">19.5 简述MySQL中的按粒度的锁分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-6-如何解决数据库死锁"><span class="nav-number">3.20.6.</span> <span class="nav-text">19.6 如何解决数据库死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-7-简述乐观锁和悲观锁"><span class="nav-number">3.20.7.</span> <span class="nav-text">19.7 简述乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-8-简述InnoDB存储引擎"><span class="nav-number">3.20.8.</span> <span class="nav-text">19.8 简述InnoDB存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-9-简述MyISAM存储引擎"><span class="nav-number">3.20.9.</span> <span class="nav-text">19.9 简述MyISAM存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-10-简述Memory存储引擎"><span class="nav-number">3.20.10.</span> <span class="nav-text">19.10 简述Memory存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-11索引是什么？"><span class="nav-number">3.20.11.</span> <span class="nav-text">19.11索引是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-12-为什么引入索引？"><span class="nav-number">3.20.12.</span> <span class="nav-text">19.12 为什么引入索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-13-Mysql有哪些常见索引类型？"><span class="nav-number">3.20.13.</span> <span class="nav-text">19.13 Mysql有哪些常见索引类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-14-简述B-Tree与B-树"><span class="nav-number">3.20.14.</span> <span class="nav-text">19.14 简述B-Tree与B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-15-简述Hash索引"><span class="nav-number">3.20.15.</span> <span class="nav-text">19.15 简述Hash索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-16-简述自适应Hash索引"><span class="nav-number">3.20.16.</span> <span class="nav-text">19.16 简述自适应Hash索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-17-简述聚集索引和稀疏索引"><span class="nav-number">3.20.17.</span> <span class="nav-text">19.17 简述聚集索引和稀疏索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-18-简述辅助索引与回表查询"><span class="nav-number">3.20.18.</span> <span class="nav-text">19.18 简述辅助索引与回表查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-19-简述联合索引和最左匹配原则"><span class="nav-number">3.20.19.</span> <span class="nav-text">19.19 简述联合索引和最左匹配原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-20-简述覆盖索引"><span class="nav-number">3.20.20.</span> <span class="nav-text">19.20 简述覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-21-为什么数据库不用红黑树用B-树"><span class="nav-number">3.20.21.</span> <span class="nav-text">19.21 为什么数据库不用红黑树用B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-22-基于主键索引的查询和非主键索引的查询有什么区别？"><span class="nav-number">3.20.22.</span> <span class="nav-text">19.22 基于主键索引的查询和非主键索引的查询有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-23-非主键索引的查询一定会回表吗？"><span class="nav-number">3.20.23.</span> <span class="nav-text">19.23 非主键索引的查询一定会回表吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-24-简述MySQL使用EXPLAIN-的关键字段"><span class="nav-number">3.20.24.</span> <span class="nav-text">19.24 简述MySQL使用EXPLAIN 的关键字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-25-简述MySQL优化流程"><span class="nav-number">3.20.25.</span> <span class="nav-text">19.25 简述MySQL优化流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-26-简述MySQL中的日志log"><span class="nav-number">3.20.26.</span> <span class="nav-text">19.26 简述MySQL中的日志log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-27-简述事务"><span class="nav-number">3.20.27.</span> <span class="nav-text">19.27 简述事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-28-数据库中多个事务同时进行可能会出现什么问题？"><span class="nav-number">3.20.28.</span> <span class="nav-text">19.28 数据库中多个事务同时进行可能会出现什么问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-29-SQL的事务隔离级别有哪些？"><span class="nav-number">3.20.29.</span> <span class="nav-text">19.29 SQL的事务隔离级别有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-30-什么是MVCC？"><span class="nav-number">3.20.30.</span> <span class="nav-text">19.30 什么是MVCC？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-31-读提交和可重复读都基于MVCC实现，有什么区别？"><span class="nav-number">3.20.31.</span> <span class="nav-text">19.31 读提交和可重复读都基于MVCC实现，有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-32-InnoDB如何保证事务的原子性、持久性和一致性？"><span class="nav-number">3.20.32.</span> <span class="nav-text">19.32 InnoDB如何保证事务的原子性、持久性和一致性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-33-MySQL是如何保证主备一致的？"><span class="nav-number">3.20.33.</span> <span class="nav-text">19.33 MySQL是如何保证主备一致的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-34-redo-log与binlog的区别？"><span class="nav-number">3.20.34.</span> <span class="nav-text">19.34 redo log与binlog的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-35-crash-safe能力是什么？"><span class="nav-number">3.20.35.</span> <span class="nav-text">19.35 crash-safe能力是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-36-WAL技术是什么？"><span class="nav-number">3.20.36.</span> <span class="nav-text">19.36 WAL技术是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-37-两阶段提交是什么？"><span class="nav-number">3.20.37.</span> <span class="nav-text">19.37 两阶段提交是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-38-只靠binlog可以支持数据库崩溃恢复吗？"><span class="nav-number">3.20.38.</span> <span class="nav-text">19.38 只靠binlog可以支持数据库崩溃恢复吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-39-简述MySQL主从复制"><span class="nav-number">3.20.39.</span> <span class="nav-text">19.39 简述MySQL主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-40-如何保证数据库和缓存数据一致"><span class="nav-number">3.20.40.</span> <span class="nav-text">19.40 如何保证数据库和缓存数据一致</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-MySQL事务和Spring事务"><span class="nav-number">3.21.</span> <span class="nav-text">20. MySQL事务和Spring事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20-1-Spring-事务的传播属性"><span class="nav-number">3.21.1.</span> <span class="nav-text">20.1 Spring 事务的传播属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-2-数据库隔离级别"><span class="nav-number">3.21.2.</span> <span class="nav-text">20.2 数据库隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-3-Spring中的隔离级别"><span class="nav-number">3.21.3.</span> <span class="nav-text">20.3 Spring中的隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-4-Spring-事务同步管理器的原理"><span class="nav-number">3.21.4.</span> <span class="nav-text">20.4 Spring 事务同步管理器的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#20-4-1-事务管理的关键抽象"><span class="nav-number">3.21.4.1.</span> <span class="nav-text">20.4.1 事务管理的关键抽象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-4-2-ThreadLocal的使用"><span class="nav-number">3.21.4.2.</span> <span class="nav-text">20.4.2 ThreadLocal的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-4-3-编程式事务、申明式事务"><span class="nav-number">3.21.4.3.</span> <span class="nav-text">20.4.3 编程式事务、申明式事务</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、tomcat等web服务"><span class="nav-number">4.</span> <span class="nav-text">十一、tomcat等web服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、RPC"><span class="nav-number">5.</span> <span class="nav-text">十二、RPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三、服务发现设计"><span class="nav-number">6.</span> <span class="nav-text">十三、服务发现设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-为什么需要服务发现？"><span class="nav-number">6.1.</span> <span class="nav-text">1. 为什么需要服务发现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-服务发现设计？"><span class="nav-number">6.2.</span> <span class="nav-text">2. 服务发现设计？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-客户端发现模式"><span class="nav-number">6.2.1.</span> <span class="nav-text">2.1 客户端发现模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-服务端发现模式"><span class="nav-number">6.2.2.</span> <span class="nav-text">2.2 服务端发现模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-服务发现中的数据一致性问题"><span class="nav-number">6.3.</span> <span class="nav-text">3. 服务发现中的数据一致性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-健康检查"><span class="nav-number">6.4.</span> <span class="nav-text">4. 健康检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-服务优雅上下线"><span class="nav-number">6.5.</span> <span class="nav-text">5. 服务优雅上下线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-容灾和高可用"><span class="nav-number">6.6.</span> <span class="nav-text">6. 容灾和高可用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十四、设计模式"><span class="nav-number">7.</span> <span class="nav-text">十四、设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-设计模式大纲？"><span class="nav-number">7.1.</span> <span class="nav-text">1. 设计模式大纲？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>


<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">袤锅</span>

  

  
</div>





  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>




  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  


  
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


</body>
</html>
